
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docxgo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mmonterroca/docxgo/builder.go (64.2%)</option>
				
				<option value="file1">github.com/mmonterroca/docxgo/cmd/test_write/main.go (0.0%)</option>
				
				<option value="file2">github.com/mmonterroca/docxgo/docx.go (100.0%)</option>
				
				<option value="file3">github.com/mmonterroca/docxgo/domain/image.go (0.0%)</option>
				
				<option value="file4">github.com/mmonterroca/docxgo/examples/01_basic/main.go (0.0%)</option>
				
				<option value="file5">github.com/mmonterroca/docxgo/examples/02_intermediate/main.go (0.0%)</option>
				
				<option value="file6">github.com/mmonterroca/docxgo/examples/03_toc/main.go (0.0%)</option>
				
				<option value="file7">github.com/mmonterroca/docxgo/examples/04_fields/main.go (0.0%)</option>
				
				<option value="file8">github.com/mmonterroca/docxgo/examples/05_styles/main.go (0.0%)</option>
				
				<option value="file9">github.com/mmonterroca/docxgo/examples/06_sections/main.go (0.0%)</option>
				
				<option value="file10">github.com/mmonterroca/docxgo/examples/07_advanced/main.go (0.0%)</option>
				
				<option value="file11">github.com/mmonterroca/docxgo/examples/08_images/main.go (0.0%)</option>
				
				<option value="file12">github.com/mmonterroca/docxgo/examples/09_advanced_tables/main.go (0.0%)</option>
				
				<option value="file13">github.com/mmonterroca/docxgo/examples/11_multi_section/main.go (0.0%)</option>
				
				<option value="file14">github.com/mmonterroca/docxgo/internal/core/document.go (67.7%)</option>
				
				<option value="file15">github.com/mmonterroca/docxgo/internal/core/field.go (84.3%)</option>
				
				<option value="file16">github.com/mmonterroca/docxgo/internal/core/image.go (73.4%)</option>
				
				<option value="file17">github.com/mmonterroca/docxgo/internal/core/paragraph.go (21.1%)</option>
				
				<option value="file18">github.com/mmonterroca/docxgo/internal/core/run.go (36.0%)</option>
				
				<option value="file19">github.com/mmonterroca/docxgo/internal/core/section.go (75.2%)</option>
				
				<option value="file20">github.com/mmonterroca/docxgo/internal/core/table.go (75.7%)</option>
				
				<option value="file21">github.com/mmonterroca/docxgo/internal/manager/character_style.go (62.7%)</option>
				
				<option value="file22">github.com/mmonterroca/docxgo/internal/manager/id.go (0.0%)</option>
				
				<option value="file23">github.com/mmonterroca/docxgo/internal/manager/media.go (0.0%)</option>
				
				<option value="file24">github.com/mmonterroca/docxgo/internal/manager/paragraph_style.go (52.9%)</option>
				
				<option value="file25">github.com/mmonterroca/docxgo/internal/manager/relationship.go (0.0%)</option>
				
				<option value="file26">github.com/mmonterroca/docxgo/internal/manager/style.go (98.5%)</option>
				
				<option value="file27">github.com/mmonterroca/docxgo/internal/manager/table_style.go (31.7%)</option>
				
				<option value="file28">github.com/mmonterroca/docxgo/internal/serializer/serializer.go (29.2%)</option>
				
				<option value="file29">github.com/mmonterroca/docxgo/internal/writer/zip.go (58.8%)</option>
				
				<option value="file30">github.com/mmonterroca/docxgo/internal/xml/drawing_helper.go (0.0%)</option>
				
				<option value="file31">github.com/mmonterroca/docxgo/internal/xml/field.go (100.0%)</option>
				
				<option value="file32">github.com/mmonterroca/docxgo/internal/xml/headerfooter.go (100.0%)</option>
				
				<option value="file33">github.com/mmonterroca/docxgo/internal/xml/section.go (90.9%)</option>
				
				<option value="file34">github.com/mmonterroca/docxgo/internal/xml/style.go (83.3%)</option>
				
				<option value="file35">github.com/mmonterroca/docxgo/options.go (88.0%)</option>
				
				<option value="file36">github.com/mmonterroca/docxgo/pkg/color/color.go (84.4%)</option>
				
				<option value="file37">github.com/mmonterroca/docxgo/pkg/errors/errors.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package docx

import (
        "fmt"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// DocumentBuilder provides a fluent API for building Word documents.
// It accumulates errors during construction and surfaces them in Build().
//
// Example:
//
//        builder := docx.NewDocumentBuilder()
//        builder.AddParagraph().
//            Text("Hello, World!").
//            Bold().
//            FontSize(14).
//            End()
//
//        doc, err := builder.Build()
//        if err != nil {
//            log.Fatal(err)
//        }
//        doc.SaveAs("output.docx")
type DocumentBuilder struct {
        doc    domain.Document
        errors []error
}

// SectionBuilder provides a fluent API for configuring document sections.
type SectionBuilder struct {
        section domain.Section
        parent  *DocumentBuilder
        err     error
}

func (sb *SectionBuilder) recordError(err error) <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if sb.err == nil </span><span class="cov8" title="1">{
                sb.err = err
        }</span>
        <span class="cov8" title="1">if sb.parent != nil </span><span class="cov8" title="1">{
                sb.parent.errors = append(sb.parent.errors, err)
        }</span>
}

func (sb *SectionBuilder) ensureSection(op string) bool <span class="cov8" title="1">{
        if sb == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if sb.err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if sb.section == nil </span><span class="cov0" title="0">{
                sb.recordError(errors.InvalidState(op, "section is nil"))
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// PageSize sets the page size for the section (e.g., PageSizeA4, PageSizeLetter).
func (sb *SectionBuilder) PageSize(size domain.PageSize) *SectionBuilder <span class="cov8" title="1">{
        if !sb.ensureSection("SectionBuilder.PageSize") </span><span class="cov0" title="0">{
                return sb
        }</span>

        <span class="cov8" title="1">if err := sb.section.SetPageSize(size); err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// Orientation sets the page orientation for the section.
func (sb *SectionBuilder) Orientation(orient domain.Orientation) *SectionBuilder <span class="cov8" title="1">{
        if !sb.ensureSection("SectionBuilder.Orientation") </span><span class="cov0" title="0">{
                return sb
        }</span>
        <span class="cov8" title="1">if err := sb.section.SetOrientation(orient); err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// Margins sets the page margins for the section.
func (sb *SectionBuilder) Margins(margins domain.Margins) *SectionBuilder <span class="cov8" title="1">{
        if !sb.ensureSection("SectionBuilder.Margins") </span><span class="cov0" title="0">{
                return sb
        }</span>
        <span class="cov8" title="1">if err := sb.section.SetMargins(margins); err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// Columns sets the column layout for the section.
func (sb *SectionBuilder) Columns(count int) *SectionBuilder <span class="cov8" title="1">{
        if !sb.ensureSection("SectionBuilder.Columns") </span><span class="cov0" title="0">{
                return sb
        }</span>
        <span class="cov8" title="1">if err := sb.section.SetColumns(count); err != nil </span><span class="cov8" title="1">{
                sb.recordError(err)
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// Header returns the requested header for direct manipulation.
func (sb *SectionBuilder) Header(headerType domain.HeaderType) (domain.Header, error) <span class="cov8" title="1">{
        if sb == nil </span><span class="cov0" title="0">{
                return nil, errors.InvalidState("SectionBuilder.Header", "section is nil")
        }</span>
        <span class="cov8" title="1">if !sb.ensureSection("SectionBuilder.Header") </span><span class="cov0" title="0">{
                return nil, sb.err
        }</span>
        <span class="cov8" title="1">head, err := sb.section.Header(headerType)
        if err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return head, nil</span>
}

// Footer returns the requested footer for direct manipulation.
func (sb *SectionBuilder) Footer(footerType domain.FooterType) (domain.Footer, error) <span class="cov8" title="1">{
        if sb == nil </span><span class="cov0" title="0">{
                return nil, errors.InvalidState("SectionBuilder.Footer", "section is nil")
        }</span>
        <span class="cov8" title="1">if !sb.ensureSection("SectionBuilder.Footer") </span><span class="cov0" title="0">{
                return nil, sb.err
        }</span>
        <span class="cov8" title="1">foot, err := sb.section.Footer(footerType)
        if err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return foot, nil</span>
}

// Section exposes the underlying domain.Section for advanced scenarios.
func (sb *SectionBuilder) Section() domain.Section <span class="cov8" title="1">{
        if sb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return sb.section</span>
}

// End returns control to the DocumentBuilder.
func (sb *SectionBuilder) End() *DocumentBuilder <span class="cov8" title="1">{
        if sb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return sb.parent</span>
}

// NewDocumentBuilder creates a new document builder with optional configuration.
//
// Example:
//
//        builder := docx.NewDocumentBuilder(
//            docx.WithDefaultFont("Arial"),
//            docx.WithPageSize(docx.A4),
//        )
func NewDocumentBuilder(opts ...Option) *DocumentBuilder <span class="cov8" title="1">{
        config := defaultConfig()
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(config)
        }</span>

        // Create document with configuration
        <span class="cov8" title="1">doc := NewDocument()

        // Apply configuration to document
        if config.Metadata != nil </span><span class="cov8" title="1">{
                if err := doc.SetMetadata(config.Metadata); err != nil </span><span class="cov0" title="0">{
                        // Note: This error is intentionally ignored during builder initialization
                        // as metadata errors are non-critical for document creation
                        _ = err
                }</span>
        }

        <span class="cov8" title="1">return &amp;DocumentBuilder{
                doc:    doc,
                errors: make([]error, 0),
        }</span>
}

// AddParagraph adds a new paragraph to the document and returns a ParagraphBuilder.
// Errors are accumulated and returned in Build().
//
// Example:
//
//        builder.AddParagraph().
//            Text("This is a paragraph.").
//            Alignment(docx.AlignmentCenter).
//            End()
func (b *DocumentBuilder) AddParagraph() *ParagraphBuilder <span class="cov8" title="1">{
        para, err := b.doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                b.errors = append(b.errors, err)
                return &amp;ParagraphBuilder{
                        parent: b,
                        err:    err,
                }
        }</span>

        <span class="cov8" title="1">return &amp;ParagraphBuilder{
                para:   para,
                parent: b,
        }</span>
}

// AddTable adds a new table with the specified dimensions and returns a TableBuilder.
//
// Example:
//
//        builder.AddTable(3, 3).
//            Row(0).Cell(0).Text("Header 1").Bold().End().
//            Row(0).Cell(1).Text("Header 2").Bold().End().
//            End()
func (b *DocumentBuilder) AddTable(rows, cols int) *TableBuilder <span class="cov8" title="1">{
        table, err := b.doc.AddTable(rows, cols)
        if err != nil </span><span class="cov0" title="0">{
                b.errors = append(b.errors, err)
                return &amp;TableBuilder{
                        parent: b,
                        err:    err,
                }
        }</span>

        <span class="cov8" title="1">return &amp;TableBuilder{
                table:  table,
                parent: b,
        }</span>
}

// DefaultSection returns a SectionBuilder for configuring the document's default section.
// Errors are accumulated and surfaced during Build().
func (b *DocumentBuilder) DefaultSection() *SectionBuilder <span class="cov8" title="1">{
        section, err := b.doc.DefaultSection()
        sb := &amp;SectionBuilder{
                section: section,
                parent:  b,
        }
        if err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// AddSection inserts a new section with the specified break type (default NextPage).
// Returns a SectionBuilder for configuring the new section.
func (b *DocumentBuilder) AddSection(breakType ...domain.SectionBreakType) *SectionBuilder <span class="cov8" title="1">{
        bt := domain.SectionBreakTypeNextPage
        if len(breakType) &gt; 0 </span><span class="cov8" title="1">{
                bt = breakType[0]
        }</span>

        <span class="cov8" title="1">section, err := b.doc.AddSectionWithBreak(bt)
        sb := &amp;SectionBuilder{
                section: section,
                parent:  b,
        }
        if err != nil </span><span class="cov0" title="0">{
                sb.recordError(err)
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// SetMetadata sets the document metadata.
func (b *DocumentBuilder) SetMetadata(meta *domain.Metadata) *DocumentBuilder <span class="cov8" title="1">{
        if err := b.doc.SetMetadata(meta); err != nil </span><span class="cov0" title="0">{
                b.errors = append(b.errors, err)
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Build validates the document and returns it.
// All accumulated errors are returned here.
func (b *DocumentBuilder) Build() (domain.Document, error) <span class="cov8" title="1">{
        // Return first error if any accumulated
        if len(b.errors) &gt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("document build failed with %d error(s): %w", len(b.errors), b.errors[0])
        }</span>

        // Validate document structure
        <span class="cov8" title="1">if err := b.doc.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "DocumentBuilder.Build")
        }</span>

        <span class="cov8" title="1">return b.doc, nil</span>
}

// ParagraphBuilder provides a fluent API for building paragraphs.
type ParagraphBuilder struct {
        para   domain.Paragraph
        parent *DocumentBuilder
        err    error
}

// Text adds text to the paragraph.
// If multiple Text() calls are made, each creates a new run.
//
// Example:
//
//        para.Text("Hello ").Text("World")  // Creates 2 runs
func (pb *ParagraphBuilder) Text(text string) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov8" title="1">{
                return pb // Propagate error
        }</span>

        <span class="cov8" title="1">run, err := pb.para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
                return pb
        }</span>

        <span class="cov8" title="1">if err := run.SetText(text); err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// Bold makes the last run bold.
func (pb *ParagraphBuilder) Bold() *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">runs := pb.para.Runs()
        if len(runs) == 0 </span><span class="cov8" title="1">{
                pb.err = errors.InvalidState("ParagraphBuilder.Bold", "no runs to make bold")
                pb.parent.errors = append(pb.parent.errors, pb.err)
                return pb
        }</span>

        <span class="cov8" title="1">if err := runs[len(runs)-1].SetBold(true); err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// Italic makes the last run italic.
func (pb *ParagraphBuilder) Italic() *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">runs := pb.para.Runs()
        if len(runs) == 0 </span><span class="cov8" title="1">{
                pb.err = errors.InvalidState("ParagraphBuilder.Italic", "no runs to make italic")
                pb.parent.errors = append(pb.parent.errors, pb.err)
                return pb
        }</span>

        <span class="cov8" title="1">if err := runs[len(runs)-1].SetItalic(true); err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// Color sets the color of the last run.
func (pb *ParagraphBuilder) Color(color domain.Color) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov8" title="1">{
                return pb
        }</span>

        <span class="cov8" title="1">runs := pb.para.Runs()
        if len(runs) == 0 </span><span class="cov8" title="1">{
                pb.err = errors.InvalidState("ParagraphBuilder.Color", "no runs to colorize")
                pb.parent.errors = append(pb.parent.errors, pb.err)
                return pb
        }</span>

        <span class="cov8" title="1">if err := runs[len(runs)-1].SetColor(color); err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// FontSize sets the font size of the last run in points.
func (pb *ParagraphBuilder) FontSize(points int) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">runs := pb.para.Runs()
        if len(runs) == 0 </span><span class="cov8" title="1">{
                pb.err = errors.InvalidState("ParagraphBuilder.FontSize", "no runs to set font size")
                pb.parent.errors = append(pb.parent.errors, pb.err)
                return pb
        }</span>

        // Convert points to half-points
        <span class="cov8" title="1">halfPoints := points * 2
        if err := runs[len(runs)-1].SetSize(halfPoints); err != nil </span><span class="cov8" title="1">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// Alignment sets the paragraph alignment.
func (pb *ParagraphBuilder) Alignment(align domain.Alignment) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">if err := pb.para.SetAlignment(align); err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// Underline sets the underline style of the last run.
func (pb *ParagraphBuilder) Underline(style domain.UnderlineStyle) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">runs := pb.para.Runs()
        if len(runs) == 0 </span><span class="cov8" title="1">{
                pb.err = errors.InvalidState("ParagraphBuilder.Underline", "no runs to underline")
                pb.parent.errors = append(pb.parent.errors, pb.err)
                return pb
        }</span>

        <span class="cov8" title="1">if err := runs[len(runs)-1].SetUnderline(style); err != nil </span><span class="cov0" title="0">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// AddImage adds an image from a file path to the paragraph.
func (pb *ParagraphBuilder) AddImage(path string) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">if _, err := pb.para.AddImage(path); err != nil </span><span class="cov8" title="1">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// AddImageWithSize adds an image with custom dimensions.
func (pb *ParagraphBuilder) AddImageWithSize(path string, size domain.ImageSize) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">if _, err := pb.para.AddImageWithSize(path, size); err != nil </span><span class="cov8" title="1">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// AddImageWithPosition adds a floating image with custom positioning.
func (pb *ParagraphBuilder) AddImageWithPosition(path string, size domain.ImageSize, pos domain.ImagePosition) *ParagraphBuilder <span class="cov8" title="1">{
        if pb.err != nil </span><span class="cov0" title="0">{
                return pb
        }</span>

        <span class="cov8" title="1">if _, err := pb.para.AddImageWithPosition(path, size, pos); err != nil </span><span class="cov8" title="1">{
                pb.err = err
                pb.parent.errors = append(pb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return pb</span>
}

// End returns to the DocumentBuilder for further operations.
func (pb *ParagraphBuilder) End() *DocumentBuilder <span class="cov8" title="1">{
        return pb.parent
}</span>

// TableBuilder provides a fluent API for building tables.
type TableBuilder struct {
        table  domain.Table
        parent *DocumentBuilder
        err    error
}

// Row returns a RowBuilder for the specified row index.
func (tb *TableBuilder) Row(index int) *RowBuilder <span class="cov8" title="1">{
        if tb.err != nil </span><span class="cov0" title="0">{
                return &amp;RowBuilder{parent: tb, err: tb.err}
        }</span>

        <span class="cov8" title="1">row, err := tb.table.Row(index)
        if err != nil </span><span class="cov0" title="0">{
                tb.err = err
                tb.parent.errors = append(tb.parent.errors, err)
                return &amp;RowBuilder{parent: tb, err: err}
        }</span>

        <span class="cov8" title="1">return &amp;RowBuilder{
                row:    row,
                parent: tb,
        }</span>
}

// Width sets the table width.
func (tb *TableBuilder) Width(widthType domain.WidthType, value int) *TableBuilder <span class="cov8" title="1">{
        if tb.err != nil </span><span class="cov0" title="0">{
                return tb
        }</span>

        <span class="cov8" title="1">if err := tb.table.SetWidth(domain.TableWidth{Type: widthType, Value: value}); err != nil </span><span class="cov0" title="0">{
                tb.err = err
                tb.parent.errors = append(tb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return tb</span>
}

// Alignment sets the table alignment.
func (tb *TableBuilder) Alignment(align domain.Alignment) *TableBuilder <span class="cov8" title="1">{
        if tb.err != nil </span><span class="cov0" title="0">{
                return tb
        }</span>

        <span class="cov8" title="1">if err := tb.table.SetAlignment(align); err != nil </span><span class="cov0" title="0">{
                tb.err = err
                tb.parent.errors = append(tb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return tb</span>
}

// Style sets the table style.
func (tb *TableBuilder) Style(style domain.TableStyle) *TableBuilder <span class="cov8" title="1">{
        if tb.err != nil </span><span class="cov0" title="0">{
                return tb
        }</span>

        <span class="cov8" title="1">if err := tb.table.SetStyle(style); err != nil </span><span class="cov0" title="0">{
                tb.err = err
                tb.parent.errors = append(tb.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return tb</span>
}

// End returns to the DocumentBuilder.
func (tb *TableBuilder) End() *DocumentBuilder <span class="cov8" title="1">{
        return tb.parent
}</span>

// RowBuilder provides a fluent API for building table rows.
type RowBuilder struct {
        row    domain.TableRow
        parent *TableBuilder
        err    error
}

// Cell returns a CellBuilder for the specified cell index.
func (rb *RowBuilder) Cell(index int) *CellBuilder <span class="cov8" title="1">{
        if rb.err != nil </span><span class="cov0" title="0">{
                return &amp;CellBuilder{parent: rb, err: rb.err}
        }</span>

        <span class="cov8" title="1">cell, err := rb.row.Cell(index)
        if err != nil </span><span class="cov0" title="0">{
                rb.err = err
                rb.parent.parent.errors = append(rb.parent.parent.errors, err)
                return &amp;CellBuilder{parent: rb, err: err}
        }</span>

        <span class="cov8" title="1">return &amp;CellBuilder{
                cell:   cell,
                parent: rb,
        }</span>
}

// Height sets the row height.
func (rb *RowBuilder) Height(twips int) *RowBuilder <span class="cov8" title="1">{
        if rb.err != nil </span><span class="cov0" title="0">{
                return rb
        }</span>

        <span class="cov8" title="1">if err := rb.row.SetHeight(twips); err != nil </span><span class="cov0" title="0">{
                rb.err = err
                rb.parent.parent.errors = append(rb.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return rb</span>
}

// End returns to the TableBuilder.
func (rb *RowBuilder) End() *TableBuilder <span class="cov8" title="1">{
        return rb.parent
}</span>

// CellBuilder provides a fluent API for building table cells.
type CellBuilder struct {
        cell   domain.TableCell
        parent *RowBuilder
        err    error
}

// Text adds text to the cell (creates a paragraph with a run).
func (cb *CellBuilder) Text(text string) *CellBuilder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">para, err := cb.cell.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
                return cb
        }</span>

        <span class="cov8" title="1">run, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
                return cb
        }</span>

        <span class="cov8" title="1">if err := run.SetText(text); err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return cb</span>
}

// Bold makes the last run in the last paragraph bold.
func (cb *CellBuilder) Bold() *CellBuilder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">paragraphs := cb.cell.Paragraphs()
        if len(paragraphs) == 0 </span><span class="cov0" title="0">{
                cb.err = errors.InvalidState("CellBuilder.Bold", "no paragraphs in cell")
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, cb.err)
                return cb
        }</span>

        <span class="cov8" title="1">runs := paragraphs[len(paragraphs)-1].Runs()
        if len(runs) == 0 </span><span class="cov0" title="0">{
                cb.err = errors.InvalidState("CellBuilder.Bold", "no runs in paragraph")
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, cb.err)
                return cb
        }</span>

        <span class="cov8" title="1">if err := runs[len(runs)-1].SetBold(true); err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return cb</span>
}

// Width sets the cell width.
func (cb *CellBuilder) Width(twips int) *CellBuilder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">if err := cb.cell.SetWidth(twips); err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return cb</span>
}

// VerticalAlignment sets the cell vertical alignment.
func (cb *CellBuilder) VerticalAlignment(align domain.VerticalAlignment) *CellBuilder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">if err := cb.cell.SetVerticalAlignment(align); err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return cb</span>
}

// Shading sets the cell background color.
func (cb *CellBuilder) Shading(color domain.Color) *CellBuilder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">if err := cb.cell.SetShading(color); err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return cb</span>
}

// Merge merges this cell with adjacent cells.
// colspan: number of columns to span (1 = no horizontal merge)
// rowspan: number of rows to span (1 = no vertical merge)
func (cb *CellBuilder) Merge(colspan, rowspan int) *CellBuilder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">if err := cb.cell.Merge(colspan, rowspan); err != nil </span><span class="cov0" title="0">{
                cb.err = err
                cb.parent.parent.parent.errors = append(cb.parent.parent.parent.errors, err)
        }</span>

        <span class="cov8" title="1">return cb</span>
}

// End returns to the RowBuilder.
func (cb *CellBuilder) End() *RowBuilder <span class="cov8" title="1">{
        return cb.parent
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Command test_write demonstrates basic document creation and writing using go-docx.
package main

import (
        "bytes"
        "fmt"

        "github.com/mmonterroca/docxgo/internal/core"
)

func main() <span class="cov0" title="0">{
        // Create document
        doc := core.NewDocument()

        para, _ := doc.AddParagraph()
        run, _ := para.AddRun()
        if err := run.SetText("Hello, World!"); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error setting text: %v\n", err)
                return
        }</span>

        // Write to buffer
        <span class="cov0" title="0">var buf bytes.Buffer
        if _, err := doc.WriteTo(&amp;buf); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated .docx file: %d bytes\n", buf.Len())
        fmt.Println("Success! File written to memory")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package docx

import (
        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/core"
        "github.com/mmonterroca/docxgo/pkg/color"
)

// NewDocument creates a new empty Word document.
// The document is created with default settings and an empty body.
//
// Example:
//
//        doc := docx.NewDocument()
//        para, _ := doc.AddParagraph()
//        run, _ := para.AddRun()
//        run.AddText("Hello, World!")
//        doc.SaveToFile("hello.docx")
func NewDocument() domain.Document <span class="cov8" title="1">{
        return core.NewDocument()
}</span>

// Version is the library version.
const Version = "2.0.0-beta"

// Common color constants exported for convenience.
var (
        Black   = color.Black
        White   = color.White
        Red     = color.Red
        Green   = color.Green
        Blue    = color.Blue
        Yellow  = color.Yellow
        Cyan    = color.Cyan
        Magenta = color.Magenta
        Orange  = color.Orange
        Purple  = color.Purple
        Gray    = color.Gray
        Silver  = color.Silver
)

// Common alignment constants exported for convenience.
const (
        AlignmentLeft       = domain.AlignmentLeft
        AlignmentCenter     = domain.AlignmentCenter
        AlignmentRight      = domain.AlignmentRight
        AlignmentJustify    = domain.AlignmentJustify
        AlignmentDistribute = domain.AlignmentDistribute
)

// Common underline constants exported for convenience.
const (
        UnderlineNone   = domain.UnderlineNone
        UnderlineSingle = domain.UnderlineSingle
        UnderlineDouble = domain.UnderlineDouble
        UnderlineThick  = domain.UnderlineThick
        UnderlineDotted = domain.UnderlineDotted
        UnderlineDashed = domain.UnderlineDashed
        UnderlineWave   = domain.UnderlineWave
)

// Common break type constants exported for convenience.
const (
        BreakTypePage   = domain.BreakTypePage
        BreakTypeColumn = domain.BreakTypeColumn
        BreakTypeLine   = domain.BreakTypeLine
)

// Field creation functions

// NewField creates a new field of the specified type.
// Use the specific factory functions (NewPageNumberField, NewTOCField, etc.)
// for most use cases.
func NewField(fieldType domain.FieldType) domain.Field <span class="cov8" title="1">{
        return core.NewField(fieldType)
}</span>

// NewPageNumberField creates a field that displays the current page number.
//
// Example:
//
//        footer, _ := section.Footer(domain.FooterDefault)
//        para, _ := footer.AddParagraph()
//        run, _ := para.AddRun()
//        run.AddField(docx.NewPageNumberField())
func NewPageNumberField() domain.Field <span class="cov8" title="1">{
        return core.NewPageNumberField()
}</span>

// NewPageCountField creates a field that displays the total number of pages.
//
// Example:
//
//        run, _ := para.AddRun()
//        run.AddText("Page ")
//        run2, _ := para.AddRun()
//        run2.AddField(docx.NewPageNumberField())
//        run3, _ := para.AddRun()
//        run3.AddText(" of ")
//        run4, _ := para.AddRun()
//        run4.AddField(docx.NewPageCountField())
func NewPageCountField() domain.Field <span class="cov8" title="1">{
        return core.NewPageCountField()
}</span>

// NewTOCField creates a Table of Contents field.
// The switches map accepts standard Word TOC switches:
//   - "levels": Heading levels to include (e.g., "1-3")
//   - "hyperlinks": Whether to make TOC entries clickable ("true"/"false")
//   - "hidePageNumbers": Whether to hide page numbers ("true"/"false")
//
// Example:
//
//        tocOptions := map[string]string{
//            "levels":     "1-3",
//            "hyperlinks": "true",
//        }
//        run.AddField(docx.NewTOCField(tocOptions))
func NewTOCField(switches map[string]string) domain.Field <span class="cov8" title="1">{
        return core.NewTOCField(switches)
}</span>

// NewHyperlinkField creates a clickable hyperlink field.
// The url parameter should be a complete URL (http://, https://, mailto:, etc.)
// The displayText is what the user sees in the document.
//
// Example:
//
//        run, _ := para.AddRun()
//        linkField := docx.NewHyperlinkField(
//            "https://github.com/mmonterroca/docxgo",
//            "go-docx Repository",
//        )
//        run.SetColor(0x0000FF) // Blue
//        run.SetUnderline(domain.UnderlineSingle)
//        run.AddField(linkField)
func NewHyperlinkField(url, displayText string) domain.Field <span class="cov8" title="1">{
        return core.NewHyperlinkField(url, displayText)
}</span>

// NewStyleRefField creates a field that references the last paragraph
// of the specified style (useful for running headers showing chapter titles).
//
// Example:
//
//        // In header, show the current chapter (last Heading1)
//        header, _ := section.Header(domain.HeaderDefault)
//        para, _ := header.AddParagraph()
//        run, _ := para.AddRun()
//        run.AddField(docx.NewStyleRefField("Heading 1"))
func NewStyleRefField(styleName string) domain.Field <span class="cov8" title="1">{
        return core.NewStyleRefField(styleName)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package domain

// ImageFormat represents supported image file formats.
type ImageFormat string

// Supported image format constants.
const (
        ImageFormatPNG  ImageFormat = "png"  // PNG format
        ImageFormatJPEG ImageFormat = "jpeg" // JPEG format (full name)
        ImageFormatJPG  ImageFormat = "jpg"  // JPEG format (short name)
        ImageFormatGIF  ImageFormat = "gif"  // GIF format
        ImageFormatBMP  ImageFormat = "bmp"  // BMP format
        ImageFormatTIFF ImageFormat = "tiff" // TIFF format (full name)
        ImageFormatTIF  ImageFormat = "tif"  // TIFF format (short name)
        ImageFormatSVG  ImageFormat = "svg"  // SVG format
        ImageFormatWEBP ImageFormat = "webp" // WebP format
)

// ImageSize represents image dimensions.
type ImageSize struct {
        WidthPx   int // Width in pixels
        HeightPx  int // Height in pixels
        WidthEMU  int // Width in EMUs (English Metric Units, 914400 EMU = 1 inch)
        HeightEMU int // Height in EMUs
}

// NewImageSize creates an ImageSize from pixel dimensions.
// Converts pixels to EMUs assuming 96 DPI.
func NewImageSize(widthPx, heightPx int) ImageSize <span class="cov0" title="0">{
        const emuPerPixel = 9525 // 914400 EMU per inch / 96 DPI
        return ImageSize{
                WidthPx:   widthPx,
                HeightPx:  heightPx,
                WidthEMU:  widthPx * emuPerPixel,
                HeightEMU: heightPx * emuPerPixel,
        }
}</span>

// NewImageSizeInches creates an ImageSize from inch dimensions.
func NewImageSizeInches(widthInches, heightInches float64) ImageSize <span class="cov0" title="0">{
        const emuPerInch = 914400
        const pixelsPerInch = 96
        return ImageSize{
                WidthPx:   int(widthInches * pixelsPerInch),
                HeightPx:  int(heightInches * pixelsPerInch),
                WidthEMU:  int(widthInches * emuPerInch),
                HeightEMU: int(heightInches * emuPerInch),
        }
}</span>

// Image represents an embedded image in a document.
type Image interface {
        // ID returns the unique image ID.
        ID() string

        // Format returns the image format.
        Format() ImageFormat

        // Size returns the image dimensions.
        Size() ImageSize

        // SetSize sets custom dimensions for the image.
        // If width or height is 0, maintains aspect ratio.
        SetSize(size ImageSize) error

        // Data returns the raw image data.
        Data() []byte

        // RelationshipID returns the relationship ID for this image.
        RelationshipID() string

        // Target returns the target path in the .docx package (e.g., "media/image1.png").
        Target() string

        // Description returns the alt text description.
        Description() string

        // SetDescription sets the alt text description.
        SetDescription(desc string) error

        // Position returns the image position settings.
        Position() ImagePosition
}

// ImagePosition represents image positioning options.
type ImagePosition struct {
        Type       ImagePositionType // Inline or Floating
        HAlign     HorizontalAlign   // Horizontal alignment (for floating)
        VAlign     VerticalAlign     // Vertical alignment (for floating)
        OffsetX    int               // Horizontal offset in EMUs
        OffsetY    int               // Vertical offset in EMUs
        WrapText   TextWrapType      // Text wrapping style
        ZOrder     int               // Z-order for layering
        BehindText bool              // Whether image is behind text
}

// ImagePositionType defines how an image is positioned in the document.
type ImagePositionType string

// Image position type constants.
const (
        ImagePositionInline   ImagePositionType = "inline"   // Inline with text (default)
        ImagePositionFloating ImagePositionType = "floating" // Floating with absolute positioning
)

// HorizontalAlign defines horizontal alignment options for floating images.
type HorizontalAlign string

// Horizontal alignment constants for floating images.
const (
        HAlignLeft    HorizontalAlign = "left"    // Left-aligned
        HAlignCenter  HorizontalAlign = "center"  // Center-aligned
        HAlignRight   HorizontalAlign = "right"   // Right-aligned
        HAlignInside  HorizontalAlign = "inside"  // Inside margin (left on odd pages)
        HAlignOutside HorizontalAlign = "outside" // Outside margin (right on odd pages)
)

// VerticalAlign defines vertical alignment options for floating images.
type VerticalAlign string

// Vertical alignment constants for floating images.
const (
        VAlignTop     VerticalAlign = "top"     // Top-aligned
        VAlignCenter  VerticalAlign = "center"  // Center-aligned
        VAlignBottom  VerticalAlign = "bottom"  // Bottom-aligned
        VAlignInside  VerticalAlign = "inside"  // Inside margin (top on odd pages)
        VAlignOutside VerticalAlign = "outside" // Outside margin (bottom on odd pages)
)

// TextWrapType defines how text wraps around an image.
type TextWrapType string

// Text wrapping constants for floating images.
const (
        WrapNone        TextWrapType = "none"        // No wrapping
        WrapSquare      TextWrapType = "square"      // Square wrapping
        WrapTight       TextWrapType = "tight"       // Tight wrapping
        WrapThrough     TextWrapType = "through"     // Through wrapping
        WrapTopBottom   TextWrapType = "topBottom"   // Top and bottom only
        WrapBehindText  TextWrapType = "behindText"  // Behind text
        WrapInFrontText TextWrapType = "inFrontText" // In front of text
)

// DefaultImagePosition returns default inline position.
func DefaultImagePosition() ImagePosition <span class="cov0" title="0">{
        return ImagePosition{
                Type:       ImagePositionInline,
                WrapText:   WrapNone,
                ZOrder:     0,
                BehindText: false,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "log"

        docx "github.com/mmonterroca/docxgo"
)

func main() <span class="cov0" title="0">{
        // Create a new document builder with options
        builder := docx.NewDocumentBuilder(
                docx.WithTitle("Builder Pattern Demo"),
                docx.WithAuthor("go-docx v2"),
                docx.WithDefaultFont("Calibri"),
                docx.WithDefaultFontSize(22), // 11pt = 22 half-points
                docx.WithPageSize(docx.A4),
                docx.WithMargins(docx.NormalMargins),
        )

        // Add title using builder fluent API
        builder.AddParagraph().
                Text("Welcome to go-docx v2 Builder Pattern").
                Bold().
                FontSize(16).
                Color(docx.Blue).
                Alignment(docx.AlignmentCenter).
                End()

        // Add subtitle
        builder.AddParagraph().
                Text("Creating documents is now easier than ever").
                Italic().
                FontSize(12).
                Color(docx.Gray).
                Alignment(docx.AlignmentCenter).
                End()

        // Add blank line
        builder.AddParagraph().End()

        // Add section heading
        builder.AddParagraph().
                Text("1. Introduction").
                Bold().
                FontSize(14).
                Color(docx.Black).
                End()

        // Add normal paragraph
        builder.AddParagraph().
                Text("The builder pattern provides a fluent, chainable API for creating documents. ").
                Text("It makes code more readable and reduces boilerplate.").
                End()

        builder.AddParagraph().End()

        // Add another section
        builder.AddParagraph().
                Text("2. Features").
                Bold().
                FontSize(14).
                End()

        // Add list items
        builder.AddParagraph().
                Text("• Fluent API - chain multiple formatting calls").
                End()

        builder.AddParagraph().
                Text("• Type-safe colors - use predefined color constants").
                Color(docx.Red).
                End()

        builder.AddParagraph().
                Text("• Easy formatting - bold, italic, underline, and more").
                Bold().
                End()

        builder.AddParagraph().
                Text("• Alignment control - left, center, right, justify").
                Alignment(docx.AlignmentCenter).
                End()

        builder.AddParagraph().End()

        // Add section with mixed formatting
        builder.AddParagraph().
                Text("3. Mixed Formatting Example").
                Bold().
                FontSize(14).
                End()

        // This demonstrates multiple text runs with different formatting
        builder.AddParagraph().
                Text("This paragraph has ").
                Text("bold text").Bold().
                Text(", ").
                Text("italic text").Italic().
                Text(", ").
                Text("colored text").Color(docx.Green).
                Text(", and ").
                Text("underlined text").Underline(docx.UnderlineSingle).
                Text(".").
                End()

        builder.AddParagraph().End()

        // Add table example
        builder.AddParagraph().
                Text("4. Simple Table").
                Bold().
                FontSize(14).
                End()

        // Create a simple 3x3 table
        builder.AddTable(3, 3).
                Row(0).
                Cell(0).Text("Header 1").Bold().End().
                Cell(1).Text("Header 2").Bold().End().
                Cell(2).Text("Header 3").Bold().End().
                End().
                Row(1).
                Cell(0).Text("Row 1, Col 1").End().
                Cell(1).Text("Row 1, Col 2").End().
                Cell(2).Text("Row 1, Col 3").End().
                End().
                Row(2).
                Cell(0).Text("Row 2, Col 1").End().
                Cell(1).Text("Row 2, Col 2").Shading(docx.Blue).End().
                Cell(2).Text("Row 2, Col 3").End().
                End().
                End()

        builder.AddParagraph().End()

        // Add conclusion
        builder.AddParagraph().
                Text("Conclusion").
                Bold().
                FontSize(14).
                End()

        builder.AddParagraph().
                Text("The builder pattern makes document creation intuitive and enjoyable. ").
                Text("Try it in your next project!").
                Bold().
                Color(docx.Purple).
                End()

        // Build the document (validates and finalizes)
        doc, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to build document: %v", err)
        }</span>

        // Save the document
        <span class="cov0" title="0">if err := doc.SaveAs("01_basic_builder.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Document created successfully: 01_basic_builder.docx")
        fmt.Println("\nThis example demonstrates:")
        fmt.Println("✓ Builder pattern with fluent API")
        fmt.Println("✓ Document options (title, author, font, margins)")
        fmt.Println("✓ Predefined color constants")
        fmt.Println("✓ Text formatting (bold, italic, color, size)")
        fmt.Println("✓ Alignment control")
        fmt.Println("✓ Simple table creation")
        fmt.Println("✓ Mixed formatting in paragraphs")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "log"

        docx "github.com/mmonterroca/docxgo"
)

func main() <span class="cov0" title="0">{
        // Create document builder with custom options
        builder := docx.NewDocumentBuilder(
                docx.WithTitle("Product Catalog"),
                docx.WithAuthor("ACME Corporation"),
                docx.WithSubject("Q1 2024 Product Lineup"),
                docx.WithDefaultFont("Arial"),
                docx.WithDefaultFontSize(22), // 11pt = 22 half-points
                docx.WithPageSize(docx.Letter),
                docx.WithMargins(docx.NormalMargins),
        )

        // Cover page
        builder.AddParagraph().
                Text("ACME Corporation").
                Bold().
                FontSize(20).
                Color(docx.Blue).
                Alignment(docx.AlignmentCenter).
                End()

        builder.AddParagraph().
                Text("Product Catalog 2024").
                FontSize(16).
                Color(docx.Gray).
                Alignment(docx.AlignmentCenter).
                End()

        builder.AddParagraph().End()
        builder.AddParagraph().End()

        // Table of contents (static text - for dynamic TOC with auto-updating page numbers, see example 07_advanced)
        // Note: This is a simple text-based TOC. For a real Word TOC field that updates automatically, use AddTOC() as shown in 07_advanced
        builder.AddParagraph().
                Text("Table of Contents").
                Bold().
                FontSize(14).
                Underline(docx.UnderlineSingle).
                End()

        builder.AddParagraph().
                Text("1. Electronics.....................................5").
                End()

        builder.AddParagraph().
                Text("2. Home &amp; Garden...............................12").
                End()

        builder.AddParagraph().
                Text("3. Sports &amp; Outdoors..........................18").
                End()

        builder.AddParagraph().End()
        builder.AddParagraph().End()

        // Section 1: Electronics
        builder.AddParagraph().
                Text("1. Electronics").
                Bold().
                FontSize(16).
                Color(docx.Blue).
                End()

        builder.AddParagraph().
                Text("Our electronics lineup features cutting-edge technology and innovative designs.").
                End()

        builder.AddParagraph().End()

        // Product table (4 rows x 3 cols)
        builder.AddTable(4, 3).
                Row(0).
                Cell(0).Text("Product").Bold().End().
                Cell(1).Text("Description").Bold().End().
                Cell(2).Text("Price").Bold().End().
                End().
                Row(1).
                Cell(0).Text("Laptop Pro X1").End().
                Cell(1).Text("15-inch display, 16GB RAM, 512GB SSD").End().
                Cell(2).Text("$1,299").Bold().End().
                End().
                Row(2).
                Cell(0).Text("Wireless Earbuds").End().
                Cell(1).Text("Active noise cancellation, 24h battery").End().
                Cell(2).Text("$199").Bold().End().
                End().
                Row(3).
                Cell(0).Text("Smart Watch").End().
                Cell(1).Text("Fitness tracking, heart rate monitor").End().
                Cell(2).Text("$349").Bold().End().
                End().
                End()

        builder.AddParagraph().End()

        // Features highlight
        builder.AddParagraph().
                Text("Key Features:").
                Bold().
                FontSize(12).
                End()

        builder.AddParagraph().
                Text("✓ Industry-leading performance").
                Color(docx.Green).
                End()

        builder.AddParagraph().
                Text("✓ 2-year warranty on all electronics").
                Color(docx.Green).
                End()

        builder.AddParagraph().
                Text("✓ Free shipping on orders over $500").
                Color(docx.Green).
                End()

        builder.AddParagraph().End()
        builder.AddParagraph().End()

        // Section 2: Home &amp; Garden
        builder.AddParagraph().
                Text("2. Home &amp; Garden").
                Bold().
                FontSize(16).
                Color(docx.Blue).
                End()

        builder.AddParagraph().
                Text("Transform your living space with our curated collection.").
                End()

        builder.AddParagraph().End()

        builder.AddTable(4, 3).
                Row(0).
                Cell(0).Text("Product").Bold().End().
                Cell(1).Text("Description").Bold().End().
                Cell(2).Text("Price").Bold().End().
                End().
                Row(1).
                Cell(0).Text("LED Desk Lamp").End().
                Cell(1).Text("Adjustable brightness, USB charging port").End().
                Cell(2).Text("$49").Bold().End().
                End().
                Row(2).
                Cell(0).Text("Garden Tool Set").End().
                Cell(1).Text("10-piece set with carrying case").End().
                Cell(2).Text("$89").Bold().End().
                End().
                Row(3).
                Cell(0).Text("Indoor Plant Kit").End().
                Cell(1).Text("Includes 3 plants, pots, and soil").End().
                Cell(2).Text("$39").Bold().End().
                End().
                End()

        builder.AddParagraph().End()

        // Section 3: Sports &amp; Outdoors
        builder.AddParagraph().
                Text("3. Sports &amp; Outdoors").
                Bold().
                FontSize(16).
                Color(docx.Blue).
                End()

        builder.AddParagraph().
                Text("Gear up for adventure with our premium outdoor equipment.").
                End()

        builder.AddParagraph().End()

        builder.AddTable(4, 3).
                Row(0).
                Cell(0).Text("Product").Bold().End().
                Cell(1).Text("Description").Bold().End().
                Cell(2).Text("Price").Bold().End().
                End().
                Row(1).
                Cell(0).Text("Hiking Backpack").End().
                Cell(1).Text("40L capacity, waterproof, ergonomic").End().
                Cell(2).Text("$129").Bold().End().
                End().
                Row(2).
                Cell(0).Text("Camping Tent").End().
                Cell(1).Text("4-person, weather-resistant, easy setup").End().
                Cell(2).Text("$249").Bold().End().
                End().
                Row(3).
                Cell(0).Text("Running Shoes").End().
                Cell(1).Text("Lightweight, cushioned, breathable").End().
                Cell(2).Text("$119").Bold().End().
                End().
                End()

        builder.AddParagraph().End()
        builder.AddParagraph().End()

        // Contact info
        builder.AddParagraph().
                Text("Contact Information").
                Bold().
                FontSize(14).
                Underline(docx.UnderlineSingle).
                End()

        builder.AddParagraph().
                Text("ACME Corporation").
                Bold().
                End()

        builder.AddParagraph().
                Text("📧 sales@acme.example.com").
                End()

        builder.AddParagraph().
                Text("📞 1-800-ACME-123").
                End()

        builder.AddParagraph().
                Text("🌐 www.acme.example.com").
                Color(docx.Blue).
                End()

        builder.AddParagraph().End()

        // Footer note
        builder.AddParagraph().
                Text("Prices subject to change. All products include standard warranty. ").
                Text("Visit our website for current pricing and availability.").
                FontSize(9).
                Color(docx.Gray).
                Italic().
                Alignment(docx.AlignmentCenter).
                End()

        // Build the document
        doc, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to build document: %v", err)
        }</span>

        // Save the document
        <span class="cov0" title="0">if err := doc.SaveAs("02_intermediate_builder.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Product catalog created successfully: 02_intermediate_builder.docx")
        fmt.Println("\nThis example demonstrates:")
        fmt.Println("✓ Professional document layout")
        fmt.Println("✓ Multiple sections with headings")
        fmt.Println("✓ Product tables with pricing")
        fmt.Println("✓ Mixed text formatting")
        fmt.Println("✓ Color-coded information")
        fmt.Println("✓ Contact information")
        fmt.Println("✓ Document metadata (title, author, subject)")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "fmt"
        "log"
        "strings"

        docx "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        doc := docx.NewDocument()

        if err := buildDocument(doc); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to build document: %v", err)
        }</span>

        <span class="cov0" title="0">if err := doc.SaveAs("03_toc_demo.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Table of contents demo created: 03_toc_demo.docx")
        fmt.Println("Open the file in Word and press F9 to refresh the TOC.")</span>
}

func buildDocument(doc domain.Document) error <span class="cov0" title="0">{
        meta := &amp;domain.Metadata{
                Title:   "go-docx Table of Contents Demo",
                Subject: "Automatic TOC generated from heading styles",
                Creator: "go-docx",
        }
        if err := doc.SetMetadata(meta); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set metadata: %w", err)
        }</span>

        <span class="cov0" title="0">if err := addCover(doc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := addTableOfContents(doc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">chapters := []struct {
                number   int
                title    string
                sections []string
        }{
                {
                        number: 1,
                        title:  "Getting Started",
                        sections: []string{
                                "Installing go-docx",
                                "Creating your first document",
                                "Applying heading styles",
                        },
                },
                {
                        number: 2,
                        title:  "Building Content",
                        sections: []string{
                                "Paragraph formatting",
                                "Working with lists",
                                "Inserting images",
                        },
                },
        }

        for _, chapter := range chapters </span><span class="cov0" title="0">{
                if err := addChapter(doc, chapter.number, chapter.title, chapter.sections); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := addAppendix(doc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func addCover(doc domain.Document) error <span class="cov0" title="0">{
        title, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add title paragraph: %w", err)
        }</span>
        <span class="cov0" title="0">if err := title.SetStyle(domain.StyleIDTitle); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set title style: %w", err)
        }</span>
        <span class="cov0" title="0">if err := title.SetAlignment(domain.AlignmentCenter); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set title alignment: %w", err)
        }</span>
        <span class="cov0" title="0">titleRun, err := title.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add title run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := titleRun.SetText("go-docx v2 Table of Contents Demo"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set title text: %w", err)
        }</span>

        <span class="cov0" title="0">subtitle, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add subtitle paragraph: %w", err)
        }</span>
        <span class="cov0" title="0">if err := subtitle.SetStyle(domain.StyleIDSubtitle); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set subtitle style: %w", err)
        }</span>
        <span class="cov0" title="0">if err := subtitle.SetAlignment(domain.AlignmentCenter); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set subtitle alignment: %w", err)
        }</span>
        <span class="cov0" title="0">subtitleRun, err := subtitle.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add subtitle run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := subtitleRun.SetText("The TOC is driven by Heading 1 and Heading 2 paragraphs"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set subtitle text: %w", err)
        }</span>
        <span class="cov0" title="0">if err := subtitle.SetSpacingAfter(240); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set subtitle spacing: %w", err)
        }</span>

        <span class="cov0" title="0">intro, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add intro paragraph: %w", err)
        }</span>
        <span class="cov0" title="0">introRun, err := intro.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add intro run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := introRun.SetText("Use heading styles while authoring. Word rebuilds the TOC automatically when you press F9."); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set intro text: %w", err)
        }</span>

        <span class="cov0" title="0">if err := doc.AddPageBreak(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add page break after cover: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func addTableOfContents(doc domain.Document) error <span class="cov0" title="0">{
        heading, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC heading: %w", err)
        }</span>
        <span class="cov0" title="0">if err := heading.SetStyle(domain.StyleIDHeading1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC heading style: %w", err)
        }</span>
        <span class="cov0" title="0">headingRun, err := heading.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC heading run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := headingRun.SetText("Table of Contents"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC heading text: %w", err)
        }</span>

        <span class="cov0" title="0">description, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC description: %w", err)
        }</span>
        <span class="cov0" title="0">descRun, err := description.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC description run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := descRun.SetText("This field stays in sync with Heading 1 and Heading 2 entries. Update it in Word when the outline changes."); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC description text: %w", err)
        }</span>
        <span class="cov0" title="0">if err := description.SetSpacingAfter(160); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC description spacing: %w", err)
        }</span>

        <span class="cov0" title="0">tocPara, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC paragraph: %w", err)
        }</span>
        <span class="cov0" title="0">tocRun, err := tocPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC run: %w", err)
        }</span>

        <span class="cov0" title="0">tocOptions := map[string]string{
                "levels":     "1-2",
                "hyperlinks": "true",
        }
        tocField := docx.NewTOCField(tocOptions)

        placeholder := strings.TrimSpace(`
Getting Started ................................................. 3
    Installing go-docx ........................................ 4
    Creating your first document ............................... 5
    Applying heading styles .................................... 6
Building Content ................................................ 7
    Paragraph formatting .................................... 8
    Working with lists ....................................... 9
    Inserting images ......................................... 10
Appendix A (Resources) ....................................... 11
`)

        if setter, ok := tocField.(interface{ SetResult(string) }); ok </span><span class="cov0" title="0">{
                setter.SetResult(placeholder)
        }</span>

        <span class="cov0" title="0">if err := tocRun.AddField(tocField); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC field: %w", err)
        }</span>

        <span class="cov0" title="0">note, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC note: %w", err)
        }</span>
        <span class="cov0" title="0">if err := note.SetStyle(domain.StyleIDIntenseQuote); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC note style: %w", err)
        }</span>
        <span class="cov0" title="0">noteRun, err := note.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC note run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := noteRun.SetText("Tip: Right-click inside the table and choose 'Update Field' whenever you add or remove sections."); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC note text: %w", err)
        }</span>
        <span class="cov0" title="0">if err := note.SetSpacingAfter(240); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set TOC note spacing: %w", err)
        }</span>

        <span class="cov0" title="0">if err := doc.AddPageBreak(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add page break after TOC: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func addChapter(doc domain.Document, number int, title string, sections []string) error <span class="cov0" title="0">{
        heading, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add chapter heading: %w", err)
        }</span>
        <span class="cov0" title="0">if err := heading.SetStyle(domain.StyleIDHeading1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set chapter heading style: %w", err)
        }</span>
        <span class="cov0" title="0">headingRun, err := heading.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add chapter heading run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := headingRun.SetText(fmt.Sprintf("Chapter %d: %s", number, title)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set chapter heading text: %w", err)
        }</span>
        <span class="cov0" title="0">if err := heading.SetSpacingAfter(200); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set chapter heading spacing: %w", err)
        }</span>

        <span class="cov0" title="0">for idx, section := range sections </span><span class="cov0" title="0">{
                subHeading, err := doc.AddParagraph()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add subsection heading: %w", err)
                }</span>
                <span class="cov0" title="0">if err := subHeading.SetStyle(domain.StyleIDHeading2); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("set subsection style: %w", err)
                }</span>
                <span class="cov0" title="0">subRun, err := subHeading.AddRun()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add subsection run: %w", err)
                }</span>
                <span class="cov0" title="0">if err := subRun.SetText(fmt.Sprintf("%d.%d %s", number, idx+1, section)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("set subsection text: %w", err)
                }</span>

                <span class="cov0" title="0">body, err := doc.AddParagraph()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add subsection body: %w", err)
                }</span>
                <span class="cov0" title="0">bodyRun, err := body.AddRun()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add subsection body run: %w", err)
                }</span>
                <span class="cov0" title="0">if err := bodyRun.SetText("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. Integer sit amet mauris sed mauris molestie aliquam."); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("set subsection body text: %w", err)
                }</span>
                <span class="cov0" title="0">if err := body.SetSpacingAfter(120); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("set subsection body spacing: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := doc.AddPageBreak(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add page break after chapter: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func addAppendix(doc domain.Document) error <span class="cov0" title="0">{
        heading, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add appendix heading: %w", err)
        }</span>
        <span class="cov0" title="0">if err := heading.SetStyle(domain.StyleIDHeading1); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set appendix heading style: %w", err)
        }</span>
        <span class="cov0" title="0">headingRun, err := heading.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add appendix heading run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := headingRun.SetText("Appendix A: Resources"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set appendix heading text: %w", err)
        }</span>
        <span class="cov0" title="0">if err := heading.SetSpacingAfter(160); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set appendix heading spacing: %w", err)
        }</span>

        <span class="cov0" title="0">intro, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add appendix intro: %w", err)
        }</span>
        <span class="cov0" title="0">introRun, err := intro.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add appendix intro run: %w", err)
        }</span>
        <span class="cov0" title="0">if err := introRun.SetText("Further reading and helpful links for building long-form documents with go-docx:"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set appendix intro text: %w", err)
        }</span>
        <span class="cov0" title="0">if err := intro.SetSpacingAfter(120); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set appendix intro spacing: %w", err)
        }</span>

        <span class="cov0" title="0">resources := []string{
                "API reference: pkg.go.dev/github.com/mmonterroca/docxgo",
                "Examples: github.com/mmonterroca/docxgo/examples",
                "Design document: docs/V2_DESIGN.md",
                "Fields deep dive: examples/04_fields",
        }

        for _, item := range resources </span><span class="cov0" title="0">{
                para, err := doc.AddParagraph()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add resource paragraph: %w", err)
                }</span>
                <span class="cov0" title="0">if err := para.SetStyle(domain.StyleIDListParagraph); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("set resource style: %w", err)
                }</span>
                <span class="cov0" title="0">run, err := para.AddRun()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add resource run: %w", err)
                }</span>
                <span class="cov0" title="0">if err := run.SetText("- " + item); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("set resource text: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package main

import (
        "fmt"
        "log"
        "strings"

        docx "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        // Create a new document
        doc := docx.NewDocument()

        // Example 1: Add page numbers to footer
        if err := addPageNumbers(doc); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add page numbers: %v", err)
        }</span>

        // Example 2: Add Table of Contents
        <span class="cov0" title="0">if err := addTableOfContents(doc); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add TOC: %v", err)
        }</span>

        // Example 3: Add content with headings
        <span class="cov0" title="0">if err := addContent(doc); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add content: %v", err)
        }</span>

        // Example 4: Add hyperlinks
        <span class="cov0" title="0">if err := addHyperlinks(doc); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add hyperlinks: %v", err)
        }</span>

        // Save the document
        <span class="cov0" title="0">if err := doc.SaveAs("fields_example.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Document created successfully: fields_example.docx")
        fmt.Println("\nNote: Open the document in Word and press F9 to update all fields.")</span>
}

// addPageNumbers adds page numbers to the default footer
func addPageNumbers(doc domain.Document) error <span class="cov0" title="0">{
        // Get the default section
        section, err := doc.DefaultSection()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get default section: %w", err)
        }</span>

        // Get the default footer
        <span class="cov0" title="0">footer, err := section.Footer(domain.FooterDefault)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get footer: %w", err)
        }</span>

        // Add a paragraph to the footer
        <span class="cov0" title="0">para, err := footer.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add paragraph: %w", err)
        }</span>

        // Set center alignment
        <span class="cov0" title="0">para.SetAlignment(domain.AlignmentCenter)

        // Add text before page number
        run1, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add run: %w", err)
        }</span>
        <span class="cov0" title="0">run1.AddText("Page ")

        // Add page number field
        run2, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add run: %w", err)
        }</span>
        <span class="cov0" title="0">pageField := docx.NewPageNumberField()
        run2.AddField(pageField)

        // Add text after page number
        run3, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add run: %w", err)
        }</span>
        <span class="cov0" title="0">run3.AddText(" of ")

        // Add total page count field
        run4, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add run: %w", err)
        }</span>
        <span class="cov0" title="0">pageCountField := docx.NewPageCountField()
        run4.AddField(pageCountField)

        return nil</span>
}

// addTableOfContents adds a TOC at the beginning of the document
func addTableOfContents(doc domain.Document) error <span class="cov0" title="0">{
        // Add TOC heading
        heading, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add heading: %w", err)
        }</span>
        <span class="cov0" title="0">heading.SetStyle("Heading1")
        run, err := heading.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add run: %w", err)
        }</span>
        <span class="cov0" title="0">run.AddText("Table of Contents")

        // Add TOC paragraph
        tocPara, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC paragraph: %w", err)
        }</span>

        // Create TOC field with custom options
        <span class="cov0" title="0">tocOptions := map[string]string{
                "levels":     "1-3",  // Include heading levels 1-3
                "hyperlinks": "true", // Enable hyperlinks
        }
        tocField := docx.NewTOCField(tocOptions)

        // Add TOC field to paragraph
        tocRun, err := tocPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add TOC run: %w", err)
        }</span>
        <span class="cov0" title="0">tocRun.AddField(tocField)

        // Add page break after TOC
        doc.AddPageBreak()

        return nil</span>
}

// addContent adds sample content with headings
func addContent(doc domain.Document) error <span class="cov0" title="0">{
        sections := []struct {
                heading string
                content string
                level   string
        }{
                {
                        heading: "Introduction",
                        content: "This document demonstrates the use of fields in Word documents. Fields are dynamic elements that can display automatically calculated values such as page numbers, dates, or cross-references.",
                        level:   "Heading1",
                },
                {
                        heading: "Page Numbering",
                        content: "The footer contains page numbers that are automatically calculated. The format used is 'Page X of Y', where X is the current page and Y is the total number of pages.",
                        level:   "Heading2",
                },
                {
                        heading: "Table of Contents",
                        content: "The TOC at the beginning is generated from the heading styles in the document. In Word, you can update it by right-clicking and selecting 'Update Field', or by pressing F9.",
                        level:   "Heading2",
                },
                {
                        heading: "Hyperlinks",
                        content: "Hyperlinks are also implemented as fields. They allow linking to external URLs or internal bookmarks.",
                        level:   "Heading2",
                },
                {
                        heading: "Advanced Features",
                        content: "Additional field types supported include STYLEREF for running headers, SEQ for sequence numbering, and custom fields for specialized needs.",
                        level:   "Heading1",
                },
                {
                        heading: "Cross-References",
                        content: "Cross-references can be created using REF fields, allowing you to reference other parts of the document by bookmark name.",
                        level:   "Heading2",
                },
                {
                        heading: "Date and Time",
                        content: "DATE and TIME fields automatically insert the current date or time, with optional formatting switches.",
                        level:   "Heading2",
                },
        }

        var lastHeading1 string
        const sequenceBookmarkName = "_RefFigureSequence1"
        const sequenceBookmarkID = "200"
        sequenceNumber := "1"

        for _, section := range sections </span><span class="cov0" title="0">{
                // Add heading
                heading, err := doc.AddParagraph()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add heading: %w", err)
                }</span>
                <span class="cov0" title="0">heading.SetStyle(section.level)
                run, err := heading.AddRun()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add run: %w", err)
                }</span>
                <span class="cov0" title="0">run.AddText(section.heading)

                if section.level == "Heading1" </span><span class="cov0" title="0">{
                        lastHeading1 = section.heading
                }</span>

                // Add content
                <span class="cov0" title="0">para, err := doc.AddParagraph()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add paragraph: %w", err)
                }</span>
                <span class="cov0" title="0">contentRun, err := para.AddRun()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add content run: %w", err)
                }</span>
                <span class="cov0" title="0">contentRun.AddText(section.content)

                if section.heading == "Date and Time" </span><span class="cov0" title="0">{
                        datePara, err := doc.AddParagraph()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add date paragraph: %w", err)
                        }</span>
                        <span class="cov0" title="0">dateLabelRun, err := datePara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add date label run: %w", err)
                        }</span>
                        <span class="cov0" title="0">dateLabelRun.AddText("Current date: ")

                        dateFieldRun, err := datePara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add date field run: %w", err)
                        }</span>
                        <span class="cov0" title="0">dateField := docx.NewField(domain.FieldTypeDate)
                        if err := dateField.SetCode(`DATE \@ "MMMM d, yyyy"`); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("configure date field: %w", err)
                        }</span>
                        <span class="cov0" title="0">if err := dateFieldRun.AddField(dateField); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add date field: %w", err)
                        }</span>

                        <span class="cov0" title="0">timePara, err := doc.AddParagraph()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add time paragraph: %w", err)
                        }</span>
                        <span class="cov0" title="0">timeLabelRun, err := timePara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add time label run: %w", err)
                        }</span>
                        <span class="cov0" title="0">timeLabelRun.AddText("Current time: ")

                        timeFieldRun, err := timePara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add time field run: %w", err)
                        }</span>
                        <span class="cov0" title="0">timeField := docx.NewField(domain.FieldTypeTime)
                        if err := timeField.SetCode(`TIME \@ "HH:mm"`); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("configure time field: %w", err)
                        }</span>
                        <span class="cov0" title="0">if err := timeFieldRun.AddField(timeField); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add time field: %w", err)
                        }</span>

                        <span class="cov0" title="0">timePara.SetSpacingAfter(200)</span>
                } else<span class="cov0" title="0"> if section.heading == "Advanced Features" </span><span class="cov0" title="0">{
                        stylePara, err := doc.AddParagraph()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add style-ref paragraph: %w", err)
                        }</span>
                        <span class="cov0" title="0">styleRun, err := stylePara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add style-ref label run: %w", err)
                        }</span>
                        <span class="cov0" title="0">styleRun.AddText("Running header (STYLEREF Heading 1): ")

                        styleFieldRun, err := stylePara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add style-ref field run: %w", err)
                        }</span>
                        <span class="cov0" title="0">styleField := docx.NewStyleRefField("Heading 1")
                        if err := styleField.SetCode(`STYLEREF "Heading 1" \* MERGEFORMAT`); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("configure style-ref field: %w", err)
                        }</span>
                        <span class="cov0" title="0">if setter, ok := styleField.(interface{ SetResult(string) }); ok </span><span class="cov0" title="0">{
                                display := lastHeading1
                                if strings.TrimSpace(display) == "" </span><span class="cov0" title="0">{
                                        display = "Heading 1 (update fields)"
                                }</span>
                                <span class="cov0" title="0">setter.SetResult(display)</span>
                        }
                        <span class="cov0" title="0">if err := styleFieldRun.AddField(styleField); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add style-ref field: %w", err)
                        }</span>

                        <span class="cov0" title="0">seqPara, err := doc.AddParagraph()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add sequence paragraph: %w", err)
                        }</span>
                        <span class="cov0" title="0">if err := seqPara.SetStyle("Caption"); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("set caption style: %w", err)
                        }</span>
                        <span class="cov0" title="0">seqLabelRun, err := seqPara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add sequence label run: %w", err)
                        }</span>
                        <span class="cov0" title="0">seqLabelRun.AddText("Figure ")

                        seqFieldRun, err := seqPara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add sequence field run: %w", err)
                        }</span>
                        <span class="cov0" title="0">seqField := docx.NewField(domain.FieldTypeSeq)
                        if err := seqField.SetCode(`SEQ Figure \* ARABIC`); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("configure sequence field: %w", err)
                        }</span>
                        <span class="cov0" title="0">if setter, ok := seqField.(interface{ SetResult(string) }); ok </span><span class="cov0" title="0">{
                                setter.SetResult(sequenceNumber)
                        }</span>
                        <span class="cov0" title="0">if err := seqFieldRun.AddField(seqField); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add sequence field: %w", err)
                        }</span>

                        <span class="cov0" title="0">seqTitleRun, err := seqPara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add sequence title run: %w", err)
                        }</span>
                        <span class="cov0" title="0">seqTitleRun.AddText(" – Sample sequence field")

                        if bookmarkable, ok := seqPara.(interface{ SetBookmark(string, string) }); ok </span><span class="cov0" title="0">{
                                bookmarkable.SetBookmark(sequenceBookmarkID, sequenceBookmarkName)
                        }</span>

                        <span class="cov0" title="0">seqPara.SetSpacingAfter(200)</span>
                } else<span class="cov0" title="0"> if section.heading == "Cross-References" </span><span class="cov0" title="0">{
                        refPara, err := doc.AddParagraph()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add cross-reference paragraph: %w", err)
                        }</span>
                        <span class="cov0" title="0">refIntroRun, err := refPara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add cross-reference intro run: %w", err)
                        }</span>
                        <span class="cov0" title="0">refIntroRun.AddText("See ")

                        refFieldRun, err := refPara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add cross-reference field run: %w", err)
                        }</span>
                        <span class="cov0" title="0">refField := docx.NewField(domain.FieldTypeRef)
                        if err := refField.SetCode(fmt.Sprintf("REF %s \\h", sequenceBookmarkName)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("configure cross-reference field: %w", err)
                        }</span>
                        <span class="cov0" title="0">if setter, ok := refField.(interface{ SetResult(string) }); ok </span><span class="cov0" title="0">{
                                setter.SetResult(fmt.Sprintf("Figure %s", sequenceNumber))
                        }</span>
                        <span class="cov0" title="0">if err := refFieldRun.AddField(refField); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add cross-reference field: %w", err)
                        }</span>

                        <span class="cov0" title="0">refSuffixRun, err := refPara.AddRun()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("add cross-reference suffix run: %w", err)
                        }</span>
                        <span class="cov0" title="0">refSuffixRun.AddText(" for the sequence field output above.")

                        refPara.SetSpacingAfter(200)</span>
                }

                // Add spacing
                <span class="cov0" title="0">para.SetSpacingAfter(200)</span> // 200 twips
        }

        <span class="cov0" title="0">return nil</span>
}

// addHyperlinks adds example hyperlinks to the document
func addHyperlinks(doc domain.Document) error <span class="cov0" title="0">{
        // Add section heading
        heading, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add heading: %w", err)
        }</span>
        <span class="cov0" title="0">heading.SetStyle("Heading1")
        run, err := heading.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add run: %w", err)
        }</span>
        <span class="cov0" title="0">run.AddText("Useful Links")

        // Add paragraph with hyperlinks
        para, err := doc.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add paragraph: %w", err)
        }</span>

        // Text before link
        <span class="cov0" title="0">textRun, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add text run: %w", err)
        }</span>
        <span class="cov0" title="0">textRun.AddText("For more information, visit ")

        // Hyperlink
        linkRun, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add link run: %w", err)
        }</span>
        <span class="cov0" title="0">linkRun.SetColor(docx.Blue)
        linkRun.SetUnderline(domain.UnderlineSingle)

        hyperlinkField := docx.NewHyperlinkField("https://github.com/mmonterroca/docxgo", "go-docx repository")
        linkRun.AddField(hyperlinkField)

        // Text after link
        textRun2, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add text run: %w", err)
        }</span>
        <span class="cov0" title="0">textRun2.AddText(" on GitHub.")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "log"

        docx "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        // Create a new document
        doc := docx.NewDocument()

        // Create title with Title style
        title, _ := doc.AddParagraph()
        title.SetStyle(domain.StyleIDTitle)
        titleRun, _ := title.AddRun()
        titleRun.AddText("Style Management Demo")

        // Add some spacing
        doc.AddParagraph()

        // Heading 1
        h1, _ := doc.AddParagraph()
        h1.SetStyle(domain.StyleIDHeading1)
        h1Run, _ := h1.AddRun()
        h1Run.AddText("1. Built-in Styles")

        // Normal paragraph
        normalPara, _ := doc.AddParagraph()
        normalPara.SetStyle(domain.StyleIDNormal)
        normalRun, _ := normalPara.AddRun()
        normalRun.AddText("This paragraph uses the Normal style. It's the default style for body text.")

        // Heading 2
        h2, _ := doc.AddParagraph()
        h2.SetStyle(domain.StyleIDHeading2)
        h2Run, _ := h2.AddRun()
        h2Run.AddText("1.1 Text Emphasis")

        // Intense Quote
        quote, _ := doc.AddParagraph()
        quote.SetStyle(domain.StyleIDIntenseQuote)
        quoteRun, _ := quote.AddRun()
        quoteRun.AddText("This is an intense quote. It stands out from the normal text with special formatting.")

        // Heading 2
        h2_2, _ := doc.AddParagraph()
        h2_2.SetStyle(domain.StyleIDHeading2)
        h2_2Run, _ := h2_2.AddRun()
        h2_2Run.AddText("1.2 Lists and References")

        // List paragraph
        list, _ := doc.AddParagraph()
        list.SetStyle(domain.StyleIDListParagraph)
        listRun, _ := list.AddRun()
        listRun.AddText("• First item in the list")

        list2, _ := doc.AddParagraph()
        list2.SetStyle(domain.StyleIDListParagraph)
        list2Run, _ := list2.AddRun()
        list2Run.AddText("• Second item in the list")

        doc.AddParagraph()

        // Heading 1
        h1_2, _ := doc.AddParagraph()
        h1_2.SetStyle(domain.StyleIDHeading1)
        h1_2Run, _ := h1_2.AddRun()
        h1_2Run.AddText("2. Available Built-in Styles")

        // Description
        infoPara, _ := doc.AddParagraph()
        infoPara.SetStyle(domain.StyleIDNormal)
        infoRun, _ := infoPara.AddRun()
        infoRun.AddText("This document demonstrates several built-in styles:")

        // Get style manager to query available styles
        styleMgr := doc.StyleManager()

        // List common built-in styles dynamically
        commonStyleIDs := []string{
                domain.StyleIDNormal,
                domain.StyleIDHeading1,
                domain.StyleIDHeading2,
                domain.StyleIDHeading3,
                domain.StyleIDTitle,
                domain.StyleIDSubtitle,
                domain.StyleIDQuote,
                domain.StyleIDIntenseQuote,
                domain.StyleIDListParagraph,
                domain.StyleIDCaption,
        }

        for _, styleID := range commonStyleIDs </span><span class="cov0" title="0">{
                if styleMgr.HasStyle(styleID) </span><span class="cov0" title="0">{
                        stylePara, _ := doc.AddParagraph()
                        stylePara.SetStyle(domain.StyleIDListParagraph)
                        styleRun, _ := stylePara.AddRun()

                        // Get style to display its name
                        if style, err := styleMgr.GetStyle(styleID); err == nil </span><span class="cov0" title="0">{
                                styleRun.AddText(fmt.Sprintf("• %s (%s)", style.Name(), styleID))
                        }</span>
                }
        }

        <span class="cov0" title="0">doc.AddParagraph()

        // Heading 1
        h1_3, _ := doc.AddParagraph()
        h1_3.SetStyle(domain.StyleIDHeading1)
        h1_3Run, _ := h1_3.AddRun()
        h1_3Run.AddText("3. Character Styles")

        // Paragraph with mixed character styles
        mixedPara, _ := doc.AddParagraph()
        mixedPara.SetStyle(domain.StyleIDNormal)

        r1, _ := mixedPara.AddRun()
        r1.AddText("This paragraph has ")

        r2, _ := mixedPara.AddRun()
        r2.SetBold(true)
        r2.AddText("bold text")

        r3, _ := mixedPara.AddRun()
        r3.AddText(", ")

        r4, _ := mixedPara.AddRun()
        r4.SetItalic(true)
        r4.AddText("italic text")

        r5, _ := mixedPara.AddRun()
        r5.AddText(", and ")

        r6, _ := mixedPara.AddRun()
        r6.SetColor(domain.Color{R: 255, G: 0, B: 0}) // Red
        r6.AddText("colored text")

        r7, _ := mixedPara.AddRun()
        r7.AddText(".")

        doc.AddParagraph()

        // Heading 1
        h1_4, _ := doc.AddParagraph()
        h1_4.SetStyle(domain.StyleIDHeading1)
        h1_4Run, _ := h1_4.AddRun()
        h1_4Run.AddText("4. Subtitle Example")

        // Subtitle
        subtitle, _ := doc.AddParagraph()
        subtitle.SetStyle(domain.StyleIDSubtitle)
        subtitleRun, _ := subtitle.AddRun()
        subtitleRun.AddText("This is a subtitle with special formatting")

        // Save the document
        if err := doc.SaveAs("05_styles_demo.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Document created successfully: 05_styles_demo.docx")
        fmt.Println("\nThe document demonstrates:")
        fmt.Println("- Title and Subtitle styles")
        fmt.Println("- Heading styles (1-3)")
        fmt.Println("- Normal paragraph style")
        fmt.Println("- Quote and Intense Quote styles")
        fmt.Println("- List paragraph style")
        fmt.Println("- Footnote reference style")
        fmt.Println("- Character-level formatting (bold, italic, color)")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "fmt"
        "log"

        docx "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        // Create a new document
        doc := docx.NewDocument()

        // Get the default section
        section, err := doc.DefaultSection()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get default section: %v", err)
        }</span>

        // Multi-section documents are now supported; this example focuses on
        // configuring the default section to showcase the page layout knobs.

        // Configure page layout
        <span class="cov0" title="0">section.SetPageSize(domain.PageSizeA4)
        section.SetOrientation(domain.OrientationLandscape)

        // Set margins (in twips: 1440 = 1 inch)
        margins := domain.Margins{
                Top:    1080, // 0.75 in
                Right:  1800, // 1.25 in to emphasize the change
                Bottom: 1080,
                Left:   1800,
                Header: 720, // 0.5 inch
                Footer: 720, // 0.5 inch
        }
        section.SetMargins(margins)
        section.SetColumns(2)

        // Add header to default section
        header, err := section.Header(domain.HeaderDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get header: %v", err)
        }</span>

        <span class="cov0" title="0">headerPara, _ := header.AddParagraph()
        headerPara.SetAlignment(domain.AlignmentRight)
        headerRun, _ := headerPara.AddRun()
        headerRun.AddText("Section &amp; Layout Demo")
        headerRun.SetBold(true)
        headerRun.SetColor(domain.Color{R: 0x44, G: 0x72, B: 0xC4}) // Blue

        // Add footer with page numbers
        footer, err := section.Footer(domain.FooterDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get footer: %v", err)
        }</span>

        <span class="cov0" title="0">footerPara, _ := footer.AddParagraph()
        footerPara.SetAlignment(domain.AlignmentCenter)

        footerRun1, _ := footerPara.AddRun()
        footerRun1.AddText("Page ")

        footerRun2, _ := footerPara.AddRun()
        pageField := docx.NewPageNumberField()
        footerRun2.AddField(pageField)

        footerRun3, _ := footerPara.AddRun()
        footerRun3.AddText(" of ")

        footerRun4, _ := footerPara.AddRun()
        totalField := docx.NewPageCountField()
        footerRun4.AddField(totalField)

        // Add title
        title, _ := doc.AddParagraph()
        title.SetStyle(domain.StyleIDTitle)
        titleRun, _ := title.AddRun()
        titleRun.AddText("Section Management Demo")

        doc.AddParagraph()

        // Heading 1
        h1, _ := doc.AddParagraph()
        h1.SetStyle(domain.StyleIDHeading1)
        h1Run, _ := h1.AddRun()
        h1Run.AddText("1. Page Layout")

        // Description
        desc1, _ := doc.AddParagraph()
        desc1.SetStyle(domain.StyleIDNormal)
        desc1Run, _ := desc1.AddRun()
        desc1Run.AddText("This document demonstrates the available section layout controls (landscape orientation, custom margins, and two-column layout applied to the entire section):")

        // List items
        item1, _ := doc.AddParagraph()
        item1.SetStyle(domain.StyleIDListParagraph)
        item1Run, _ := item1.AddRun()
        item1Run.AddText("• Page size: A4 (210mm × 297mm)")

        item2, _ := doc.AddParagraph()
        item2.SetStyle(domain.StyleIDListParagraph)
        item2Run, _ := item2.AddRun()
        item2Run.AddText("• Orientation: Landscape")

        item3, _ := doc.AddParagraph()
        item3.SetStyle(domain.StyleIDListParagraph)
        item3Run, _ := item3.AddRun()
        item3Run.AddText("• Margins: 0.75 in top/bottom, 1.25 in left/right")

        item4, _ := doc.AddParagraph()
        item4.SetStyle(domain.StyleIDListParagraph)
        item4Run, _ := item4.AddRun()
        item4Run.AddText("• Header margin: 0.5 inch")

        item5, _ := doc.AddParagraph()
        item5.SetStyle(domain.StyleIDListParagraph)
        item5Run, _ := item5.AddRun()
        item5Run.AddText("• Footer margin: 0.5 inch")

        item6, _ := doc.AddParagraph()
        item6.SetStyle(domain.StyleIDListParagraph)
        item6Run, _ := item6.AddRun()
        item6Run.AddText("• Columns: 2 (news-style layout)")

        doc.AddParagraph()

        // Heading 1
        h1_2, _ := doc.AddParagraph()
        h1_2.SetStyle(domain.StyleIDHeading1)
        h1_2Run, _ := h1_2.AddRun()
        h1_2Run.AddText("2. Headers and Footers")

        // Description
        desc2, _ := doc.AddParagraph()
        desc2.SetStyle(domain.StyleIDNormal)
        desc2Run, _ := desc2.AddRun()
        desc2Run.AddText("This document has:")

        // Header info
        hItem1, _ := doc.AddParagraph()
        hItem1.SetStyle(domain.StyleIDListParagraph)
        hItem1Run, _ := hItem1.AddRun()
        hItem1Run.AddText("• Header: Right-aligned title (see top of page)")

        // Footer info
        hItem2, _ := doc.AddParagraph()
        hItem2.SetStyle(domain.StyleIDListParagraph)
        hItem2Run, _ := hItem2.AddRun()
        hItem2Run.AddText("• Footer: Center-aligned page numbers (see bottom)")

        doc.AddParagraph()

        // Heading 1
        h1_3, _ := doc.AddParagraph()
        h1_3.SetStyle(domain.StyleIDHeading1)
        h1_3Run, _ := h1_3.AddRun()
        h1_3Run.AddText("3. Available Page Sizes")

        // Page size info
        psDesc, _ := doc.AddParagraph()
        psDesc.SetStyle(domain.StyleIDNormal)
        psDescRun, _ := psDesc.AddRun()
        psDescRun.AddText("go-docx v2 supports these predefined page sizes:")

        sizes := []struct {
                name string
                desc string
        }{
                {"A3", "297mm × 420mm"},
                {"A4", "210mm × 297mm (used in this document)"},
                {"A5", "148mm × 210mm"},
                {"Letter", "8.5in × 11in"},
                {"Legal", "8.5in × 14in"},
                {"Tabloid", "11in × 17in"},
        }

        for _, size := range sizes </span><span class="cov0" title="0">{
                sizePara, _ := doc.AddParagraph()
                sizePara.SetStyle(domain.StyleIDListParagraph)
                sizeRun, _ := sizePara.AddRun()
                sizeRun.AddText(fmt.Sprintf("• %s: %s", size.name, size.desc))
        }</span>

        <span class="cov0" title="0">doc.AddParagraph()

        // Heading 1
        h1_4, _ := doc.AddParagraph()
        h1_4.SetStyle(domain.StyleIDHeading1)
        h1_4Run, _ := h1_4.AddRun()
        h1_4Run.AddText("4. Orientation Options")

        // Orientation info
        oriDesc, _ := doc.AddParagraph()
        oriDesc.SetStyle(domain.StyleIDNormal)
        oriDescRun, _ := oriDesc.AddRun()
        oriDescRun.AddText("You can set page orientation:")

        ori1, _ := doc.AddParagraph()
        ori1.SetStyle(domain.StyleIDListParagraph)
        ori1Run, _ := ori1.AddRun()
        ori1Run.AddText("• Portrait (default option)")

        ori2, _ := doc.AddParagraph()
        ori2.SetStyle(domain.StyleIDListParagraph)
        ori2Run, _ := ori2.AddRun()
        ori2Run.AddText("• Landscape (used in this demo)")

        doc.AddParagraph()

        // Heading 1
        h1_5, _ := doc.AddParagraph()
        h1_5.SetStyle(domain.StyleIDHeading1)
        h1_5Run, _ := h1_5.AddRun()
        h1_5Run.AddText("5. Column Layouts")

        // Column info
        colDesc, _ := doc.AddParagraph()
        colDesc.SetStyle(domain.StyleIDNormal)
        colDescRun, _ := colDesc.AddRun()
        colDescRun.AddText("Sections support multiple column layouts:")

        col1, _ := doc.AddParagraph()
        col1.SetStyle(domain.StyleIDListParagraph)
        col1Run, _ := col1.AddRun()
        col1Run.AddText("• Single column (default)")

        col2, _ := doc.AddParagraph()
        col2.SetStyle(domain.StyleIDListParagraph)
        col2Run, _ := col2.AddRun()
        col2Run.AddText("• Two columns (newspaper style – applied in this demo)")

        col3, _ := doc.AddParagraph()
        col3.SetStyle(domain.StyleIDListParagraph)
        col3Run, _ := col3.AddRun()
        col3Run.AddText("• Three or more columns")

        // Add filler content to demonstrate multi-page
        doc.AddParagraph()
        h1_6, _ := doc.AddParagraph()
        h1_6.SetStyle(domain.StyleIDHeading1)
        h1_6Run, _ := h1_6.AddRun()
        h1_6Run.AddText("6. Sample Content")

        for i := 1; i &lt;= 15; i++ </span><span class="cov0" title="0">{
                para, _ := doc.AddParagraph()
                para.SetStyle(domain.StyleIDNormal)
                run, _ := para.AddRun()
                run.AddText(fmt.Sprintf("This is paragraph %d. It provides sample content to demonstrate how the page layout, margins, and headers/footers work across multiple pages. Notice the consistent header at the top and page numbers at the bottom.", i))
        }</span>

        // Save the document
        <span class="cov0" title="0">if err := doc.SaveAs("06_sections_demo.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Document created successfully: 06_sections_demo.docx")
        fmt.Println("\nThe document demonstrates:")
        fmt.Println("- A4 page size with landscape orientation")
        fmt.Println("- Custom margins (0.75\" top/bottom, 1.25\" left/right)")
        fmt.Println("- Custom header with document title")
        fmt.Println("- Footer with dynamic page numbers (Page X of Y)")
        fmt.Println("- Two-column layout applied to the section")
        fmt.Println("- Multiple pages to show consistent layout")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "fmt"
        "log"

        docx "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        // Create a new document
        doc := docx.NewDocument()

        // Configure page layout
        section, _ := doc.DefaultSection()
        section.SetPageSize(domain.PageSizeA4)
        section.SetOrientation(domain.OrientationPortrait)
        section.SetMargins(domain.Margins{
                Top:    1440,
                Right:  1440,
                Bottom: 1440,
                Left:   1440,
                Header: 720,
                Footer: 720,
        })

        // Setup header with document info
        header, _ := section.Header(domain.HeaderDefault)
        setupHeader(header)

        // Setup footer with page numbers
        footer, _ := section.Footer(domain.FooterDefault)
        setupFooter(footer)

        // Add cover page
        addCoverPage(doc)

        // Add table of contents
        addTableOfContents(doc)

        // Add main content sections
        addIntroduction(doc)
        addFeatures(doc)
        addExamples(doc)
        addConclusion(doc)

        // Save the document
        if err := doc.SaveAs("07_advanced_demo.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Advanced document created successfully: 07_advanced_demo.docx")
        fmt.Println("\nThis document demonstrates:")
        fmt.Println("✓ Professional page layout (A4, portrait, 1-inch margins)")
        fmt.Println("✓ Custom header and footer with fields")
        fmt.Println("✓ Cover page with Title style")
        fmt.Println("✓ Table of Contents with hyperlinks")
        fmt.Println("✓ Multiple heading levels (H1, H2, H3)")
        fmt.Println("✓ Various paragraph styles (Normal, Quote, List)")
        fmt.Println("✓ Character formatting (bold, italic, color, hyperlinks)")
        fmt.Println("✓ Dynamic fields (page numbers, TOC, hyperlinks)")
        fmt.Println("\nTo update the TOC, open the document and press F9 or right-click &gt; Update Field")</span>
}

func setupHeader(header domain.Header) <span class="cov0" title="0">{
        para, _ := header.AddParagraph()
        para.SetAlignment(domain.AlignmentRight)

        run, _ := para.AddRun()
        run.AddText("go-docx v2 • Advanced Features Demo")
        run.SetSize(20)                                       // 10pt in half-points
        run.SetColor(domain.Color{R: 0x44, G: 0x72, B: 0xC4}) // Blue
}</span>

func setupFooter(footer domain.Footer) <span class="cov0" title="0">{
        para, _ := footer.AddParagraph()
        para.SetAlignment(domain.AlignmentCenter)

        // Left part: Document info
        r1, _ := para.AddRun()
        r1.AddText("Page ")
        r1.SetSize(20) // 10pt in half-points

        // Page number field
        r2, _ := para.AddRun()
        pageField := docx.NewPageNumberField()
        r2.AddField(pageField)
        r2.SetSize(20)

        r3, _ := para.AddRun()
        r3.AddText(" of ")
        r3.SetSize(20)

        // Total pages field
        r4, _ := para.AddRun()
        totalField := docx.NewPageCountField()
        r4.AddField(totalField)
        r4.SetSize(20)
}</span>

func addCoverPage(doc domain.Document) <span class="cov0" title="0">{
        // Title
        title, _ := doc.AddParagraph()
        title.SetStyle(domain.StyleIDTitle)
        title.SetAlignment(domain.AlignmentCenter)
        titleRun, _ := title.AddRun()
        titleRun.AddText("Advanced Document Creation")

        doc.AddParagraph()

        // Subtitle
        subtitle, _ := doc.AddParagraph()
        subtitle.SetStyle(domain.StyleIDSubtitle)
        subtitle.SetAlignment(domain.AlignmentCenter)
        subtitleRun, _ := subtitle.AddRun()
        subtitleRun.AddText("Demonstrating All Phase 6 Features")

        doc.AddParagraph()
        doc.AddParagraph()

        // Author info
        author, _ := doc.AddParagraph()
        author.SetAlignment(domain.AlignmentCenter)
        authorRun, _ := author.AddRun()
        authorRun.AddText("Created with go-docx v2")
        authorRun.SetItalic(true)

        doc.AddParagraph()
        doc.AddParagraph()
}</span>

func addTableOfContents(doc domain.Document) <span class="cov0" title="0">{
        // TOC heading
        tocHeading, _ := doc.AddParagraph()
        tocHeading.SetStyle(domain.StyleIDHeading1)
        tocRun, _ := tocHeading.AddRun()
        tocRun.AddText("Table of Contents")

        doc.AddParagraph()

        // Add TOC field
        tocPara, _ := doc.AddParagraph()
        tocFieldRun, _ := tocPara.AddRun()

        tocOptions := map[string]string{
                "levels":          "1-3",
                "hyperlinks":      "true",
                "hidePageNumbers": "false",
        }
        tocField := docx.NewTOCField(tocOptions)
        tocFieldRun.AddField(tocField)

        // Instructions
        doc.AddParagraph()
        instruction, _ := doc.AddParagraph()
        instruction.SetStyle(domain.StyleIDIntenseQuote)
        instRun, _ := instruction.AddRun()
        instRun.AddText("Note: To update this table of contents, open the document in Word, right-click the TOC, and select \"Update Field\", or press F9.")
        instRun.SetItalic(true)
        instRun.SetSize(20) // 10pt in half-points

        doc.AddParagraph()
        doc.AddParagraph()
}</span>

func addIntroduction(doc domain.Document) <span class="cov0" title="0">{
        // Heading 1
        h1, _ := doc.AddParagraph()
        h1.SetStyle(domain.StyleIDHeading1)
        h1Run, _ := h1.AddRun()
        h1Run.AddText("1. Introduction")

        // Paragraph
        intro, _ := doc.AddParagraph()
        intro.SetStyle(domain.StyleIDNormal)
        introRun, _ := intro.AddRun()
        introRun.AddText("This document demonstrates the advanced features available in go-docx v2. It showcases sections, headers, footers, fields, and comprehensive style management.")

        doc.AddParagraph()

        // Heading 2
        h2, _ := doc.AddParagraph()
        h2.SetStyle(domain.StyleIDHeading2)
        h2Run, _ := h2.AddRun()
        h2Run.AddText("1.1 Purpose")

        purpose, _ := doc.AddParagraph()
        purpose.SetStyle(domain.StyleIDNormal)
        purposeRun, _ := purpose.AddRun()
        purposeRun.AddText("The goal is to provide a complete example that developers can reference when building professional documents programmatically.")

        doc.AddParagraph()
}</span>

func addFeatures(doc domain.Document) <span class="cov0" title="0">{
        // Heading 1
        h1, _ := doc.AddParagraph()
        h1.SetStyle(domain.StyleIDHeading1)
        h1Run, _ := h1.AddRun()
        h1Run.AddText("2. Features Overview")

        // Intro
        intro, _ := doc.AddParagraph()
        intro.SetStyle(domain.StyleIDNormal)
        introRun, _ := intro.AddRun()
        introRun.AddText("go-docx v2 Phase 6 introduces several powerful capabilities:")

        doc.AddParagraph()

        // Heading 2 - Sections
        h2_1, _ := doc.AddParagraph()
        h2_1.SetStyle(domain.StyleIDHeading2)
        h2_1Run, _ := h2_1.AddRun()
        h2_1Run.AddText("2.1 Section Management")

        sectDesc, _ := doc.AddParagraph()
        sectDesc.SetStyle(domain.StyleIDNormal)
        sectDescRun, _ := sectDesc.AddRun()
        sectDescRun.AddText("Complete control over page layout:")

        features := []string{
                "Page sizes (A3, A4, A5, Letter, Legal, Tabloid)",
                "Orientation (Portrait, Landscape)",
                "Margins (all sides configurable)",
                "Multi-column layouts",
        }

        for _, feature := range features </span><span class="cov0" title="0">{
                p, _ := doc.AddParagraph()
                p.SetStyle(domain.StyleIDListParagraph)
                r, _ := p.AddRun()
                r.AddText("• " + feature)
        }</span>

        <span class="cov0" title="0">doc.AddParagraph()

        // Heading 2 - Headers/Footers
        h2_2, _ := doc.AddParagraph()
        h2_2.SetStyle(domain.StyleIDHeading2)
        h2_2Run, _ := h2_2.AddRun()
        h2_2Run.AddText("2.2 Headers and Footers")

        hfDesc, _ := doc.AddParagraph()
        hfDesc.SetStyle(domain.StyleIDNormal)
        hfDescRun, _ := hfDesc.AddRun()
        hfDescRun.AddText("Professional header and footer support:")

        hfFeatures := []string{
                "Three types: Default, First, Even",
                "Dynamic fields (page numbers, document properties)",
                "Full formatting capabilities",
        }

        for _, feature := range hfFeatures </span><span class="cov0" title="0">{
                p, _ := doc.AddParagraph()
                p.SetStyle(domain.StyleIDListParagraph)
                r, _ := p.AddRun()
                r.AddText("• " + feature)
        }</span>

        <span class="cov0" title="0">doc.AddParagraph()

        // Heading 2 - Fields
        h2_3, _ := doc.AddParagraph()
        h2_3.SetStyle(domain.StyleIDHeading2)
        h2_3Run, _ := h2_3.AddRun()
        h2_3Run.AddText("2.3 Field System")

        fieldDesc, _ := doc.AddParagraph()
        fieldDesc.SetStyle(domain.StyleIDNormal)
        fieldDescRun, _ := fieldDesc.AddRun()
        fieldDescRun.AddText("Nine field types for dynamic content:")

        fieldTypes := []string{
                "Page numbers and page count",
                "Table of Contents (see above)",
                "Hyperlinks (see examples below)",
                "Date and time",
                "Document properties",
        }

        for _, field := range fieldTypes </span><span class="cov0" title="0">{
                p, _ := doc.AddParagraph()
                p.SetStyle(domain.StyleIDListParagraph)
                r, _ := p.AddRun()
                r.AddText("• " + field)
        }</span>

        <span class="cov0" title="0">doc.AddParagraph()

        // Heading 2 - Styles
        h2_4, _ := doc.AddParagraph()
        h2_4.SetStyle(domain.StyleIDHeading2)
        h2_4Run, _ := h2_4.AddRun()
        h2_4Run.AddText("2.4 Style Management")

        styleDesc, _ := doc.AddParagraph()
        styleDesc.SetStyle(domain.StyleIDNormal)
        styleDescRun, _ := styleDesc.AddRun()
        styleDescRun.AddText("Comprehensive style system:")

        styleFeatures := []string{
                "40+ built-in styles with type-safe constants",
                "StyleManager for querying and custom styles",
                "Paragraph and character styles",
        }

        for _, feature := range styleFeatures </span><span class="cov0" title="0">{
                p, _ := doc.AddParagraph()
                p.SetStyle(domain.StyleIDListParagraph)
                r, _ := p.AddRun()
                r.AddText("• " + feature)
        }</span>

        <span class="cov0" title="0">doc.AddParagraph()</span>
}

func addExamples(doc domain.Document) <span class="cov0" title="0">{
        // Heading 1
        h1, _ := doc.AddParagraph()
        h1.SetStyle(domain.StyleIDHeading1)
        h1Run, _ := h1.AddRun()
        h1Run.AddText("3. Code Examples")

        // Heading 2
        h2, _ := doc.AddParagraph()
        h2.SetStyle(domain.StyleIDHeading2)
        h2Run, _ := h2.AddRun()
        h2Run.AddText("3.1 Hyperlink Example")

        linkDesc, _ := doc.AddParagraph()
        linkDesc.SetStyle(domain.StyleIDNormal)

        r1, _ := linkDesc.AddRun()
        r1.AddText("Visit the ")

        // Hyperlink
        r2, _ := linkDesc.AddRun()
        linkField := docx.NewHyperlinkField(
                "https://github.com/mmonterroca/docxgo",
                "go-docx GitHub repository",
        )
        r2.SetColor(domain.Color{R: 0x00, G: 0x00, B: 0xFF}) // Blue
        r2.SetUnderline(domain.UnderlineSingle)
        r2.AddField(linkField)

        r3, _ := linkDesc.AddRun()
        r3.AddText(" for more information.")

        doc.AddParagraph()

        // Heading 2
        h2_2, _ := doc.AddParagraph()
        h2_2.SetStyle(domain.StyleIDHeading2)
        h2_2Run, _ := h2_2.AddRun()
        h2_2Run.AddText("3.2 Quote Example")

        quote, _ := doc.AddParagraph()
        quote.SetStyle(domain.StyleIDIntenseQuote)
        quoteRun, _ := quote.AddRun()
        quoteRun.AddText("\"The best way to predict the future is to create it.\" - This demonstrates the IntenseQuote style.")

        doc.AddParagraph()

        // Heading 2
        h2_3, _ := doc.AddParagraph()
        h2_3.SetStyle(domain.StyleIDHeading2)
        h2_3Run, _ := h2_3.AddRun()
        h2_3Run.AddText("3.3 Mixed Formatting")

        mixed, _ := doc.AddParagraph()
        mixed.SetStyle(domain.StyleIDNormal)

        mr1, _ := mixed.AddRun()
        mr1.AddText("This paragraph demonstrates ")

        mr2, _ := mixed.AddRun()
        mr2.SetBold(true)
        mr2.AddText("bold text")

        mr3, _ := mixed.AddRun()
        mr3.AddText(", ")

        mr4, _ := mixed.AddRun()
        mr4.SetItalic(true)
        mr4.AddText("italic text")

        mr5, _ := mixed.AddRun()
        mr5.AddText(", ")

        mr6, _ := mixed.AddRun()
        mr6.SetColor(domain.Color{R: 0xFF, G: 0x00, B: 0x00}) // Red
        mr6.AddText("colored text")

        mr7, _ := mixed.AddRun()
        mr7.AddText(", and ")

        mr8, _ := mixed.AddRun()
        mr8.SetBold(true)
        mr8.SetItalic(true)
        mr8.SetColor(domain.Color{R: 0x00, G: 0xAA, B: 0x00}) // Green
        mr8.AddText("combined formatting")

        mr9, _ := mixed.AddRun()
        mr9.AddText(".")

        doc.AddParagraph()
}</span>

func addConclusion(doc domain.Document) <span class="cov0" title="0">{
        // Heading 1
        h1, _ := doc.AddParagraph()
        h1.SetStyle(domain.StyleIDHeading1)
        h1Run, _ := h1.AddRun()
        h1Run.AddText("4. Conclusion")

        // Summary
        summary, _ := doc.AddParagraph()
        summary.SetStyle(domain.StyleIDNormal)
        summaryRun, _ := summary.AddRun()
        summaryRun.AddText("This document demonstrates the complete feature set of go-docx v2 Phase 6. All advanced capabilities work together seamlessly to create professional documents programmatically.")

        doc.AddParagraph()

        // Next steps heading
        h2, _ := doc.AddParagraph()
        h2.SetStyle(domain.StyleIDHeading2)
        h2Run, _ := h2.AddRun()
        h2Run.AddText("4.1 Next Steps")

        // Next steps list
        nextSteps := []string{
                "Explore individual examples (05_styles, 06_sections, 04_fields)",
                "Read the API documentation for detailed reference",
                "Check the migration guide for v1 to v2 transition",
                "Contribute to the project on GitHub",
        }

        for _, step := range nextSteps </span><span class="cov0" title="0">{
                p, _ := doc.AddParagraph()
                p.SetStyle(domain.StyleIDListParagraph)
                r, _ := p.AddRun()
                r.AddText("• " + step)
        }</span>

        <span class="cov0" title="0">doc.AddParagraph()
        doc.AddParagraph()

        // Final note
        final, _ := doc.AddParagraph()
        final.SetStyle(domain.StyleIDIntenseQuote)
        final.SetAlignment(domain.AlignmentCenter)
        finalRun, _ := final.AddRun()
        finalRun.AddText("Thank you for using go-docx v2!")
        finalRun.SetBold(true)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca

Example: Image insertion with various positioning options

This example demonstrates:
- Adding inline images to paragraphs
- Custom image sizes
- Floating images with positioning
- Builder pattern for fluent API
*/

package main

import (
        "fmt"
        "image"
        "image/color"
        "image/png"
        "log"
        "os"
        "path/filepath"

        "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func createSampleImage(path string, width, height int, fillColor color.RGBA) error <span class="cov0" title="0">{
        // Create a simple colored rectangle
        img := image.NewRGBA(image.Rect(0, 0, width, height))

        // Fill with gradient or solid color
        for y := 0; y &lt; height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; width; x++ </span><span class="cov0" title="0">{
                        r := uint8(int(fillColor.R) * x / width)
                        g := uint8(int(fillColor.G) * y / height)
                        b := fillColor.B
                        img.Set(x, y, color.RGBA{R: r, G: g, B: b, A: 255})
                }</span>
        }

        // Ensure directory exists
        <span class="cov0" title="0">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save to file
        <span class="cov0" title="0">f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        return png.Encode(f, img)</span>
}

func main() <span class="cov0" title="0">{
        // Create temporary directory for sample images
        tmpDir := "temp_images"
        defer os.RemoveAll(tmpDir)

        // Create sample images
        redImage := filepath.Join(tmpDir, "red_box.png")
        if err := createSampleImage(redImage, 400, 300, color.RGBA{R: 255, G: 0, B: 0, A: 255}); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create red image: %v", err)
        }</span>

        <span class="cov0" title="0">blueImage := filepath.Join(tmpDir, "blue_box.png")
        if err := createSampleImage(blueImage, 600, 400, color.RGBA{R: 0, G: 0, B: 255, A: 255}); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create blue image: %v", err)
        }</span>

        <span class="cov0" title="0">greenImage := filepath.Join(tmpDir, "green_box.png")
        if err := createSampleImage(greenImage, 300, 300, color.RGBA{R: 0, G: 255, B: 0, A: 255}); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create green image: %v", err)
        }</span>

        // Create document with builder
        <span class="cov0" title="0">builder := docx.NewDocumentBuilder()

        // Title
        builder.AddParagraph().
                Text("Image Insertion Examples").
                Bold().
                FontSize(24).
                Alignment(domain.AlignmentCenter).
                End()

        builder.AddParagraph().Text("").End() // Blank line

        // Example 1: Inline image (default size)
        builder.AddParagraph().
                Text("1. Inline Image (Default Size)").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("This paragraph contains an inline image: ").
                AddImage(redImage).
                Text(" &lt;- Red box image").
                End()

        builder.AddParagraph().Text("").End()

        // Example 2: Custom sized image
        builder.AddParagraph().
                Text("2. Custom Sized Image").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Blue box resized to 300x200 pixels: ").
                End()

        customSize := domain.NewImageSize(300, 200)
        builder.AddParagraph().
                AddImageWithSize(blueImage, customSize).
                End()

        builder.AddParagraph().Text("").End()

        // Example 3: Image sized in inches
        builder.AddParagraph().
                Text("3. Image Sized in Inches").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Green box at 2x2 inches: ").
                End()

        inchSize := domain.NewImageSizeInches(2.0, 2.0)
        builder.AddParagraph().
                AddImageWithSize(greenImage, inchSize).
                End()

        builder.AddParagraph().Text("").End()

        // Example 4: Floating image (centered)
        builder.AddParagraph().
                Text("4. Floating Image (Center Aligned)").
                Bold().
                FontSize(16).
                End()

        floatingSize := domain.NewImageSize(250, 187)
        centerPos := domain.ImagePosition{
                Type:       domain.ImagePositionFloating,
                HAlign:     domain.HAlignCenter,
                VAlign:     domain.VAlignTop,
                WrapText:   domain.WrapSquare,
                BehindText: false,
        }

        builder.AddParagraph().
                Text("This text wraps around the centered floating image below.").
                End()

        builder.AddParagraph().
                AddImageWithPosition(redImage, floatingSize, centerPos).
                End()

        builder.AddParagraph().
                Text("Lorem ipsum dolor sit amet, consectetur adipiscing elit. ").
                Text("Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ").
                Text("Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris.").
                End()

        builder.AddParagraph().Text("").End()

        // Example 5: Floating image (left aligned with text wrap)
        builder.AddParagraph().
                Text("5. Floating Image (Left Aligned with Text Wrap)").
                Bold().
                FontSize(16).
                End()

        leftPos := domain.ImagePosition{
                Type:       domain.ImagePositionFloating,
                HAlign:     domain.HAlignLeft,
                VAlign:     domain.VAlignTop,
                WrapText:   domain.WrapSquare,
                OffsetX:    0,
                OffsetY:    0,
                BehindText: false,
        }

        builder.AddParagraph().
                AddImageWithPosition(greenImage, domain.NewImageSize(200, 200), leftPos).
                Text("This text wraps around a left-aligned image. ").
                Text("The image is positioned to the left and the text flows around it. ").
                Text("This creates a professional magazine-style layout. ").
                Text("You can control the text wrapping behavior using different wrap types. ").
                Text("Lorem ipsum dolor sit amet, consectetur adipiscing elit.").
                End()

        builder.AddParagraph().Text("").End()

        // Example 6: Right-aligned floating image
        builder.AddParagraph().
                Text("6. Floating Image (Right Aligned)").
                Bold().
                FontSize(16).
                End()

        rightPos := domain.ImagePosition{
                Type:       domain.ImagePositionFloating,
                HAlign:     domain.HAlignRight,
                VAlign:     domain.VAlignTop,
                WrapText:   domain.WrapTight,
                BehindText: false,
        }

        builder.AddParagraph().
                AddImageWithPosition(blueImage, domain.NewImageSize(180, 120), rightPos).
                Text("This paragraph has a right-aligned floating image. ").
                Text("The tight wrap setting allows text to flow very close to the image edge. ").
                Text("This is useful for creating compact layouts with minimal white space. ").
                Text("Notice how the text wraps tightly around the image boundary.").
                End()

        builder.AddParagraph().Text("").End()

        // Example 7: Multiple images in a paragraph
        builder.AddParagraph().
                Text("7. Multiple Images in One Paragraph").
                Bold().
                FontSize(16).
                End()

        smallSize := domain.NewImageSize(80, 60)
        builder.AddParagraph().
                Text("Small images inline: ").
                AddImageWithSize(redImage, smallSize).
                Text(" ").
                AddImageWithSize(blueImage, smallSize).
                Text(" ").
                AddImageWithSize(greenImage, smallSize).
                Text(" &lt;- Three inline images").
                End()

        // Save document
        doc, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to build document: %v", err)
        }</span>

        <span class="cov0" title="0">outputPath := "08_images_output.docx"
        if err := doc.SaveAs(outputPath); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Document created successfully: %s\n", outputPath)
        fmt.Println("\nFeatures demonstrated:")
        fmt.Println("  - Inline images (default size)")
        fmt.Println("  - Custom image sizes (pixels)")
        fmt.Println("  - Image sizes in inches")
        fmt.Println("  - Floating images (center, left, right)")
        fmt.Println("  - Text wrapping (square, tight)")
        fmt.Println("  - Multiple images in one paragraph")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca

Example: Advanced table features - cell merging, nested tables, and styling

This example demonstrates:
- Horizontal cell merging (colspan)
- Vertical cell merging (rowspan)
- Combined horizontal and vertical merging
- Nested tables within cells
- Table styling
- Row height control
- Complex table layouts (calendar, invoice, etc.)
*/

package main

import (
        "fmt"
        "log"
        "time"

        "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        builder := docx.NewDocumentBuilder()

        // Title
        builder.AddParagraph().
                Text("Advanced Table Features").
                Bold().
                FontSize(24).
                Alignment(domain.AlignmentCenter).
                End()

        builder.AddParagraph().Text("").End()

        // Example 1: Horizontal cell merging
        builder.AddParagraph().
                Text("1. Horizontal Cell Merging (Colspan)").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Merging cells horizontally to create headers or spans:").
                End()

        builder.AddTable(3, 4).
                Style(domain.TableStyleGrid).
                Row(0).
                Cell(0).Text("Header (spans 4 columns)").Bold().Merge(4, 1).End().
                End().
                Row(1).
                Cell(0).Text("A1").End().
                Cell(1).Text("B1").End().
                Cell(2).Text("C1").End().
                Cell(3).Text("D1").End().
                End().
                Row(2).
                Cell(0).Text("A2 (spans 2)").Merge(2, 1).End().
                Cell(2).Text("C2 (spans 2)").Merge(2, 1).End().
                End().
                End()

        builder.AddParagraph().Text("").End()

        // Example 2: Vertical cell merging
        builder.AddParagraph().
                Text("2. Vertical Cell Merging (Rowspan)").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Merging cells vertically for labels or categories:").
                End()

        builder.AddTable(4, 3).
                Style(domain.TableStyleGrid).
                Row(0).
                Cell(0).Text("Header 1").Bold().End().
                Cell(1).Text("Header 2").Bold().End().
                Cell(2).Text("Header 3").Bold().End().
                End().
                Row(1).
                Cell(0).Text("Category A\n(3 rows)").VerticalAlignment(domain.VerticalAlignCenter).Merge(1, 3).End().
                Cell(1).Text("Data 1").End().
                Cell(2).Text("Value 1").End().
                End().
                Row(2).
                Cell(1).Text("Data 2").End().
                Cell(2).Text("Value 2").End().
                End().
                Row(3).
                Cell(1).Text("Data 3").End().
                Cell(2).Text("Value 3").End().
                End().
                End()

        builder.AddParagraph().Text("").End()

        // Example 3: Combined merging (2x2 region)
        builder.AddParagraph().
                Text("3. Combined Horizontal and Vertical Merging").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Creating complex layouts with both colspan and rowspan:").
                End()

        builder.AddTable(4, 4).
                Style(domain.TableStyleGrid).
                Row(0).
                Cell(0).Text("2x2 Merged\nCell").
                VerticalAlignment(domain.VerticalAlignCenter).
                Merge(2, 2).End().
                Cell(2).Text("C1").End().
                Cell(3).Text("D1").End().
                End().
                Row(1).
                Cell(2).Text("C2").End().
                Cell(3).Text("D2").End().
                End().
                Row(2).
                Cell(0).Text("A3").End().
                Cell(1).Text("B3").End().
                Cell(2).Text("C3").End().
                Cell(3).Text("D3").End().
                End().
                Row(3).
                Cell(0).Text("Footer (spans all 4 columns)").Merge(4, 1).End().
                End().
                End()

        builder.AddParagraph().Text("").End()

        // Example 4: Calendar-style layout
        builder.AddParagraph().
                Text("4. Calendar Layout").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Using merging to create a monthly calendar:").
                End()

        now := time.Now()
        builder.AddTable(7, 7).
                Style(domain.TableStyleMediumShading).
                Row(0).
                Cell(0).Text(now.Format("January 2006")).Bold().Merge(7, 1).End().
                End().
                Row(1).
                Cell(0).Text("Sun").Bold().End().
                Cell(1).Text("Mon").Bold().End().
                Cell(2).Text("Tue").Bold().End().
                Cell(3).Text("Wed").Bold().End().
                Cell(4).Text("Thu").Bold().End().
                Cell(5).Text("Fri").Bold().End().
                Cell(6).Text("Sat").Bold().End().
                End().
                Row(2).
                Cell(0).Text("").End().
                Cell(1).Text("").End().
                Cell(2).Text("1").End().
                Cell(3).Text("2").End().
                Cell(4).Text("3").End().
                Cell(5).Text("4").End().
                Cell(6).Text("5").End().
                End().
                Row(3).
                Cell(0).Text("6").End().
                Cell(1).Text("7").End().
                Cell(2).Text("8").End().
                Cell(3).Text("9").End().
                Cell(4).Text("10").End().
                Cell(5).Text("11").End().
                Cell(6).Text("12").End().
                End().
                Row(4).
                Cell(0).Text("13").End().
                Cell(1).Text("14").End().
                Cell(2).Text("15").End().
                Cell(3).Text("16").End().
                Cell(4).Text("17").End().
                Cell(5).Text("18").End().
                Cell(6).Text("19").End().
                End().
                Row(5).
                Cell(0).Text("20").End().
                Cell(1).Text("21").End().
                Cell(2).Text("22").End().
                Cell(3).Text("23").End().
                Cell(4).Text("24").End().
                Cell(5).Text("25").End().
                Cell(6).Text("26").End().
                End().
                Row(6).
                Cell(0).Text("27").End().
                Cell(1).Text("28").End().
                Cell(2).Text("29").End().
                Cell(3).Text("30").End().
                Cell(4).Text("31").End().
                Cell(5).Text("").End().
                Cell(6).Text("").End().
                End().
                End()

        builder.AddParagraph().Text("").End()

        // Example 5: Nested tables
        builder.AddParagraph().
                Text("5. Nested Tables").
                Bold().
                FontSize(16).
                End()

        builder.AddParagraph().
                Text("Tables within table cells for complex layouts:").
                End()

        // Note: Nested tables need to be added via direct API, not builder yet
        doc, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to build document: %v", err)
        }</span>

        // Add nested table example using direct API
        <span class="cov0" title="0">outerTable, err := doc.AddTable(2, 2)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add outer table: %v", err)
        }</span>

        <span class="cov0" title="0">outerTable.SetStyle(domain.TableStyleGrid)

        row0, _ := outerTable.Row(0)
        cell00, _ := row0.Cell(0)
        para00, _ := cell00.AddParagraph()
        run00, _ := para00.AddRun()
        run00.SetText("Outer Cell A1")
        run00.SetBold(true)

        // Add nested table in cell (0,1)
        cell01, _ := row0.Cell(1)
        nested, err := cell01.AddTable(2, 2)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add nested table: %v", err)
        }</span>

        // Populate nested table
        <span class="cov0" title="0">nRow0, _ := nested.Row(0)
        nCell00, _ := nRow0.Cell(0)
        nPara00, _ := nCell00.AddParagraph()
        nRun00, _ := nPara00.AddRun()
        nRun00.SetText("Nested A1")

        nCell01, _ := nRow0.Cell(1)
        nPara01, _ := nCell01.AddParagraph()
        nRun01, _ := nPara01.AddRun()
        nRun01.SetText("Nested B1")

        nRow1, _ := nested.Row(1)
        nCell10, _ := nRow1.Cell(0)
        nPara10, _ := nCell10.AddParagraph()
        nRun10, _ := nPara10.AddRun()
        nRun10.SetText("Nested A2")

        nCell11, _ := nRow1.Cell(1)
        nPara11, _ := nCell11.AddParagraph()
        nRun11, _ := nPara11.AddRun()
        nRun11.SetText("Nested B2")

        // Continue with outer table
        row1, _ := outerTable.Row(1)
        cell10, _ := row1.Cell(0)
        para10, _ := cell10.AddParagraph()
        run10, _ := para10.AddRun()
        run10.SetText("Outer Cell A2")

        cell11, _ := row1.Cell(1)
        para11, _ := cell11.AddParagraph()
        run11, _ := para11.AddRun()
        run11.SetText("Outer Cell B2")

        // Example 6: Invoice-style table
        para, _ := doc.AddParagraph()
        run, _ := para.AddRun()
        run.SetText("")

        para, _ = doc.AddParagraph()
        run, _ = para.AddRun()
        run.SetText("6. Invoice Layout")
        run.SetBold(true)
        run.SetSize(16)

        para, _ = doc.AddParagraph()
        run, _ = para.AddRun()
        run.SetText("Professional invoice with merged header and footer:")

        invoice, err := doc.AddTable(6, 4)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add invoice table: %v", err)
        }</span>

        <span class="cov0" title="0">invoice.SetStyle(domain.TableStyleGrid)

        // Header
        iRow0, _ := invoice.Row(0)
        iCell0, _ := iRow0.Cell(0)
        iCell0.SetShading(domain.Color{R: 220, G: 220, B: 220})
        iPara0, _ := iCell0.AddParagraph()
        iRun0, _ := iPara0.AddRun()
        iRun0.SetText("INVOICE #12345")
        iRun0.SetBold(true)
        iCell0.Merge(4, 1)

        // Column headers
        iRow1, _ := invoice.Row(1)
        cells1 := []string{"Item", "Quantity", "Price", "Total"}
        for i, text := range cells1 </span><span class="cov0" title="0">{
                cell, _ := iRow1.Cell(i)
                cell.SetShading(domain.Color{R: 240, G: 240, B: 240})
                para, _ := cell.AddParagraph()
                run, _ := para.AddRun()
                run.SetText(text)
                run.SetBold(true)
        }</span>

        // Items
        <span class="cov0" title="0">items := [][]string{
                {"Product A", "2", "$10.00", "$20.00"},
                {"Product B", "1", "$25.00", "$25.00"},
                {"Product C", "3", "$5.00", "$15.00"},
        }

        for rowIdx, item := range items </span><span class="cov0" title="0">{
                iRow, _ := invoice.Row(rowIdx + 2)
                for colIdx, val := range item </span><span class="cov0" title="0">{
                        cell, _ := iRow.Cell(colIdx)
                        para, _ := cell.AddParagraph()
                        run, _ := para.AddRun()
                        run.SetText(val)
                }</span>
        }

        // Total
        <span class="cov0" title="0">iRow5, _ := invoice.Row(5)
        iCell50, _ := iRow5.Cell(0)
        iCell50.Merge(2, 1)
        iCell51, _ := iRow5.Cell(2)
        iCell51.SetShading(domain.Color{R: 240, G: 240, B: 240})
        iPara51, _ := iCell51.AddParagraph()
        iRun51, _ := iPara51.AddRun()
        iRun51.SetText("TOTAL:")
        iRun51.SetBold(true)
        iCell52, _ := iRow5.Cell(3)
        iCell52.SetShading(domain.Color{R: 240, G: 240, B: 240})
        iPara52, _ := iCell52.AddParagraph()
        iRun52, _ := iPara52.AddRun()
        iRun52.SetText("$60.00")
        iRun52.SetBold(true)

        // Save document
        outputPath := "09_advanced_tables_output.docx"
        if err := doc.SaveAs(outputPath); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Document created successfully: %s\n", outputPath)
        fmt.Println("\nFeatures demonstrated:")
        fmt.Println("  - Horizontal cell merging (colspan)")
        fmt.Println("  - Vertical cell merging (rowspan)")
        fmt.Println("  - Combined 2D merging")
        fmt.Println("  - Calendar layout")
        fmt.Println("  - Nested tables")
        fmt.Println("  - Invoice-style layout")
        fmt.Println("  - Table styles")
        fmt.Println("  - Cell shading and formatting")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "fmt"
        "log"

        docx "github.com/mmonterroca/docxgo"
        "github.com/mmonterroca/docxgo/domain"
)

func main() <span class="cov0" title="0">{
        doc := docx.NewDocument()

        // Configure the default section (executive summary)
        defaultSection, err := doc.DefaultSection()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to obtain default section: %v", err)
        }</span>
        <span class="cov0" title="0">_ = defaultSection.SetPageSize(domain.PageSizeLetter)
        _ = defaultSection.SetMargins(domain.Margins{
                Top:    1080,
                Right:  1080,
                Bottom: 1080,
                Left:   1440,
                Header: 720,
                Footer: 720,
        })

        // Header for first section
        header, err := defaultSection.Header(domain.HeaderDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create header: %v", err)
        }</span>
        <span class="cov0" title="0">headerPara, err := header.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add header paragraph: %v", err)
        }</span>
        <span class="cov0" title="0">headerPara.SetAlignment(domain.AlignmentRight)
        headerRun, err := headerPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add header run: %v", err)
        }</span>
        <span class="cov0" title="0">headerRun.AddText("Quarterly Report")
        headerRun.SetBold(true)

        // Footer with dynamic page numbers
        footer, err := defaultSection.Footer(domain.FooterDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create footer: %v", err)
        }</span>
        <span class="cov0" title="0">footerPara, err := footer.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add footer paragraph: %v", err)
        }</span>
        <span class="cov0" title="0">footerPara.SetAlignment(domain.AlignmentCenter)

        footerRun, err := footerPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add footer run: %v", err)
        }</span>
        <span class="cov0" title="0">footerRun.AddText("Page ")

        pageFieldRun, err := footerPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add footer field run: %v", err)
        }</span>
        <span class="cov0" title="0">pageFieldRun.AddField(docx.NewPageNumberField())

        footerRun2, err := footerPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add footer text run: %v", err)
        }</span>
        <span class="cov0" title="0">footerRun2.AddText(" of ")

        totalFieldRun, err := footerPara.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add footer total run: %v", err)
        }</span>
        <span class="cov0" title="0">totalFieldRun.AddField(docx.NewPageCountField())

        // Executive summary content
        title, _ := doc.AddParagraph()
        title.SetStyle(domain.StyleIDTitle)
        titleRun, _ := title.AddRun()
        titleRun.AddText("Q3 Business Review")

        intro, _ := doc.AddParagraph()
        intro.SetStyle(domain.StyleIDNormal)
        introRun, _ := intro.AddRun()
        introRun.AddText("This report highlights performance across business units and showcases the new multi-section support in go-docx v2.")

        summaryHeading, _ := doc.AddParagraph()
        summaryHeading.SetStyle(domain.StyleIDHeading1)
        summaryHeadingRun, _ := summaryHeading.AddRun()
        summaryHeadingRun.AddText("1. Executive Summary")

        bulletPoints := []string{
                "Revenue up 12% quarter-over-quarter",
                "New customer acquisitions increased by 18%",
                "Operational costs reduced by 6% through automation",
        }
        for _, text := range bulletPoints </span><span class="cov0" title="0">{
                item, _ := doc.AddParagraph()
                item.SetStyle(domain.StyleIDListParagraph)
                run, _ := item.AddRun()
                run.AddText(fmt.Sprintf("• %s", text))
        }</span>

        <span class="cov0" title="0">doc.AddParagraph() // spacer

        // Create a new landscape section for wide content
        landscapeSection, err := doc.AddSectionWithBreak(domain.SectionBreakTypeNextPage)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add landscape section: %v", err)
        }</span>
        <span class="cov0" title="0">_ = landscapeSection.SetOrientation(domain.OrientationLandscape)
        _ = landscapeSection.SetPageSize(domain.PageSizeLetter)
        _ = landscapeSection.SetColumns(2)
        _ = landscapeSection.SetMargins(domain.Margins{
                Top:    720,
                Right:  720,
                Bottom: 720,
                Left:   720,
                Header: 540,
                Footer: 540,
        })

        landscapeHeader, err := landscapeSection.Header(domain.HeaderDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add landscape header: %v", err)
        }</span>
        <span class="cov0" title="0">landscapeHeaderPara, _ := landscapeHeader.AddParagraph()
        landscapeHeaderPara.SetAlignment(domain.AlignmentCenter)
        landscapeHeaderRun, _ := landscapeHeaderPara.AddRun()
        landscapeHeaderRun.AddText("Operational Dashboards")
        landscapeHeaderRun.SetBold(true)

        landscapeHeading, _ := doc.AddParagraph()
        landscapeHeading.SetStyle(domain.StyleIDHeading1)
        landscapeHeadingRun, _ := landscapeHeading.AddRun()
        landscapeHeadingRun.AddText("2. Metrics Overview (Landscape)")

        metrics := []string{
                "Sales pipeline coverage: 3.5x",
                "Average deal cycle: 42 days",
                "Customer satisfaction (NPS): 67",
                "Support ticket resolution SLA: 94%",
                "Cloud infrastructure cost savings: 9%",
                "Website conversion rate: 3.1%",
                "Outbound response time: 3.4 hours",
                "Renewal retention: 91%",
                "Engineering release cadence: bi-weekly",
                "Escalation backlog: 6 open",
                "Regional quota attainment: 108%",
                "Marketing influenced pipeline: 54%",
        }

        for _, metric := range metrics </span><span class="cov0" title="0">{
                para, _ := doc.AddParagraph()
                para.SetStyle(domain.StyleIDListParagraph)
                run, _ := para.AddRun()
                run.AddText(fmt.Sprintf("• %s", metric))
        }</span>

        <span class="cov0" title="0">landscapeFooter, err := landscapeSection.Footer(domain.FooterDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add landscape footer: %v", err)
        }</span>
        <span class="cov0" title="0">landscapeFooterPara, _ := landscapeFooter.AddParagraph()
        landscapeFooterPara.SetAlignment(domain.AlignmentCenter)
        landscapeFooterRun, _ := landscapeFooterPara.AddRun()
        landscapeFooterRun.AddText("Landscape metrics • Page ")
        landscapeFooterField, _ := landscapeFooterPara.AddRun()
        landscapeFooterField.AddField(docx.NewPageNumberField())

        doc.AddParagraph() // spacer

        // Final section returning to portrait for closing notes
        closingSection, err := doc.AddSectionWithBreak(domain.SectionBreakTypeContinuous)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add closing section: %v", err)
        }</span>
        <span class="cov0" title="0">_ = closingSection.SetOrientation(domain.OrientationPortrait)
        _ = closingSection.SetColumns(1)
        _ = closingSection.SetMargins(domain.Margins{
                Top:    1440,
                Right:  1440,
                Bottom: 1440,
                Left:   1080,
                Header: 540,
                Footer: 720,
        })

        closingFooter, err := closingSection.Footer(domain.FooterDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add closing footer: %v", err)
        }</span>
        <span class="cov0" title="0">closingFooterPara, _ := closingFooter.AddParagraph()
        closingFooterPara.SetAlignment(domain.AlignmentRight)
        closingFooterRun, _ := closingFooterPara.AddRun()
        closingFooterRun.AddText("Next Steps • Page ")
        closingFooterField, _ := closingFooterPara.AddRun()
        closingFooterField.AddField(docx.NewPageNumberField())

        closingHeader, err := closingSection.Header(domain.HeaderDefault)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to add closing header: %v", err)
        }</span>
        <span class="cov0" title="0">closingHeaderPara, _ := closingHeader.AddParagraph()
        closingHeaderRun, _ := closingHeaderPara.AddRun()
        closingHeaderRun.AddText("Action Items")
        closingHeaderRun.SetBold(true)

        closingHeading, _ := doc.AddParagraph()
        closingHeading.SetStyle(domain.StyleIDHeading1)
        closingHeadingRun, _ := closingHeading.AddRun()
        closingHeadingRun.AddText("3. Next Steps")

        actions := []string{
                "Finalize FY roadmap with updated revenue targets",
                "Expand automation program to customer success workflows",
                "Pilot advanced analytics dashboard rollout",
        }
        for _, action := range actions </span><span class="cov0" title="0">{
                item, _ := doc.AddParagraph()
                item.SetStyle(domain.StyleIDListParagraph)
                run, _ := item.AddRun()
                run.AddText(fmt.Sprintf("• %s", action))
        }</span>

        <span class="cov0" title="0">conclusion, _ := doc.AddParagraph()
        conclusion.SetStyle(domain.StyleIDNormal)
        conclusionRun, _ := conclusion.AddRun()
        conclusionRun.AddText("The new multi-section capabilities allow individual sections to own their headers, footers, margins, and layouts, enabling rich document scenarios without leaving go-docx.")

        if err := doc.SaveAs("11_multi_section_demo.docx"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to save document: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Document created successfully: 11_multi_section_demo.docx")
        fmt.Println("\nKey highlights:")
        fmt.Println("- Portrait default section with executive summary and dynamic footer")
        fmt.Println("- Next-page break into landscape section with two-column layout")
        fmt.Println("- Continuous break back to portrait for closing action items")
        fmt.Println("- Per-section headers to showcase unique content per layout")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Package core provides concrete implementations of domain interfaces for go-docx v2.
//
// This package contains the core document model implementations including:
// - Document: The main document structure
// - Paragraph: Paragraph implementation with formatting
// - Run: Text run implementation with character formatting
// - Table: Table implementation with cells and rows
// - Section: Section implementation with page settings
// - Image: Image embedding and positioning
// - Field: Field implementation (TOC, page numbers, etc.)
//
// These implementations handle the business logic and coordinate with
// internal managers (ID generation, relationships, media, styles) and
// serialization to XML structures.
package core

import (
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/internal/serializer"
        "github.com/mmonterroca/docxgo/internal/writer"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// document implements the domain.Document interface.
type document struct {
        paragraphs    []domain.Paragraph
        tables        []domain.Table
        sections      []domain.Section
        blocks        []domain.Block
        metadata      *domain.Metadata
        idGen         *manager.IDGenerator
        relManager    *manager.RelationshipManager
        mediaManager  *manager.MediaManager
        styleManager  domain.StyleManager
        headerCount   int
        footerCount   int
        activeSection *docxSection
}

// NewDocument creates a new Document.
func NewDocument() domain.Document <span class="cov8" title="1">{
        idGen := manager.NewIDGenerator()
        relManager := manager.NewRelationshipManager(idGen)
        doc := &amp;document{
                paragraphs:   make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                tables:       make([]domain.Table, 0, constants.DefaultTableCapacity),
                sections:     make([]domain.Section, 0, 1),
                blocks:       make([]domain.Block, 0, constants.DefaultParagraphCapacity),
                metadata:     &amp;domain.Metadata{},
                idGen:        idGen,
                relManager:   relManager,
                mediaManager: manager.NewMediaManager(idGen),
                styleManager: manager.NewStyleManager(),
        }

        // Ensure core document relationships exist (styles, fonts, theme)
        doc.ensureDefaultRelationships()

        return doc
}</span>

// ensureActiveSection guarantees the document has a current section and returns it.
func (d *document) ensureActiveSection() (*docxSection, error) <span class="cov8" title="1">{
        if len(d.sections) == 0 </span><span class="cov8" title="1">{
                section := NewSection(d.relManager, d.idGen, d.mediaManager)
                coreSection, ok := section.(*docxSection)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.InvalidState("Document.ensureActiveSection", "unexpected section implementation type")
                }</span>
                <span class="cov8" title="1">d.sections = append(d.sections, section)
                d.activeSection = coreSection</span>
        }

        <span class="cov8" title="1">if d.activeSection == nil </span><span class="cov0" title="0">{
                last := d.sections[len(d.sections)-1]
                coreSection, ok := last.(*docxSection)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.InvalidState("Document.ensureActiveSection", "unexpected section implementation type")
                }</span>
                <span class="cov0" title="0">d.activeSection = coreSection</span>
        }

        <span class="cov8" title="1">return d.activeSection, nil</span>
}

// AddParagraph adds a new paragraph to the document.
func (d *document) AddParagraph() (domain.Paragraph, error) <span class="cov8" title="1">{
        if _, err := d.ensureActiveSection(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">id := d.idGen.NextParagraphID()
        para := NewParagraph(id, d.idGen, d.relManager, d.mediaManager)
        d.paragraphs = append(d.paragraphs, para)
        d.blocks = append(d.blocks, domain.Block{Paragraph: para})
        return para, nil</span>
}

// AddTable adds a new table with the specified dimensions.
func (d *document) AddTable(rows, cols int) (domain.Table, error) <span class="cov8" title="1">{
        if _, err := d.ensureActiveSection(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if rows &lt; constants.MinTableRows || rows &gt; constants.MaxTableRows </span><span class="cov8" title="1">{
                return nil, errors.InvalidArgument("Document.AddTable", "rows", rows,
                        "rows must be between 1 and 1000")
        }</span>
        <span class="cov8" title="1">if cols &lt; constants.MinTableCols || cols &gt; constants.MaxTableCols </span><span class="cov8" title="1">{
                return nil, errors.InvalidArgument("Document.AddTable", "cols", cols,
                        "columns must be between 1 and 63")
        }</span>

        <span class="cov8" title="1">id := d.idGen.NextTableID()
        table := NewTable(id, rows, cols, d.idGen, d.relManager, d.mediaManager)
        d.tables = append(d.tables, table)
        d.blocks = append(d.blocks, domain.Block{Table: table})
        return table, nil</span>
}

// AddSection adds a new section to the document using a next-page break.
func (d *document) AddSection() (domain.Section, error) <span class="cov0" title="0">{
        return d.AddSectionWithBreak(domain.SectionBreakTypeNextPage)
}</span>

// AddSectionWithBreak adds a new section specifying the section break behavior.
func (d *document) AddSectionWithBreak(breakType domain.SectionBreakType) (domain.Section, error) <span class="cov8" title="1">{
        if breakType &lt; domain.SectionBreakTypeNextPage || breakType &gt; domain.SectionBreakTypeOddPage </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Document.AddSectionWithBreak", "breakType", breakType,
                        "section break type must be between NextPage and OddPage")
        }</span>

        <span class="cov8" title="1">currentSection, err := d.ensureActiveSection()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">d.blocks = append(d.blocks, domain.Block{
                SectionBreak: &amp;domain.SectionBreak{
                        Section: currentSection,
                        Type:    breakType,
                },
        })

        newSection := NewSection(d.relManager, d.idGen, d.mediaManager)
        coreSection, ok := newSection.(*docxSection)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.InvalidState("Document.AddSectionWithBreak", "unexpected section implementation type")
        }</span>

        <span class="cov8" title="1">d.sections = append(d.sections, newSection)
        d.activeSection = coreSection

        return newSection, nil</span>
}

// AddPageBreak adds a page break to the document.
func (d *document) AddPageBreak() error <span class="cov0" title="0">{
        // Create a new paragraph
        para, err := d.AddParagraph()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add a run with a page break
        <span class="cov0" title="0">run, err := para.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return run.AddBreak(domain.BreakTypePage)</span>
}

// DefaultSection returns the default (first) section of the document.
func (d *document) DefaultSection() (domain.Section, error) <span class="cov8" title="1">{
        _, err := d.ensureActiveSection()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // ensureActiveSection always keeps sections slice populated.
        <span class="cov8" title="1">return d.sections[0], nil</span>
}

// Paragraphs returns all paragraphs in the document.
func (d *document) Paragraphs() []domain.Paragraph <span class="cov8" title="1">{
        // Return a copy to prevent external modification
        paras := make([]domain.Paragraph, len(d.paragraphs))
        copy(paras, d.paragraphs)
        return paras
}</span>

// Tables returns all tables in the document.
func (d *document) Tables() []domain.Table <span class="cov0" title="0">{
        tables := make([]domain.Table, len(d.tables))
        copy(tables, d.tables)
        return tables
}</span>

// Sections returns all sections in the document.
func (d *document) Sections() []domain.Section <span class="cov8" title="1">{
        sections := make([]domain.Section, len(d.sections))
        copy(sections, d.sections)
        return sections
}</span>

// Blocks returns all top-level document content in insertion order.
func (d *document) Blocks() []domain.Block <span class="cov8" title="1">{
        blocks := make([]domain.Block, len(d.blocks))
        copy(blocks, d.blocks)
        return blocks
}</span>

// generateHeadingBookmarks generates bookmarks for all headings in the document.
// This is required for Table of Contents (TOC) fields to work properly.
// Bookmarks are named _Toc{sequential_number} and only applied to paragraphs with Heading styles.
func (d *document) generateHeadingBookmarks() <span class="cov8" title="1">{
        bookmarkCounter := 0

        for _, para := range d.paragraphs </span><span class="cov8" title="1">{
                // Type assert to access internal paragraph methods
                if p, ok := para.(*paragraph); ok </span><span class="cov8" title="1">{
                        styleName := p.StyleName()

                        // Check if this paragraph has a Heading style
                        if strings.HasPrefix(styleName, "Heading") </span><span class="cov0" title="0">{
                                bookmarkID := fmt.Sprintf("%d", bookmarkCounter)
                                bookmarkName := fmt.Sprintf("_Toc%d", bookmarkCounter)
                                p.SetBookmark(bookmarkID, bookmarkName)
                                bookmarkCounter++
                        }</span>
                }
        }
}

// prepareHeaderFooterRelationships ensures that every header/footer defined in the
// document has an associated relationship and target part name within the DOCX
// package. This must run before serialization so both section references and the
// document relationships list are consistent.
func (d *document) prepareHeaderFooterRelationships() <span class="cov8" title="1">{
        for _, sec := range d.sections </span><span class="cov8" title="1">{
                coreSection, ok := sec.(*docxSection)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">coreSection.mu.Lock()

                for _, header := range coreSection.headers </span><span class="cov8" title="1">{
                        if header == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if header.TargetPath() == "" </span><span class="cov8" title="1">{
                                d.headerCount++
                                target := fmt.Sprintf("header%d.xml", d.headerCount)
                                header.setRelationship(header.RelationshipID(), target)
                        }</span>

                        <span class="cov8" title="1">if header.RelationshipID() == "" </span><span class="cov8" title="1">{
                                if relID, err := d.relManager.AddHeader(header.TargetPath()); err == nil </span><span class="cov8" title="1">{
                                        header.setRelationship(relID, header.TargetPath())
                                }</span>
                        }
                }

                <span class="cov8" title="1">for _, footer := range coreSection.footers </span><span class="cov8" title="1">{
                        if footer == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if footer.TargetPath() == "" </span><span class="cov8" title="1">{
                                d.footerCount++
                                target := fmt.Sprintf("footer%d.xml", d.footerCount)
                                footer.setRelationship(footer.RelationshipID(), target)
                        }</span>

                        <span class="cov8" title="1">if footer.RelationshipID() == "" </span><span class="cov8" title="1">{
                                if relID, err := d.relManager.AddFooter(footer.TargetPath()); err == nil </span><span class="cov8" title="1">{
                                        footer.setRelationship(relID, footer.TargetPath())
                                }</span>
                        }
                }

                <span class="cov8" title="1">coreSection.mu.Unlock()</span>
        }
}

// ensureDefaultRelationships guarantees that the DOCX package contains the
// required relationships for styles, fonts, and theme assets. Without these
// entries Word falls back to implicit defaults and style assignments appear as
// "Normal", which breaks features such as the Table of Contents.
func (d *document) ensureDefaultRelationships() <span class="cov8" title="1">{
        if d == nil || d.relManager == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Track existing relationship targets to avoid duplicates when called
        // multiple times (e.g. SaveAs after WriteTo).
        <span class="cov8" title="1">existing := make(map[string]bool)
        for _, rel := range d.relManager.All() </span><span class="cov8" title="1">{
                existing[rel.Target] = true
        }</span>

        <span class="cov8" title="1">baseRels := []struct {
                relType string
                target  string
        }{
                {constants.RelTypeStyles, "styles.xml"},
                {constants.RelTypeFontTable, "fontTable.xml"},
                {constants.RelTypeTheme, "theme/theme1.xml"},
                {constants.RelTypeSettings, "settings.xml"},
                {constants.RelTypeWebSettings, "webSettings.xml"},
        }

        for _, rel := range baseRels </span><span class="cov8" title="1">{
                if existing[rel.target] </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Ignore the error because the inputs are fixed and validated. In the
                // unlikely event of a failure we still prefer to continue writing the
                // document instead of aborting.
                <span class="cov8" title="1">_, _ = d.relManager.Add(rel.relType, rel.target, "Internal")</span>
        }
}

// WriteTo writes the document to the provided writer in .docx format.
func (d *document) WriteTo(w io.Writer) (int64, error) <span class="cov8" title="1">{
        if len(d.sections) == 0 </span><span class="cov0" title="0">{
                if _, err := d.DefaultSection(); err != nil </span><span class="cov0" title="0">{
                        return 0, errors.Wrap(err, "Document.WriteTo")
                }</span>
        }

        // Generate bookmarks for headings (needed for TOC)
        <span class="cov8" title="1">d.generateHeadingBookmarks()

        // Ensure headers and footers have relationships/targets before serialization
        d.prepareHeaderFooterRelationships()

        // Ensure required base relationships are present before serialization
        d.ensureDefaultRelationships()

        // Serialize domain objects to XML structures
        ser := serializer.NewDocumentSerializer()
        xmlDoc := ser.SerializeDocument(d)
        headers, footers := ser.SerializeSectionParts(d)

        // Create ZIP writer
        zipWriter := writer.NewZipWriter(w)
        defer func() </span><span class="cov8" title="1">{
                if err := zipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't override return value as document may have been partially written
                        _ = err
                }</span>
        }()

        // Build relationships from relationship manager
        <span class="cov8" title="1">rels := d.relManager.ToXML()

        // Serialize metadata
        coreProps := ser.SerializeCoreProperties(d.metadata)
        appProps := ser.SerializeAppProperties(d)

        // Serialize styles
        styles := ser.SerializeStyles(d.styleManager)

        mediaFiles := d.mediaManager.All()

        // Write document structure
        if err := zipWriter.WriteDocument(xmlDoc, rels, coreProps, appProps, styles, mediaFiles, headers, footers); err != nil </span><span class="cov0" title="0">{
                return 0, errors.WrapWithCode(err, errors.ErrCodeIO, "Document.WriteTo")
        }</span>

        // Get byte count from writer if available
        // For now, return 0 as ZipWriter doesn't track total bytes
        // This could be enhanced by wrapping the writer with a counting writer
        <span class="cov8" title="1">return 0, nil</span>
}

// SaveAs saves the document to the specified file path.
func (d *document) SaveAs(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Document.SaveAs", "path", path, "path cannot be empty")
        }</span>

        // Create file
        <span class="cov8" title="1">file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.WrapWithCode(err, errors.ErrCodeIO, "Document.SaveAs")
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := file.Close(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = errors.WrapWithCode(closeErr, errors.ErrCodeIO, "Document.SaveAs")
                }</span>
        }()

        // Write document to file
        <span class="cov8" title="1">_, err = d.WriteTo(file)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Document.SaveAs")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the document structure is valid.
func (d *document) Validate() error <span class="cov0" title="0">{
        // Basic validation
        if len(d.paragraphs) == 0 &amp;&amp; len(d.tables) == 0 </span><span class="cov0" title="0">{
                return errors.InvalidState("Document.Validate", "document is empty")
        }</span>

        // Validate each paragraph
        <span class="cov0" title="0">for i, para := range d.paragraphs </span><span class="cov0" title="0">{
                if para == nil </span><span class="cov0" title="0">{
                        return errors.InvalidState("Document.Validate",
                                "paragraph at index "+string(rune(i))+" is nil")
                }</span>
        }

        // Validate each table
        <span class="cov0" title="0">for i, table := range d.tables </span><span class="cov0" title="0">{
                if table == nil </span><span class="cov0" title="0">{
                        return errors.InvalidState("Document.Validate",
                                "table at index "+string(rune(i))+" is nil")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Metadata returns the document's metadata.
func (d *document) Metadata() *domain.Metadata <span class="cov0" title="0">{
        return d.metadata
}</span>

// SetMetadata updates the document's metadata.
func (d *document) SetMetadata(meta *domain.Metadata) error <span class="cov0" title="0">{
        if meta == nil </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Document.SetMetadata", "meta", meta, "metadata cannot be nil")
        }</span>
        <span class="cov0" title="0">d.metadata = meta
        return nil</span>
}

// StyleManager returns the style manager for this document.
func (d *document) StyleManager() domain.StyleManager <span class="cov0" title="0">{
        return d.styleManager
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package core

import (
        "fmt"
        "strings"
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// docxField implements the Field interface.
type docxField struct {
        mu         sync.RWMutex
        fieldType  domain.FieldType
        code       string
        result     string
        isDirty    bool // Indicates if field needs recalculation
        properties map[string]string
}

// NewField creates a new field with the specified type.
func NewField(fieldType domain.FieldType) domain.Field <span class="cov8" title="1">{
        field := &amp;docxField{
                fieldType:  fieldType,
                isDirty:    true,
                properties: make(map[string]string),
        }

        // Set default code based on type
        field.code = field.getDefaultCode()

        return field
}</span>

// NewPageNumberField creates a field for page numbering.
func NewPageNumberField() domain.Field <span class="cov8" title="1">{
        field := NewField(domain.FieldTypePageNumber)
        return field
}</span>

// NewPageCountField creates a field for total page count.
func NewPageCountField() domain.Field <span class="cov8" title="1">{
        field := NewField(domain.FieldTypePageCount)
        return field
}</span>

// NewTOCField creates a Table of Contents field with options.
func NewTOCField(switches map[string]string) domain.Field <span class="cov8" title="1">{
        field := NewField(domain.FieldTypeTOC).(*docxField)

        // Apply switches
        for key, value := range switches </span><span class="cov8" title="1">{
                field.properties[key] = value
        }</span>

        // Rebuild code with switches
        <span class="cov8" title="1">field.code = field.buildTOCCode()

        return field</span>
}

// NewHyperlinkField creates a hyperlink field.
func NewHyperlinkField(url, displayText string) domain.Field <span class="cov8" title="1">{
        field := NewField(domain.FieldTypeHyperlink).(*docxField)
        field.properties["url"] = url
        field.properties["display"] = displayText
        field.code = fmt.Sprintf(`HYPERLINK "%s"`, url)
        field.result = displayText
        field.isDirty = false
        return field
}</span>

// NewStyleRefField creates a STYLEREF field.
func NewStyleRefField(styleName string) domain.Field <span class="cov8" title="1">{
        field := NewField(domain.FieldTypeStyleRef).(*docxField)
        field.properties["style"] = styleName
        field.code = fmt.Sprintf(`STYLEREF "%s"`, styleName)
        return field
}</span>

// Type returns the field type.
func (f *docxField) Type() domain.FieldType <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.fieldType
}</span>

// Code returns the field code.
func (f *docxField) Code() string <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.code
}</span>

// SetCode sets the field code.
func (f *docxField) SetCode(code string) error <span class="cov8" title="1">{
        if strings.TrimSpace(code) == "" </span><span class="cov8" title="1">{
                return errors.NewValidationError(
                        "SetCode",
                        "code",
                        code,
                        "field code cannot be empty",
                )
        }</span>

        <span class="cov8" title="1">f.mu.Lock()
        defer f.mu.Unlock()

        f.code = code
        f.isDirty = true

        return nil</span>
}

// Result returns the field result (calculated value).
func (f *docxField) Result() string <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.result
}</span>

// Update recalculates the field result.
func (f *docxField) Update() error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        if !f.isDirty </span><span class="cov8" title="1">{
                return nil // No update needed
        }</span>

        // Update based on field type
        <span class="cov8" title="1">switch f.fieldType </span>{
        case domain.FieldTypePageNumber:<span class="cov8" title="1">
                f.result = "1"</span> // Placeholder - actual value determined by Word
        case domain.FieldTypePageCount:<span class="cov8" title="1">
                f.result = "1"</span> // Placeholder - actual value determined by Word
        case domain.FieldTypeNumPages:<span class="cov0" title="0">
                f.result = "1"</span> // Placeholder - actual value determined by Word
        case domain.FieldTypeTOC:<span class="cov8" title="1">
                f.result = "Table of Contents"</span> // Placeholder
        case domain.FieldTypeStyleRef:<span class="cov0" title="0">
                f.result = ""</span> // Placeholder - populated by Word
        case domain.FieldTypeHyperlink:<span class="cov0" title="0">
                // Result is the display text
                if display, ok := f.properties["display"]; ok </span><span class="cov0" title="0">{
                        f.result = display
                }</span>
        case domain.FieldTypeDate:<span class="cov8" title="1">
                f.result = "1/1/2025"</span> // Placeholder
        case domain.FieldTypeTime:<span class="cov0" title="0">
                f.result = "12:00:00"</span> // Placeholder
        case domain.FieldTypeSeq:<span class="cov8" title="1">
                f.result = "1"</span> // Placeholder
        case domain.FieldTypeRef:<span class="cov0" title="0">
                f.result = ""</span> // Placeholder - populated by Word
        case domain.FieldTypeCustom:<span class="cov8" title="1">
                f.result = ""</span> // Custom fields have user-defined results
        default:<span class="cov0" title="0">
                f.result = ""</span> // Unknown field type
        }

        <span class="cov8" title="1">f.isDirty = false
        return nil</span>
}

// SetResult allows callers to inject a pre-rendered field result.
// This is primarily useful for examples so the initial document shows
// friendly placeholder text before Word updates the field values.
func (f *docxField) SetResult(result string) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()

        f.result = result
        f.isDirty = false
}</span>

// getDefaultCode returns the default field code for the field type.
func (f *docxField) getDefaultCode() string <span class="cov8" title="1">{
        switch f.fieldType </span>{
        case domain.FieldTypePageNumber:<span class="cov8" title="1">
                return constants.FieldCodePageNumber</span>
        case domain.FieldTypePageCount:<span class="cov8" title="1">
                return constants.FieldCodeNumPages</span>
        case domain.FieldTypeNumPages:<span class="cov0" title="0">
                return constants.FieldCodeNumPages</span>
        case domain.FieldTypeTOC:<span class="cov8" title="1">
                return constants.FieldCodeTOC + ` \\o "1-3" \\h \\z \\u`</span>
        case domain.FieldTypeDate:<span class="cov8" title="1">
                return constants.FieldCodeDate</span>
        case domain.FieldTypeTime:<span class="cov0" title="0">
                return constants.FieldCodeTime</span>
        case domain.FieldTypeStyleRef:<span class="cov8" title="1">
                return constants.FieldCodeStyleRef + ` "Heading 1"`</span>
        case domain.FieldTypeSeq:<span class="cov8" title="1">
                return constants.FieldCodeSeq + ` Figure`</span>
        case domain.FieldTypeRef:<span class="cov0" title="0">
                return constants.FieldCodeRef</span>
        case domain.FieldTypeHyperlink:<span class="cov8" title="1">
                return "HYPERLINK"</span> // Hyperlink fields use HYPERLINK code
        case domain.FieldTypeCustom:<span class="cov8" title="1">
                return ""</span> // Custom fields require user-defined codes
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// buildTOCCode builds a TOC field code with switches.
func (f *docxField) buildTOCCode() string <span class="cov8" title="1">{
        code := constants.FieldCodeTOC

        // Heading levels (default 1-3)
        if levels, ok := f.properties["levels"]; ok </span><span class="cov8" title="1">{
                code += fmt.Sprintf(` \\o "%s"`, levels)
        }</span> else<span class="cov8" title="1"> {
                code += ` \\o "1-3"`
        }</span>

        // Hyperlinks (always included by default)
        <span class="cov8" title="1">code += ` \\h`

        // Hide page numbers (only if explicitly set to "true")
        if hidePN, ok := f.properties["hidePageNumbers"]; ok &amp;&amp; hidePN == "true" </span><span class="cov8" title="1">{
                code += ` \\n`
        }</span>

        // Hide tab leader (only if explicitly set to "true")
        <span class="cov8" title="1">if hideTab, ok := f.properties["hideTabLeader"]; ok &amp;&amp; hideTab == "true" </span><span class="cov0" title="0">{
                code += ` \\p`
        }</span>

        // Preserve tab entries
        <span class="cov8" title="1">code += ` \\z`

        // Use styles
        code += ` \\u`

        return code</span>
}

// SetProperty sets a field property (for advanced customization).
func (f *docxField) SetProperty(key, value string) <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.properties[key] = value
        f.isDirty = true
}</span>

// GetProperty gets a field property.
func (f *docxField) GetProperty(key string) (string, bool) <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        value, ok := f.properties[key]
        return value, ok
}</span>

// IsDirty returns whether the field needs updating.
func (f *docxField) IsDirty() bool <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.isDirty
}</span>

// MarkDirty marks the field as needing an update.
func (f *docxField) MarkDirty() <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.isDirty = true
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package core

import (
        "fmt"
        "image"
        _ "image/gif"  // Register GIF format decoder
        _ "image/jpeg" // Register JPEG format decoder
        _ "image/png"  // Register PNG format decoder
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// docxImage implements the domain.Image interface.
type docxImage struct {
        id             string
        format         domain.ImageFormat
        size           domain.ImageSize
        originalSize   domain.ImageSize
        data           []byte
        relationshipID string
        target         string
        description    string
        position       domain.ImagePosition
}

// NewImage creates a new image from a file path.
func NewImage(id, path string) (domain.Image, error) <span class="cov8" title="1">{
        // Read image file
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WrapWithCode(err, errors.ErrCodeIO, "NewImage")
        }</span>

        // Detect format from extension
        <span class="cov8" title="1">format := detectImageFormat(path)
        if format == "" </span><span class="cov8" title="1">{
                return nil, errors.InvalidArgument("NewImage", "path", path, "unsupported image format")
        }</span>

        // Get image dimensions
        <span class="cov8" title="1">size, err := getImageDimensions(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "NewImage")
        }</span>

        // Generate target path
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(path))
        if ext == "" </span><span class="cov0" title="0">{
                ext = "." + string(format)
        }</span>
        <span class="cov8" title="1">target := fmt.Sprintf("media/image%s%s", id, ext)

        return &amp;docxImage{
                id:           id,
                format:       format,
                size:         size,
                originalSize: size,
                data:         data,
                target:       target,
                description:  "",
                position:     domain.DefaultImagePosition(),
        }, nil</span>
}

// NewImageWithSize creates a new image with custom dimensions.
func NewImageWithSize(id, path string, size domain.ImageSize) (domain.Image, error) <span class="cov8" title="1">{
        img, err := NewImage(id, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := img.SetSize(size); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return img, nil</span>
}

// NewImageWithPosition creates a new image with custom positioning.
func NewImageWithPosition(id, path string, size domain.ImageSize, pos domain.ImagePosition) (domain.Image, error) <span class="cov8" title="1">{
        img, err := NewImageWithSize(id, path, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">docxImg := img.(*docxImage)
        docxImg.position = pos

        return img, nil</span>
}

// ID returns the unique image ID.
func (img *docxImage) ID() string <span class="cov8" title="1">{
        return img.id
}</span>

// Format returns the image format.
func (img *docxImage) Format() domain.ImageFormat <span class="cov8" title="1">{
        return img.format
}</span>

// Size returns the image dimensions.
func (img *docxImage) Size() domain.ImageSize <span class="cov8" title="1">{
        return img.size
}</span>

// SetSize sets custom dimensions for the image.
func (img *docxImage) SetSize(size domain.ImageSize) error <span class="cov8" title="1">{
        // If width or height is 0, maintain aspect ratio
        if size.WidthPx == 0 &amp;&amp; size.HeightPx == 0 </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Image.SetSize", "size", size, "both width and height cannot be zero")
        }</span>

        <span class="cov8" title="1">if size.WidthPx == 0 </span><span class="cov0" title="0">{
                // Calculate width from height maintaining aspect ratio
                ratio := float64(img.originalSize.WidthPx) / float64(img.originalSize.HeightPx)
                size.WidthPx = int(float64(size.HeightPx) * ratio)
                size.WidthEMU = size.WidthPx * 9525
        }</span> else<span class="cov8" title="1"> if size.HeightPx == 0 </span><span class="cov0" title="0">{
                // Calculate height from width maintaining aspect ratio
                ratio := float64(img.originalSize.HeightPx) / float64(img.originalSize.WidthPx)
                size.HeightPx = int(float64(size.WidthPx) * ratio)
                size.HeightEMU = size.HeightPx * 9525
        }</span>

        <span class="cov8" title="1">img.size = size
        return nil</span>
}

// Data returns the raw image data.
func (img *docxImage) Data() []byte <span class="cov8" title="1">{
        // Return copy to prevent external modification
        data := make([]byte, len(img.data))
        copy(data, img.data)
        return data
}</span>

// RelationshipID returns the relationship ID for this image.
func (img *docxImage) RelationshipID() string <span class="cov8" title="1">{
        return img.relationshipID
}</span>

// SetRelationshipID sets the relationship ID (called by manager).
func (img *docxImage) SetRelationshipID(id string) <span class="cov0" title="0">{
        img.relationshipID = id
}</span>

// Target returns the target path in the .docx package.
func (img *docxImage) Target() string <span class="cov8" title="1">{
        return img.target
}</span>

// setTarget updates the internal target path for the image within the DOCX package.
func (img *docxImage) setTarget(target string) <span class="cov0" title="0">{
        img.target = target
}</span>

// Description returns the alt text description.
func (img *docxImage) Description() string <span class="cov8" title="1">{
        return img.description
}</span>

// SetDescription sets the alt text description.
func (img *docxImage) SetDescription(desc string) error <span class="cov8" title="1">{
        img.description = desc
        return nil
}</span>

// Position returns the image position settings.
func (img *docxImage) Position() domain.ImagePosition <span class="cov8" title="1">{
        return img.position
}</span>

// detectImageFormat detects the image format from file extension.
func detectImageFormat(path string) domain.ImageFormat <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(path))
        ext = strings.TrimPrefix(ext, ".")

        switch ext </span>{
        case "png":<span class="cov8" title="1">
                return domain.ImageFormatPNG</span>
        case "jpg", "jpeg":<span class="cov8" title="1">
                return domain.ImageFormatJPEG</span>
        case "gif":<span class="cov8" title="1">
                return domain.ImageFormatGIF</span>
        case "bmp":<span class="cov8" title="1">
                return domain.ImageFormatBMP</span>
        case "tif", "tiff":<span class="cov8" title="1">
                return domain.ImageFormatTIFF</span>
        case "svg":<span class="cov8" title="1">
                return domain.ImageFormatSVG</span>
        case "webp":<span class="cov8" title="1">
                return domain.ImageFormatWEBP</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// getImageDimensions reads image dimensions from image data.
func getImageDimensions(data []byte) (domain.ImageSize, error) <span class="cov8" title="1">{
        // Decode image to get dimensions
        img, format, err := image.DecodeConfig(strings.NewReader(string(data)))
        if err != nil </span><span class="cov0" title="0">{
                // If decode fails, try reading as binary
                reader := strings.NewReader(string(data))
                img, format, err = image.DecodeConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ImageSize{}, errors.Wrap(err, "getImageDimensions")
                }</span>
        }

        <span class="cov8" title="1">_ = format // format string is for logging if needed

        return domain.NewImageSize(img.Width, img.Height), nil</span>
}

// ReadImageFromReader creates an image from an io.Reader.
func ReadImageFromReader(id string, reader io.Reader, format domain.ImageFormat) (domain.Image, error) <span class="cov8" title="1">{
        // Read all data
        data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WrapWithCode(err, errors.ErrCodeIO, "ReadImageFromReader")
        }</span>

        // Get dimensions
        <span class="cov8" title="1">size, err := getImageDimensions(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "ReadImageFromReader")
        }</span>

        // Generate target
        <span class="cov8" title="1">target := fmt.Sprintf("media/image%s.%s", id, format)

        return &amp;docxImage{
                id:           id,
                format:       format,
                size:         size,
                originalSize: size,
                data:         data,
                target:       target,
                description:  "",
                position:     domain.DefaultImagePosition(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package core

import (
        "path/filepath"
        "strings"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// IDGenerator interface for testing purposes
type IDGenerator interface {
        NextParagraphID() string
        NextRunID() string
        NextImageID() string
        GenerateID(prefix string) string
}

// paragraph implements the domain.Paragraph interface.
type paragraph struct {
        id            string
        runs          []domain.Run
        fields        []domain.Field
        images        []domain.Image
        styleName     string
        alignment     domain.Alignment
        indent        domain.Indentation
        spacingBefore int
        spacingAfter  int
        lineSpacing   domain.LineSpacing
        idGen         IDGenerator
        relManager    *manager.RelationshipManager
        bookmarkID    string // ID for bookmark (if this paragraph needs one for TOC)
        bookmarkName  string // Name for bookmark (e.g., "_Toc123456")
        mediaManager  *manager.MediaManager
}

// NewParagraph creates a new Paragraph.
func NewParagraph(id string, idGen IDGenerator, relManager *manager.RelationshipManager, mediaManager *manager.MediaManager) domain.Paragraph <span class="cov8" title="1">{
        return &amp;paragraph{
                id:            id,
                runs:          make([]domain.Run, 0, constants.DefaultRunCapacity),
                fields:        make([]domain.Field, 0, 4),
                images:        make([]domain.Image, 0, 4),
                alignment:     domain.AlignmentLeft,
                indent:        domain.Indentation{},
                spacingBefore: constants.DefaultParagraphSpacing,
                spacingAfter:  constants.DefaultParagraphSpacing,
                lineSpacing:   domain.LineSpacing{Rule: domain.LineSpacingAuto, Value: constants.DefaultLineSpacing},
                idGen:         idGen,
                relManager:    relManager,
                mediaManager:  mediaManager,
        }
}</span>

// AddRun adds a new text run to the paragraph.
func (p *paragraph) AddRun() (domain.Run, error) <span class="cov8" title="1">{
        id := p.idGen.NextRunID()
        run := NewRun(id, p.relManager)
        p.runs = append(p.runs, run)
        return run, nil
}</span>

// AddField adds a field to the paragraph.
// Deprecated: Use AddRun() and run.AddField() instead for better control.
func (p *paragraph) AddField(_ domain.FieldType) (domain.Field, error) <span class="cov0" title="0">{
        return nil, errors.Unsupported("Paragraph.AddField", "use AddRun() and run.AddField() instead")
}</span>

// AddHyperlink adds a hyperlink to the paragraph.
func (p *paragraph) AddHyperlink(url, displayText string) (domain.Run, error) <span class="cov0" title="0">{
        if url == "" </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Paragraph.AddHyperlink", "url", url, "URL cannot be empty")
        }</span>

        // Add relationship for hyperlink
        <span class="cov0" title="0">_, err := p.relManager.AddHyperlink(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddHyperlink")
        }</span>

        // Create run with hyperlink text
        <span class="cov0" title="0">run, err := p.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddHyperlink")
        }</span>

        <span class="cov0" title="0">text := displayText
        if text == "" </span><span class="cov0" title="0">{
                text = url
        }</span>

        <span class="cov0" title="0">err = run.SetText(text)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddHyperlink")
        }</span>

        // Set hyperlink styling (blue, underlined)
        <span class="cov0" title="0">_ = run.SetColor(domain.ColorBlue)
        _ = run.SetUnderline(domain.UnderlineSingle)

        return run, nil</span>
}

// AddImage adds an image to the paragraph from a file path.
func (p *paragraph) AddImage(path string) (domain.Image, error) <span class="cov0" title="0">{
        id := p.idGen.NextImageID()
        img, err := NewImage(id, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImage")
        }</span>

        <span class="cov0" title="0">if err := p.attachImage(img, filepath.Base(path)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return img, nil</span>
}

// AddImageWithSize adds an image with custom dimensions.
func (p *paragraph) AddImageWithSize(path string, size domain.ImageSize) (domain.Image, error) <span class="cov0" title="0">{
        id := p.idGen.NextImageID()
        img, err := NewImageWithSize(id, path, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImageWithSize")
        }</span>

        <span class="cov0" title="0">if err := p.attachImage(img, filepath.Base(path)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return img, nil</span>
}

// AddImageWithPosition adds an image with custom positioning.
func (p *paragraph) AddImageWithPosition(path string, size domain.ImageSize, pos domain.ImagePosition) (domain.Image, error) <span class="cov0" title="0">{
        id := p.idGen.NextImageID()
        img, err := NewImageWithPosition(id, path, size, pos)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImageWithPosition")
        }</span>

        <span class="cov0" title="0">if err := p.attachImage(img, filepath.Base(path)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return img, nil</span>
}

// attachImage registers the image with the media and relationship managers and appends it as a drawing run.
func (p *paragraph) attachImage(img domain.Image, sourceName string) error <span class="cov0" title="0">{
        if p.mediaManager == nil </span><span class="cov0" title="0">{
                return errors.InvalidState("Paragraph.attachImage", "media manager not initialized")
        }</span>

        <span class="cov0" title="0">if sourceName == "" </span><span class="cov0" title="0">{
                sourceName = img.ID()
        }</span>

        <span class="cov0" title="0">_, mediaPath, err := p.mediaManager.Add(img.Data(), sourceName)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Paragraph.attachImage")
        }</span>

        <span class="cov0" title="0">relativePath := strings.TrimPrefix(mediaPath, "word/")
        if docxImg, ok := img.(*docxImage); ok </span><span class="cov0" title="0">{
                docxImg.setTarget(relativePath)
        }</span>

        <span class="cov0" title="0">relID, err := p.relManager.AddImage(relativePath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Paragraph.attachImage")
        }</span>

        <span class="cov0" title="0">if docxImg, ok := img.(*docxImage); ok </span><span class="cov0" title="0">{
                docxImg.SetRelationshipID(relID)
        }</span>

        <span class="cov0" title="0">run := NewRun(p.idGen.NextRunID(), p.relManager)
        if setter, ok := run.(interface{ setImage(domain.Image) }); ok </span><span class="cov0" title="0">{
                setter.setImage(img)
        }</span>

        <span class="cov0" title="0">p.runs = append(p.runs, run)
        p.images = append(p.images, img)
        return nil</span>
}

// Images returns all images in this paragraph.
func (p *paragraph) Images() []domain.Image <span class="cov0" title="0">{
        images := make([]domain.Image, len(p.images))
        copy(images, p.images)
        return images
}</span>

// Runs returns all runs in this paragraph.
func (p *paragraph) Runs() []domain.Run <span class="cov8" title="1">{
        // Return a copy to prevent external modification
        runs := make([]domain.Run, len(p.runs))
        copy(runs, p.runs)
        return runs
}</span>

// Fields returns all fields in this paragraph.
func (p *paragraph) Fields() []domain.Field <span class="cov0" title="0">{
        fields := make([]domain.Field, len(p.fields))
        copy(fields, p.fields)
        return fields
}</span>

// Text returns the plain text content of the paragraph.
func (p *paragraph) Text() string <span class="cov0" title="0">{
        var sb strings.Builder
        for _, run := range p.runs </span><span class="cov0" title="0">{
                sb.WriteString(run.Text())
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// Style returns the style applied to this paragraph.
// Note: Currently only returns the style name, not a full Style object.
// For now, use SetStyle() to apply styles and track the name yourself if needed.
func (p *paragraph) Style() domain.Style <span class="cov0" title="0">{
        // Style retrieval from the style manager is not yet implemented.
        // Return nil for now - users should track the applied style name themselves.
        return nil
}</span>

// SetStyle applies a named style to the paragraph.
func (p *paragraph) SetStyle(styleName string) error <span class="cov0" title="0">{
        if styleName == "" </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetStyle", "styleName", styleName, "style name cannot be empty")
        }</span>
        <span class="cov0" title="0">p.styleName = styleName
        return nil</span>
}

// StyleName returns the style name applied to this paragraph.
// This is an internal method used by the serializer.
func (p *paragraph) StyleName() string <span class="cov8" title="1">{
        return p.styleName
}</span>

// SetBookmark sets a bookmark for this paragraph (used for TOC).
// This is an internal method used when generating TOC.
func (p *paragraph) SetBookmark(id, name string) <span class="cov0" title="0">{
        p.bookmarkID = id
        p.bookmarkName = name
}</span>

// BookmarkID returns the bookmark ID for this paragraph.
// This is an internal method used by the serializer.
func (p *paragraph) BookmarkID() string <span class="cov8" title="1">{
        return p.bookmarkID
}</span>

// BookmarkName returns the bookmark name for this paragraph.
// This is an internal method used by the serializer.
func (p *paragraph) BookmarkName() string <span class="cov0" title="0">{
        return p.bookmarkName
}</span>

// Alignment returns the paragraph's horizontal alignment.
func (p *paragraph) Alignment() domain.Alignment <span class="cov8" title="1">{
        return p.alignment
}</span>

// SetAlignment sets the paragraph's horizontal alignment.
func (p *paragraph) SetAlignment(align domain.Alignment) error <span class="cov8" title="1">{
        if align &lt; domain.AlignmentLeft || align &gt; domain.AlignmentDistribute </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetAlignment", "align", align, "invalid alignment value")
        }</span>
        <span class="cov8" title="1">p.alignment = align
        return nil</span>
}

// Indent returns the paragraph's indentation settings.
func (p *paragraph) Indent() domain.Indentation <span class="cov8" title="1">{
        return p.indent
}</span>

// SetIndent sets the paragraph's indentation.
func (p *paragraph) SetIndent(indent domain.Indentation) error <span class="cov8" title="1">{
        // Validate indentation values
        if indent.Left &lt; constants.MinIndent || indent.Left &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.Left", indent.Left,
                        "left indent must be between -31680 and 31680 twips (-22 to 22 inches)")
        }</span>
        <span class="cov8" title="1">if indent.Right &lt; constants.MinIndent || indent.Right &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.Right", indent.Right,
                        "right indent must be between -31680 and 31680 twips (-22 to 22 inches)")
        }</span>
        <span class="cov8" title="1">if indent.FirstLine &lt; 0 || indent.FirstLine &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.FirstLine", indent.FirstLine,
                        "first line indent must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov8" title="1">if indent.Hanging &lt; 0 || indent.Hanging &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.Hanging", indent.Hanging,
                        "hanging indent must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov8" title="1">if indent.FirstLine &gt; 0 &amp;&amp; indent.Hanging &gt; 0 </span><span class="cov8" title="1">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent", indent,
                        "cannot have both first line indent and hanging indent")
        }</span>

        <span class="cov8" title="1">p.indent = indent
        return nil</span>
}

// SpacingBefore returns spacing before the paragraph (in twips).
func (p *paragraph) SpacingBefore() int <span class="cov8" title="1">{
        return p.spacingBefore
}</span>

// SetSpacingBefore sets spacing before the paragraph.
func (p *paragraph) SetSpacingBefore(twips int) error <span class="cov0" title="0">{
        if twips &lt; constants.MinSpacing || twips &gt; constants.MaxSpacing </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetSpacingBefore", "twips", twips,
                        "spacing must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov0" title="0">p.spacingBefore = twips
        return nil</span>
}

// SpacingAfter returns spacing after the paragraph (in twips).
func (p *paragraph) SpacingAfter() int <span class="cov8" title="1">{
        return p.spacingAfter
}</span>

// SetSpacingAfter sets spacing after the paragraph.
func (p *paragraph) SetSpacingAfter(twips int) error <span class="cov0" title="0">{
        if twips &lt; constants.MinSpacing || twips &gt; constants.MaxSpacing </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetSpacingAfter", "twips", twips,
                        "spacing must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov0" title="0">p.spacingAfter = twips
        return nil</span>
}

// LineSpacing returns the line spacing setting.
func (p *paragraph) LineSpacing() domain.LineSpacing <span class="cov8" title="1">{
        return p.lineSpacing
}</span>

// SetLineSpacing sets the line spacing.
func (p *paragraph) SetLineSpacing(spacing domain.LineSpacing) error <span class="cov0" title="0">{
        if spacing.Rule &lt; domain.LineSpacingAuto || spacing.Rule &gt; domain.LineSpacingAtLeast </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetLineSpacing", "spacing.Rule", spacing.Rule,
                        "invalid line spacing rule")
        }</span>
        <span class="cov0" title="0">if spacing.Value &lt; constants.MinLineSpacing || spacing.Value &gt; constants.MaxLineSpacing </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetLineSpacing", "spacing.Value", spacing.Value,
                        "line spacing value must be between 0 and 31680 twips")
        }</span>
        <span class="cov0" title="0">p.lineSpacing = spacing
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Package core provides core implementations of domain interfaces.
package core

import (
        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// run implements the domain.Run interface.
type run struct {
        id         string
        text       string
        image      domain.Image
        font       domain.Font
        color      domain.Color
        size       int // in half-points
        bold       bool
        italic     bool
        underline  domain.UnderlineStyle
        strike     bool
        highlight  domain.HighlightColor
        fields     []domain.Field     // Fields embedded in this run
        breaks     []domain.BreakType // Breaks in this run
        relManager *manager.RelationshipManager
}

// NewRun creates a new Run.
func NewRun(id string, relManager *manager.RelationshipManager) domain.Run <span class="cov8" title="1">{
        return &amp;run{
                id:         id,
                font:       domain.Font{Name: constants.DefaultFontName},
                color:      domain.ColorBlack,
                size:       constants.DefaultFontSize,
                underline:  domain.UnderlineNone,
                highlight:  domain.HighlightNone,
                relManager: relManager,
        }
}</span>

// Text returns the text content of this run.
func (r *run) Text() string <span class="cov8" title="1">{
        return r.text
}</span>

// SetText sets the text content of this run.
func (r *run) SetText(text string) error <span class="cov8" title="1">{
        r.text = text
        return nil
}</span>

// Image returns the image associated with this run, if any.
func (r *run) Image() domain.Image <span class="cov8" title="1">{
        return r.image
}</span>

// setImage attaches an image to the run for serialization.
func (r *run) setImage(img domain.Image) <span class="cov0" title="0">{
        r.image = img
}</span>

// Font returns the font settings for this run.
func (r *run) Font() domain.Font <span class="cov8" title="1">{
        return r.font
}</span>

// SetFont sets the font for this run.
func (r *run) SetFont(font domain.Font) error <span class="cov0" title="0">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.SetFont", "font.Name", font.Name, "font name cannot be empty")
        }</span>
        <span class="cov0" title="0">r.font = font
        return nil</span>
}

// Color returns the text color.
func (r *run) Color() domain.Color <span class="cov8" title="1">{
        return r.color
}</span>

// SetColor sets the text color.
func (r *run) SetColor(color domain.Color) error <span class="cov8" title="1">{
        // Color validation is implicit via uint8 type (0-255)
        r.color = color
        return nil
}</span>

// Size returns the font size in half-points.
func (r *run) Size() int <span class="cov8" title="1">{
        return r.size
}</span>

// SetSize sets the font size in half-points.
func (r *run) SetSize(halfPoints int) error <span class="cov8" title="1">{
        if halfPoints &lt; constants.MinFontSize || halfPoints &gt; constants.MaxFontSize </span><span class="cov8" title="1">{
                return errors.InvalidArgument("Run.SetSize", "halfPoints", halfPoints,
                        "font size must be between 2 and 3276 half-points (1pt - 1638pt)")
        }</span>
        <span class="cov8" title="1">r.size = halfPoints
        return nil</span>
}

// Bold returns whether the text is bold.
func (r *run) Bold() bool <span class="cov8" title="1">{
        return r.bold
}</span>

// SetBold sets whether the text is bold.
func (r *run) SetBold(bold bool) error <span class="cov8" title="1">{
        r.bold = bold
        return nil
}</span>

// Italic returns whether the text is italic.
func (r *run) Italic() bool <span class="cov8" title="1">{
        return r.italic
}</span>

// SetItalic sets whether the text is italic.
func (r *run) SetItalic(italic bool) error <span class="cov8" title="1">{
        r.italic = italic
        return nil
}</span>

// Underline returns the underline style.
func (r *run) Underline() domain.UnderlineStyle <span class="cov8" title="1">{
        return r.underline
}</span>

// SetUnderline sets the underline style.
func (r *run) SetUnderline(style domain.UnderlineStyle) error <span class="cov0" title="0">{
        // Validate underline style
        if style &lt; domain.UnderlineNone || style &gt; domain.UnderlineWave </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.SetUnderline", "style", style,
                        "invalid underline style")
        }</span>
        <span class="cov0" title="0">r.underline = style
        return nil</span>
}

// Strike returns whether the text is struck through.
func (r *run) Strike() bool <span class="cov8" title="1">{
        return r.strike
}</span>

// SetStrike sets whether the text is struck through.
func (r *run) SetStrike(strike bool) error <span class="cov0" title="0">{
        r.strike = strike
        return nil
}</span>

// Highlight returns the highlight color.
func (r *run) Highlight() domain.HighlightColor <span class="cov8" title="1">{
        return r.highlight
}</span>

// SetHighlight sets the highlight color.
func (r *run) SetHighlight(color domain.HighlightColor) error <span class="cov0" title="0">{
        // Validate highlight color
        if color &lt; domain.HighlightNone || color &gt; domain.HighlightLightGray </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.SetHighlight", "color", color,
                        "invalid highlight color")
        }</span>
        <span class="cov0" title="0">r.highlight = color
        return nil</span>
}

// AddText is a convenience method that appends text to the run.
func (r *run) AddText(text string) error <span class="cov0" title="0">{
        r.text += text
        return nil
}</span>

// AddBreak adds a break to the run (page, column, or line break).
func (r *run) AddBreak(breakType domain.BreakType) error <span class="cov0" title="0">{
        if breakType &lt; domain.BreakTypePage || breakType &gt; domain.BreakTypeLine </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.AddBreak", "breakType", breakType, "invalid break type")
        }</span>

        <span class="cov0" title="0">if r.breaks == nil </span><span class="cov0" title="0">{
                r.breaks = make([]domain.BreakType, 0, 1)
        }</span>

        <span class="cov0" title="0">r.breaks = append(r.breaks, breakType)
        return nil</span>
}

// Breaks returns all breaks in this run.
func (r *run) Breaks() []domain.BreakType <span class="cov8" title="1">{
        if r.breaks == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Return a defensive copy
        <span class="cov0" title="0">result := make([]domain.BreakType, len(r.breaks))
        copy(result, r.breaks)
        return result</span>
}

// AddField adds a field to this run (e.g., page number, TOC, hyperlink).
func (r *run) AddField(field domain.Field) error <span class="cov0" title="0">{
        if field == nil </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.AddField", "field", nil, "field cannot be nil")
        }</span>

        <span class="cov0" title="0">if field.Type() == domain.FieldTypeHyperlink </span><span class="cov0" title="0">{
                accessor, ok := field.(interface {
                        GetProperty(string) (string, bool)
                        SetProperty(string, string)
                })
                if !ok </span><span class="cov0" title="0">{
                        return errors.InvalidArgument("Run.AddField", "field", field, "hyperlink field must support property access")
                }</span>

                <span class="cov0" title="0">if r.relManager == nil </span><span class="cov0" title="0">{
                        return errors.InvalidState("Run.AddField", "hyperlink relationship manager not initialized")
                }</span>

                <span class="cov0" title="0">url, ok := accessor.GetProperty("url")
                if !ok || url == "" </span><span class="cov0" title="0">{
                        return errors.InvalidArgument("Run.AddField", "url", url, "hyperlink URL cannot be empty")
                }</span>

                <span class="cov0" title="0">relID, err := r.relManager.AddHyperlink(url)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Run.AddField")
                }</span>

                <span class="cov0" title="0">accessor.SetProperty("relationshipID", relID)</span>
        }

        <span class="cov0" title="0">if r.fields == nil </span><span class="cov0" title="0">{
                r.fields = make([]domain.Field, 0, 2)
        }</span>

        <span class="cov0" title="0">r.fields = append(r.fields, field)
        return nil</span>
}

// Fields returns all fields in this run.
func (r *run) Fields() []domain.Field <span class="cov8" title="1">{
        if r.fields == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Return a defensive copy
        <span class="cov0" title="0">result := make([]domain.Field, len(r.fields))
        copy(result, r.fields)
        return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package core

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// docxSection implements the Section interface.
type docxSection struct {
        mu           sync.RWMutex
        pageSize     domain.PageSize
        margins      domain.Margins
        orientation  domain.Orientation
        columns      int
        headers      map[domain.HeaderType]*docxHeader
        footers      map[domain.FooterType]*docxFooter
        relationMgr  *manager.RelationshipManager
        idGen        *manager.IDGenerator
        mediaManager *manager.MediaManager
}

// NewSection creates a new section with default settings.
func NewSection(relationMgr *manager.RelationshipManager, idGen *manager.IDGenerator, mediaManager *manager.MediaManager) domain.Section <span class="cov8" title="1">{
        return &amp;docxSection{
                pageSize:     domain.PageSizeA4,
                margins:      domain.DefaultMargins,
                orientation:  domain.OrientationPortrait,
                columns:      1,
                headers:      make(map[domain.HeaderType]*docxHeader),
                footers:      make(map[domain.FooterType]*docxFooter),
                relationMgr:  relationMgr,
                idGen:        idGen,
                mediaManager: mediaManager,
        }
}</span>

// PageSize returns the page size for this section.
func (s *docxSection) PageSize() domain.PageSize <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.pageSize
}</span>

// SetPageSize sets the page size.
func (s *docxSection) SetPageSize(size domain.PageSize) error <span class="cov0" title="0">{
        if size.Width &lt;= 0 || size.Height &lt;= 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetPageSize",
                        "page size",
                        size,
                        "width and height must be positive",
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.pageSize = size
        return nil</span>
}

// Margins returns the page margins.
func (s *docxSection) Margins() domain.Margins <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.margins
}</span>

// SetMargins sets the page margins.
func (s *docxSection) SetMargins(margins domain.Margins) error <span class="cov0" title="0">{
        if margins.Top &lt; 0 || margins.Right &lt; 0 || margins.Bottom &lt; 0 || margins.Left &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetMargins",
                        "margins",
                        margins,
                        "margins cannot be negative",
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.margins = margins
        return nil</span>
}

// Orientation returns the page orientation.
func (s *docxSection) Orientation() domain.Orientation <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.orientation
}</span>

// SetOrientation sets the page orientation.
func (s *docxSection) SetOrientation(orient domain.Orientation) error <span class="cov0" title="0">{
        if orient != domain.OrientationPortrait &amp;&amp; orient != domain.OrientationLandscape </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetOrientation",
                        "orientation",
                        orient,
                        "must be Portrait or Landscape",
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.orientation = orient
        return nil</span>
}

// Columns returns the number of columns.
func (s *docxSection) Columns() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.columns
}</span>

// SetColumns sets the number of columns.
func (s *docxSection) SetColumns(count int) error <span class="cov0" title="0">{
        if count &lt; 1 || count &gt; constants.MaxColumns </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetColumns",
                        "columns",
                        count,
                        "must be between 1 and "+string(rune(constants.MaxColumns)),
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.columns = count
        return nil</span>
}

// Header returns the header for this section.
func (s *docxSection) Header(headerType domain.HeaderType) (domain.Header, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if header already exists
        if header, exists := s.headers[headerType]; exists </span><span class="cov0" title="0">{
                return header, nil
        }</span>

        // Create new header
        <span class="cov8" title="1">header := &amp;docxHeader{
                headerType:   headerType,
                paragraphs:   make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                relationMgr:  s.relationMgr,
                idGen:        s.idGen,
                mediaManager: s.mediaManager,
        }

        s.headers[headerType] = header
        return header, nil</span>
}

// Footer returns the footer for this section.
func (s *docxSection) Footer(footerType domain.FooterType) (domain.Footer, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if footer already exists
        if footer, exists := s.footers[footerType]; exists </span><span class="cov0" title="0">{
                return footer, nil
        }</span>

        // Create new footer
        <span class="cov8" title="1">footer := &amp;docxFooter{
                footerType:   footerType,
                paragraphs:   make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                relationMgr:  s.relationMgr,
                idGen:        s.idGen,
                mediaManager: s.mediaManager,
        }

        s.footers[footerType] = footer
        return footer, nil</span>
}

// HeadersAll returns a copy of all headers defined for the section.
func (s *docxSection) HeadersAll() map[domain.HeaderType]domain.Header <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        result := make(map[domain.HeaderType]domain.Header, len(s.headers))
        for k, v := range s.headers </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// FootersAll returns a copy of all footers defined for the section.
func (s *docxSection) FootersAll() map[domain.FooterType]domain.Footer <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        result := make(map[domain.FooterType]domain.Footer, len(s.footers))
        for k, v := range s.footers </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// docxHeader implements the Header interface.
type docxHeader struct {
        mu           sync.RWMutex
        headerType   domain.HeaderType
        paragraphs   []domain.Paragraph
        relationMgr  *manager.RelationshipManager
        idGen        *manager.IDGenerator
        relID        string
        targetPath   string
        mediaManager *manager.MediaManager
}

// AddParagraph adds a paragraph to the header.
func (h *docxHeader) AddParagraph() (domain.Paragraph, error) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        id := h.idGen.NextParagraphID()
        para := NewParagraph(id, h.idGen, h.relationMgr, h.mediaManager)
        h.paragraphs = append(h.paragraphs, para)
        return para, nil
}</span>

// Paragraphs returns all paragraphs in the header.
func (h *docxHeader) Paragraphs() []domain.Paragraph <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        // Return defensive copy
        result := make([]domain.Paragraph, len(h.paragraphs))
        copy(result, h.paragraphs)
        return result
}</span>

// RelationshipID returns the relationship ID associated with this header.
func (h *docxHeader) RelationshipID() string <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.relID
}</span>

// TargetPath returns the target part path for this header within the DOCX package.
func (h *docxHeader) TargetPath() string <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.targetPath
}</span>

// setRelationship stores the relationship metadata for the header.
func (h *docxHeader) setRelationship(relID, target string) <span class="cov8" title="1">{
        h.mu.Lock()
        h.relID = relID
        h.targetPath = target
        h.mu.Unlock()
}</span>

// docxFooter implements the Footer interface.
type docxFooter struct {
        mu           sync.RWMutex
        footerType   domain.FooterType
        paragraphs   []domain.Paragraph
        relationMgr  *manager.RelationshipManager
        idGen        *manager.IDGenerator
        relID        string
        targetPath   string
        mediaManager *manager.MediaManager
}

// AddParagraph adds a paragraph to the footer.
func (f *docxFooter) AddParagraph() (domain.Paragraph, error) <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        id := f.idGen.NextParagraphID()
        para := NewParagraph(id, f.idGen, f.relationMgr, f.mediaManager)
        f.paragraphs = append(f.paragraphs, para)
        return para, nil
}</span>

// Paragraphs returns all paragraphs in the footer.
func (f *docxFooter) Paragraphs() []domain.Paragraph <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        // Return defensive copy
        result := make([]domain.Paragraph, len(f.paragraphs))
        copy(result, f.paragraphs)
        return result
}</span>

// RelationshipID returns the relationship ID associated with this footer.
func (f *docxFooter) RelationshipID() string <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.relID
}</span>

// TargetPath returns the target part path for this footer within the DOCX package.
func (f *docxFooter) TargetPath() string <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.targetPath
}</span>

// setRelationship stores the relationship metadata for the footer.
func (f *docxFooter) setRelationship(relID, target string) <span class="cov8" title="1">{
        f.mu.Lock()
        f.relID = relID
        f.targetPath = target
        f.mu.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package core

import (
        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// table implements the domain.Table interface.
type table struct {
        id           string
        rows         []domain.TableRow
        cols         int
        width        domain.TableWidth
        alignment    domain.Alignment
        style        domain.TableStyle
        idGen        *manager.IDGenerator
        relManager   *manager.RelationshipManager
        mediaManager *manager.MediaManager
}

// NewTable creates a new Table.
func NewTable(id string, rows, cols int, idGen *manager.IDGenerator, relManager *manager.RelationshipManager, mediaManager *manager.MediaManager) domain.Table <span class="cov8" title="1">{
        t := &amp;table{
                id:           id,
                rows:         make([]domain.TableRow, 0, rows),
                cols:         cols,
                width:        domain.TableWidth{Type: domain.WidthAuto, Value: 0},
                alignment:    domain.AlignmentLeft,
                style:        domain.TableStyle{},
                idGen:        idGen,
                relManager:   relManager,
                mediaManager: mediaManager,
        }

        // Create initial rows
        for i := 0; i &lt; rows; i++ </span><span class="cov8" title="1">{
                rowID := idGen.NextRowID()
                row := NewTableRow(t, rowID, cols, idGen, relManager, mediaManager)
                t.rows = append(t.rows, row)
        }</span>

        <span class="cov8" title="1">return t</span>
}

// Row returns the row at the specified index.
func (t *table) Row(index int) (domain.TableRow, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(t.rows) </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Table.Row", "index", index,
                        "row index out of bounds")
        }</span>
        <span class="cov8" title="1">return t.rows[index], nil</span>
}

// Rows returns all rows in the table.
func (t *table) Rows() []domain.TableRow <span class="cov8" title="1">{
        rows := make([]domain.TableRow, len(t.rows))
        copy(rows, t.rows)
        return rows
}</span>

// AddRow adds a new row to the end of the table.
func (t *table) AddRow() (domain.TableRow, error) <span class="cov8" title="1">{
        rowID := t.idGen.NextRowID()
        row := NewTableRow(t, rowID, t.cols, t.idGen, t.relManager, t.mediaManager)
        t.rows = append(t.rows, row)
        return row, nil
}</span>

// InsertRow inserts a new row at the specified index.
func (t *table) InsertRow(index int) (domain.TableRow, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; len(t.rows) </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Table.InsertRow", "index", index,
                        "row index out of bounds")
        }</span>

        <span class="cov8" title="1">rowID := t.idGen.NextRowID()
        row := NewTableRow(t, rowID, t.cols, t.idGen, t.relManager, t.mediaManager)

        // Insert at index
        t.rows = append(t.rows[:index], append([]domain.TableRow{row}, t.rows[index:]...)...)

        return row, nil</span>
}

// DeleteRow deletes the row at the specified index.
func (t *table) DeleteRow(index int) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(t.rows) </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Table.DeleteRow", "index", index,
                        "row index out of bounds")
        }</span>

        <span class="cov8" title="1">t.rows = append(t.rows[:index], t.rows[index+1:]...)
        return nil</span>
}

// RowCount returns the number of rows in the table.
func (t *table) RowCount() int <span class="cov8" title="1">{
        return len(t.rows)
}</span>

// ColumnCount returns the number of columns in the table.
func (t *table) ColumnCount() int <span class="cov8" title="1">{
        return t.cols
}</span>

// Width returns the table width.
func (t *table) Width() domain.TableWidth <span class="cov8" title="1">{
        return t.width
}</span>

// SetWidth sets the table width.
func (t *table) SetWidth(width domain.TableWidth) error <span class="cov0" title="0">{
        if width.Type &lt; domain.WidthAuto || width.Type &gt; domain.WidthPct </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Table.SetWidth", "width.Type", width.Type,
                        "invalid width type")
        }</span>
        <span class="cov0" title="0">t.width = width
        return nil</span>
}

// Alignment returns the table alignment.
func (t *table) Alignment() domain.Alignment <span class="cov8" title="1">{
        return t.alignment
}</span>

// SetAlignment sets the table alignment.
func (t *table) SetAlignment(align domain.Alignment) error <span class="cov0" title="0">{
        if align &lt; domain.AlignmentLeft || align &gt; domain.AlignmentDistribute </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Table.SetAlignment", "align", align,
                        "invalid alignment value")
        }</span>
        <span class="cov0" title="0">t.alignment = align
        return nil</span>
}

// Style returns the table style.
func (t *table) Style() domain.TableStyle <span class="cov8" title="1">{
        return t.style
}</span>

// SetStyle sets the table style.
func (t *table) SetStyle(style domain.TableStyle) error <span class="cov8" title="1">{
        t.style = style
        return nil
}</span>

// tableRow implements the domain.TableRow interface.
type tableRow struct {
        id           string
        cells        []domain.TableCell
        height       int
        table        *table
        idGen        *manager.IDGenerator
        relManager   *manager.RelationshipManager
        mediaManager *manager.MediaManager
}

// NewTableRow creates a new TableRow.
func NewTableRow(tbl *table, id string, cols int, idGen *manager.IDGenerator, relManager *manager.RelationshipManager, mediaManager *manager.MediaManager) domain.TableRow <span class="cov8" title="1">{
        row := &amp;tableRow{
                id:           id,
                cells:        make([]domain.TableCell, 0, cols),
                height:       0, // Auto height
                table:        tbl,
                idGen:        idGen,
                relManager:   relManager,
                mediaManager: mediaManager,
        }

        // Create cells
        for i := 0; i &lt; cols; i++ </span><span class="cov8" title="1">{
                cellID := idGen.NextCellID()
                cell := NewTableCell(row, cellID, idGen, relManager, mediaManager)
                row.cells = append(row.cells, cell)
        }</span>

        <span class="cov8" title="1">return row</span>
}

// Cell returns the cell at the specified column index.
func (r *tableRow) Cell(col int) (domain.TableCell, error) <span class="cov8" title="1">{
        if col &lt; 0 || col &gt;= len(r.cells) </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("TableRow.Cell", "col", col,
                        "column index out of bounds")
        }</span>
        <span class="cov8" title="1">return r.cells[col], nil</span>
}

// Cells returns all cells in this row.
func (r *tableRow) Cells() []domain.TableCell <span class="cov8" title="1">{
        cells := make([]domain.TableCell, len(r.cells))
        copy(cells, r.cells)
        return cells
}</span>

// Height returns the row height.
func (r *tableRow) Height() int <span class="cov8" title="1">{
        return r.height
}</span>

// SetHeight sets the row height in twips.
func (r *tableRow) SetHeight(twips int) error <span class="cov0" title="0">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableRow.SetHeight", "twips", twips,
                        "height cannot be negative")
        }</span>
        <span class="cov0" title="0">r.height = twips
        return nil</span>
}

// tableCell implements the domain.TableCell interface.
type tableCell struct {
        id                string
        paragraphs        []domain.Paragraph
        tables            []domain.Table
        width             int
        verticalAlignment domain.VerticalAlignment
        borders           domain.TableBorders
        shading           domain.Color
        gridSpan          int
        vMerge            domain.VerticalMergeType
        row               *tableRow
        hMergeParent      *tableCell
        idGen             *manager.IDGenerator
        relManager        *manager.RelationshipManager
        mediaManager      *manager.MediaManager
}

// NewTableCell creates a new TableCell.
func NewTableCell(row *tableRow, id string, idGen *manager.IDGenerator, relManager *manager.RelationshipManager, mediaManager *manager.MediaManager) domain.TableCell <span class="cov8" title="1">{
        return &amp;tableCell{
                id:                id,
                paragraphs:        make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                tables:            make([]domain.Table, 0, 1),
                width:             0, // Auto width
                verticalAlignment: domain.VerticalAlignTop,
                borders:           domain.TableBorders{},
                shading:           domain.ColorWhite,
                gridSpan:          1, // Default: no horizontal merge
                vMerge:            domain.VMergeNone,
                row:               row,
                idGen:             idGen,
                relManager:        relManager,
                mediaManager:      mediaManager,
        }
}</span>

// AddParagraph adds a paragraph to this cell.
func (c *tableCell) AddParagraph() (domain.Paragraph, error) <span class="cov8" title="1">{
        id := c.idGen.NextParagraphID()
        para := NewParagraph(id, c.idGen, c.relManager, c.mediaManager)
        c.paragraphs = append(c.paragraphs, para)
        return para, nil
}</span>

// Paragraphs returns all paragraphs in this cell.
func (c *tableCell) Paragraphs() []domain.Paragraph <span class="cov8" title="1">{
        paras := make([]domain.Paragraph, len(c.paragraphs))
        copy(paras, c.paragraphs)
        return paras
}</span>

// Width returns the cell width.
func (c *tableCell) Width() int <span class="cov8" title="1">{
        return c.width
}</span>

// SetWidth sets the cell width in twips.
func (c *tableCell) SetWidth(twips int) error <span class="cov0" title="0">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableCell.SetWidth", "twips", twips,
                        "width cannot be negative")
        }</span>
        <span class="cov0" title="0">c.width = twips
        return nil</span>
}

// VerticalAlignment returns the vertical alignment of content.
func (c *tableCell) VerticalAlignment() domain.VerticalAlignment <span class="cov8" title="1">{
        return c.verticalAlignment
}</span>

// SetVerticalAlignment sets the vertical alignment.
func (c *tableCell) SetVerticalAlignment(align domain.VerticalAlignment) error <span class="cov0" title="0">{
        if align &lt; domain.VerticalAlignTop || align &gt; domain.VerticalAlignBottom </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableCell.SetVerticalAlignment", "align", align,
                        "invalid vertical alignment value")
        }</span>
        <span class="cov0" title="0">c.verticalAlignment = align
        return nil</span>
}

// Borders returns the cell borders.
func (c *tableCell) Borders() domain.TableBorders <span class="cov0" title="0">{
        return c.borders
}</span>

// SetBorders sets the cell borders.
func (c *tableCell) SetBorders(borders domain.TableBorders) error <span class="cov0" title="0">{
        c.borders = borders
        return nil
}</span>

// Shading returns the cell background color.
func (c *tableCell) Shading() domain.Color <span class="cov8" title="1">{
        return c.shading
}</span>

// SetShading sets the cell background color.
func (c *tableCell) SetShading(color domain.Color) error <span class="cov0" title="0">{
        c.shading = color
        return nil
}</span>

// Merge merges this cell with adjacent cells.
func (c *tableCell) Merge(cols, rows int) error <span class="cov8" title="1">{
        const op = "TableCell.Merge"

        if cols &lt; 1 </span><span class="cov8" title="1">{
                return errors.InvalidArgument(op, "cols", cols,
                        "cols must be at least 1")
        }</span>
        <span class="cov8" title="1">if rows &lt; 1 </span><span class="cov8" title="1">{
                return errors.InvalidArgument(op, "rows", rows,
                        "rows must be at least 1")
        }</span>

        <span class="cov8" title="1">if c.row == nil || c.row.table == nil </span><span class="cov0" title="0">{
                return errors.InvalidState(op, "cell is not attached to a table")
        }</span>

        <span class="cov8" title="1">if c.hMergeParent != nil </span><span class="cov0" title="0">{
                return errors.InvalidState(op, "cannot merge from a horizontally merged cell")
        }</span>
        <span class="cov8" title="1">if c.vMerge == domain.VMergeContinue </span><span class="cov0" title="0">{
                return errors.InvalidState(op, "cannot merge from a vertically continued cell")
        }</span>

        <span class="cov8" title="1">row := c.row
        colIndex := -1
        for idx, candidate := range row.cells </span><span class="cov8" title="1">{
                if tc, ok := candidate.(*tableCell); ok &amp;&amp; tc == c </span><span class="cov8" title="1">{
                        colIndex = idx
                        break</span>
                }
        }
        <span class="cov8" title="1">if colIndex == -1 </span><span class="cov0" title="0">{
                return errors.InvalidState(op, "cell not found in parent row")
        }</span>

        <span class="cov8" title="1">if colIndex+cols &gt; len(row.cells) </span><span class="cov0" title="0">{
                return errors.InvalidArgument(op, "cols", cols,
                        "merge exceeds row column count")
        }</span>

        <span class="cov8" title="1">tbl := row.table
        rowIndex := -1
        for idx, candidate := range tbl.rows </span><span class="cov8" title="1">{
                if tr, ok := candidate.(*tableRow); ok &amp;&amp; tr == row </span><span class="cov8" title="1">{
                        rowIndex = idx
                        break</span>
                }
        }
        <span class="cov8" title="1">if rowIndex == -1 </span><span class="cov0" title="0">{
                return errors.InvalidState(op, "parent row not found in table")
        }</span>

        <span class="cov8" title="1">if rowIndex+rows &gt; len(tbl.rows) </span><span class="cov0" title="0">{
                return errors.InvalidArgument(op, "rows", rows,
                        "merge exceeds available rows")
        }</span>

        // Validate that the merge region is free of existing merges
        <span class="cov8" title="1">for rOffset := 0; rOffset &lt; rows; rOffset++ </span><span class="cov8" title="1">{
                targetRow, ok := tbl.rows[rowIndex+rOffset].(*tableRow)
                if !ok </span><span class="cov0" title="0">{
                        return errors.InvalidState(op, "unexpected row implementation type")
                }</span>

                <span class="cov8" title="1">for cOffset := 0; cOffset &lt; cols; cOffset++ </span><span class="cov8" title="1">{
                        targetCell, ok := targetRow.cells[colIndex+cOffset].(*tableCell)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.InvalidState(op, "unexpected cell implementation type")
                        }</span>

                        <span class="cov8" title="1">if targetCell == c </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if targetCell.hMergeParent != nil </span><span class="cov0" title="0">{
                                return errors.InvalidState(op, "merge region overlaps an existing horizontal merge")
                        }</span>
                        <span class="cov8" title="1">if targetCell.vMerge != domain.VMergeNone </span><span class="cov0" title="0">{
                                return errors.InvalidState(op, "merge region overlaps an existing vertical merge")
                        }</span>
                        <span class="cov8" title="1">if targetCell.gridSpan &gt; 1 </span><span class="cov0" title="0">{
                                return errors.InvalidState(op, "merge region overlaps an existing grid span")
                        }</span>
                }
        }

        // Configure the primary cell
        <span class="cov8" title="1">c.hMergeParent = nil
        c.gridSpan = cols
        if rows &gt; 1 </span><span class="cov8" title="1">{
                c.vMerge = domain.VMergeRestart
        }</span> else<span class="cov8" title="1"> {
                c.vMerge = domain.VMergeNone
        }</span>

        // Apply horizontal merge within the current row
        <span class="cov8" title="1">for offset := 1; offset &lt; cols; offset++ </span><span class="cov8" title="1">{
                sibling := row.cells[colIndex+offset].(*tableCell)
                sibling.hMergeParent = c
                sibling.gridSpan = 1
                sibling.vMerge = domain.VMergeNone
        }</span>

        // Apply vertical merges across subsequent rows
        <span class="cov8" title="1">if rows &gt; 1 </span><span class="cov8" title="1">{
                for rOffset := 1; rOffset &lt; rows; rOffset++ </span><span class="cov8" title="1">{
                        targetRow := tbl.rows[rowIndex+rOffset].(*tableRow)
                        leading := targetRow.cells[colIndex].(*tableCell)
                        leading.hMergeParent = nil
                        leading.gridSpan = cols
                        leading.vMerge = domain.VMergeContinue

                        for cOffset := 1; cOffset &lt; cols; cOffset++ </span><span class="cov8" title="1">{
                                neighbor := targetRow.cells[colIndex+cOffset].(*tableCell)
                                neighbor.hMergeParent = leading
                                neighbor.gridSpan = 1
                                neighbor.vMerge = domain.VMergeContinue
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GridSpan returns the number of grid columns spanned by this cell.
func (c *tableCell) GridSpan() int <span class="cov8" title="1">{
        return c.gridSpan
}</span>

// SetGridSpan sets the horizontal merge span.
func (c *tableCell) SetGridSpan(span int) error <span class="cov8" title="1">{
        if span &lt; 1 </span><span class="cov8" title="1">{
                return errors.InvalidArgument("TableCell.SetGridSpan", "span", span,
                        "span must be at least 1")
        }</span>
        <span class="cov8" title="1">c.gridSpan = span
        return nil</span>
}

// VMerge returns the vertical merge type.
func (c *tableCell) VMerge() domain.VerticalMergeType <span class="cov8" title="1">{
        return c.vMerge
}</span>

// SetVMerge sets the vertical merge type.
func (c *tableCell) SetVMerge(mergeType domain.VerticalMergeType) error <span class="cov8" title="1">{
        if mergeType &lt; domain.VMergeNone || mergeType &gt; domain.VMergeContinue </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableCell.SetVMerge", "mergeType", mergeType,
                        "invalid vertical merge type")
        }</span>
        <span class="cov8" title="1">c.vMerge = mergeType
        return nil</span>
}

// AddTable adds a nested table to this cell.
func (c *tableCell) AddTable(rows, cols int) (domain.Table, error) <span class="cov8" title="1">{
        if rows &lt; 1 </span><span class="cov8" title="1">{
                return nil, errors.InvalidArgument("TableCell.AddTable", "rows", rows,
                        "rows must be at least 1")
        }</span>
        <span class="cov8" title="1">if cols &lt; 1 </span><span class="cov8" title="1">{
                return nil, errors.InvalidArgument("TableCell.AddTable", "cols", cols,
                        "cols must be at least 1")
        }</span>

        <span class="cov8" title="1">table := NewTable(c.idGen.GenerateID("table"), rows, cols, c.idGen, c.relManager, c.mediaManager)
        c.tables = append(c.tables, table)
        return table, nil</span>
}

// Tables returns all nested tables in this cell.
func (c *tableCell) Tables() []domain.Table <span class="cov8" title="1">{
        // Return a defensive copy
        result := make([]domain.Table, len(c.tables))
        copy(result, c.tables)
        return result
}</span>

// IsHorizontallyMergedContinuation reports whether this cell is hidden by a
// horizontal merge originating from another cell in the same row.
func (c *tableCell) IsHorizontallyMergedContinuation() bool <span class="cov8" title="1">{
        return c.hMergeParent != nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// characterStyle implements domain.CharacterStyle.
type characterStyle struct {
        mu        sync.RWMutex
        id        string
        name      string
        basedOn   string
        font      domain.Font
        isDefault bool
        isBuiltIn bool
        bold      bool
        italic    bool
        underline domain.UnderlineStyle
        color     domain.Color
        size      int // in half-points
}

// newCharacterStyle creates a new character style.
// Note: builtIn parameter is used in tests to create custom styles.
//
//nolint:unparam // builtIn always true in production, but false in tests
func newCharacterStyle(id, name string, builtIn bool) *characterStyle <span class="cov8" title="1">{
        return &amp;characterStyle{
                id:        id,
                name:      name,
                isBuiltIn: builtIn,
                font:      domain.Font{Name: constants.DefaultFontName},
                color:     domain.ColorBlack,
                size:      constants.DefaultFontSize,
                underline: domain.UnderlineNone,
        }
}</span>

// ID returns the unique style identifier.
func (cs *characterStyle) ID() string <span class="cov8" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.id
}</span>

// Name returns the style display name.
func (cs *characterStyle) Name() string <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.name
}</span>

// Type returns the style type.
func (cs *characterStyle) Type() domain.StyleType <span class="cov8" title="1">{
        return domain.StyleTypeCharacter
}</span>

// BasedOn returns the style ID this style is based on.
func (cs *characterStyle) BasedOn() string <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.basedOn
}</span>

// SetBasedOn sets the parent style.
func (cs *characterStyle) SetBasedOn(styleID string) error <span class="cov8" title="1">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.basedOn = styleID
        return nil
}</span>

// Next returns the style ID for next paragraph (not applicable for character styles).
func (cs *characterStyle) Next() string <span class="cov0" title="0">{
        return ""
}</span>

// SetNext sets next paragraph style (not applicable for character styles).
func (cs *characterStyle) SetNext(styleID string) error <span class="cov0" title="0">{
        return errors.NewValidationError(
                "CharacterStyle.SetNext",
                "styleID",
                styleID,
                "Next property not applicable for character styles",
        )
}</span>

// Font returns the font settings.
func (cs *characterStyle) Font() domain.Font <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.font
}</span>

// SetFont sets the font settings.
func (cs *characterStyle) SetFont(font domain.Font) error <span class="cov0" title="0">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "CharacterStyle.SetFont",
                        "font.Name",
                        "",
                        "font name cannot be empty",
                )
        }</span>

        <span class="cov0" title="0">cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.font = font
        return nil</span>
}

// IsDefault returns whether this is a default style.
func (cs *characterStyle) IsDefault() bool <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.isDefault
}</span>

// SetDefault marks this style as default.
func (cs *characterStyle) SetDefault(isDefault bool) error <span class="cov8" title="1">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.isDefault = isDefault
        return nil
}</span>

// IsCustom returns whether this is a custom style.
func (cs *characterStyle) IsCustom() bool <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return !cs.isBuiltIn
}</span>

// Bold returns whether the text is bold.
func (cs *characterStyle) Bold() bool <span class="cov8" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.bold
}</span>

// SetBold sets whether the text is bold.
func (cs *characterStyle) SetBold(bold bool) error <span class="cov8" title="1">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.bold = bold
        return nil
}</span>

// Italic returns whether the text is italic.
func (cs *characterStyle) Italic() bool <span class="cov8" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.italic
}</span>

// SetItalic sets whether the text is italic.
func (cs *characterStyle) SetItalic(italic bool) error <span class="cov8" title="1">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.italic = italic
        return nil
}</span>

// Underline returns the underline style.
func (cs *characterStyle) Underline() domain.UnderlineStyle <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.underline
}</span>

// SetUnderline sets the underline style.
func (cs *characterStyle) SetUnderline(style domain.UnderlineStyle) error <span class="cov8" title="1">{
        if style &lt; domain.UnderlineNone || style &gt; domain.UnderlineWave </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "CharacterStyle.SetUnderline",
                        "style",
                        style,
                        "invalid underline style",
                )
        }</span>

        <span class="cov8" title="1">cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.underline = style
        return nil</span>
}

// Color returns the text color.
func (cs *characterStyle) Color() domain.Color <span class="cov8" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.color
}</span>

// SetColor sets the text color.
func (cs *characterStyle) SetColor(color domain.Color) error <span class="cov8" title="1">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.color = color
        return nil
}</span>

// Size returns the font size in half-points.
func (cs *characterStyle) Size() int <span class="cov8" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.size
}</span>

// SetSize sets the font size in half-points.
func (cs *characterStyle) SetSize(halfPoints int) error <span class="cov8" title="1">{
        if halfPoints &lt; constants.MinFontSize || halfPoints &gt; constants.MaxFontSize </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "CharacterStyle.SetSize",
                        "halfPoints",
                        halfPoints,
                        "font size must be between 2 and 3276 half-points (1pt - 1638pt)",
                )
        }</span>

        <span class="cov8" title="1">cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.size = halfPoints
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Package manager provides internal management services for go-docx v2.
package manager

import (
        "fmt"
        "sync/atomic"

        "github.com/mmonterroca/docxgo/pkg/constants"
)

// IDGenerator generates unique IDs for document elements.
// It is thread-safe and can be used concurrently.
type IDGenerator struct {
        paragraphCounter atomic.Uint64
        runCounter       atomic.Uint64
        tableCounter     atomic.Uint64
        rowCounter       atomic.Uint64
        cellCounter      atomic.Uint64
        imageCounter     atomic.Uint64
        shapeCounter     atomic.Uint64
        relCounter       atomic.Uint64
        bookmarkCounter  atomic.Uint64
        commentCounter   atomic.Uint64
        footnoteCounter  atomic.Uint64
        endnoteCounter   atomic.Uint64
}

// NewIDGenerator creates a new ID generator.
func NewIDGenerator() *IDGenerator <span class="cov0" title="0">{
        return &amp;IDGenerator{}
}</span>

// NextParagraphID generates the next paragraph ID.
func (g *IDGenerator) NextParagraphID() string <span class="cov0" title="0">{
        id := g.paragraphCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixParagraph, id)
}</span>

// NextRunID generates the next run ID.
func (g *IDGenerator) NextRunID() string <span class="cov0" title="0">{
        id := g.runCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixRun, id)
}</span>

// NextTableID generates the next table ID.
func (g *IDGenerator) NextTableID() string <span class="cov0" title="0">{
        id := g.tableCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixTable, id)
}</span>

// NextRowID generates the next row ID.
func (g *IDGenerator) NextRowID() string <span class="cov0" title="0">{
        id := g.rowCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixRow, id)
}</span>

// NextCellID generates the next cell ID.
func (g *IDGenerator) NextCellID() string <span class="cov0" title="0">{
        id := g.cellCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixCell, id)
}</span>

// NextImageID generates the next image ID.
func (g *IDGenerator) NextImageID() string <span class="cov0" title="0">{
        id := g.imageCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixImage, id)
}</span>

// NextShapeID generates the next shape ID.
func (g *IDGenerator) NextShapeID() string <span class="cov0" title="0">{
        id := g.shapeCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixShape, id)
}</span>

// NextRelID generates the next relationship ID.
func (g *IDGenerator) NextRelID() string <span class="cov0" title="0">{
        id := g.relCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixRel, id)
}</span>

// NextBookmarkID generates the next bookmark ID.
func (g *IDGenerator) NextBookmarkID() string <span class="cov0" title="0">{
        id := g.bookmarkCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixBookmark, id)
}</span>

// NextCommentID generates the next comment ID.
func (g *IDGenerator) NextCommentID() string <span class="cov0" title="0">{
        id := g.commentCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixComment, id)
}</span>

// NextFootnoteID generates the next footnote ID.
func (g *IDGenerator) NextFootnoteID() string <span class="cov0" title="0">{
        id := g.footnoteCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixFootnote, id)
}</span>

// NextEndnoteID generates the next endnote ID.
func (g *IDGenerator) NextEndnoteID() string <span class="cov0" title="0">{
        id := g.endnoteCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixEndnote, id)
}</span>

// GenerateID generates an ID with a custom prefix.
// This is a generic method for any element type.
func (g *IDGenerator) GenerateID(prefix string) string <span class="cov0" title="0">{
        // Use table counter for generic IDs
        id := g.tableCounter.Add(1)
        return fmt.Sprintf("%s%d", prefix, id)
}</span>

// Reset resets all counters to zero.
// This should only be used when starting a new document.
func (g *IDGenerator) Reset() <span class="cov0" title="0">{
        g.paragraphCounter.Store(0)
        g.runCounter.Store(0)
        g.tableCounter.Store(0)
        g.rowCounter.Store(0)
        g.cellCounter.Store(0)
        g.imageCounter.Store(0)
        g.shapeCounter.Store(0)
        g.relCounter.Store(0)
        g.bookmarkCounter.Store(0)
        g.commentCounter.Store(0)
        g.footnoteCounter.Store(0)
        g.endnoteCounter.Store(0)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package manager

import (
        "fmt"
        "path/filepath"
        "strings"
        "sync"

        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// MediaFile represents a media file in the document.
type MediaFile struct {
        ID          string // Unique ID
        Name        string // File name (e.g., "image1.png")
        Path        string // Path within .docx (e.g., "word/media/image1.png")
        ContentType string // MIME type
        Data        []byte // File data
}

// MediaManager manages media files (images, etc.) in a document.
// It is thread-safe.
type MediaManager struct {
        mu      sync.RWMutex
        files   map[string]*MediaFile // key is ID
        idGen   *IDGenerator
        counter int // Counter for generating unique file names
}

// NewMediaManager creates a new media manager.
func NewMediaManager(idGen *IDGenerator) *MediaManager <span class="cov0" title="0">{
        return &amp;MediaManager{
                files: make(map[string]*MediaFile, constants.DefaultMediaCapacity),
                idGen: idGen,
        }
}</span>

// Add adds a media file and returns its ID and path.
func (mm *MediaManager) Add(data []byte, filename string) (id, path string, err error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return "", "", errors.InvalidArgument("MediaManager.Add", "data", data, "media data cannot be empty")
        }</span>
        <span class="cov0" title="0">if filename == "" </span><span class="cov0" title="0">{
                return "", "", errors.InvalidArgument("MediaManager.Add", "filename", filename, "filename cannot be empty")
        }</span>

        <span class="cov0" title="0">mm.mu.Lock()
        defer mm.mu.Unlock()

        // Generate unique ID
        id = mm.idGen.NextImageID()

        // Detect content type from extension
        ext := strings.ToLower(filepath.Ext(filename))
        contentType := mm.detectContentType(ext)

        // Generate unique filename
        mm.counter++
        uniqueName := fmt.Sprintf("image%d%s", mm.counter, ext)
        path = constants.PathMediaPrefix + uniqueName

        file := &amp;MediaFile{
                ID:          id,
                Name:        uniqueName,
                Path:        path,
                ContentType: contentType,
                Data:        data,
        }

        mm.files[id] = file
        return id, path, nil</span>
}

// Get retrieves a media file by ID.
func (mm *MediaManager) Get(id string) (*MediaFile, error) <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        file, exists := mm.files[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NotFound("MediaManager.Get", "media file")
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// GetByPath retrieves a media file by path.
func (mm *MediaManager) GetByPath(path string) (*MediaFile, error) <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        for _, file := range mm.files </span><span class="cov0" title="0">{
                if file.Path == path </span><span class="cov0" title="0">{
                        return file, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.NotFound("MediaManager.GetByPath", "media file")</span>
}

// All returns all media files.
func (mm *MediaManager) All() []*MediaFile <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        files := make([]*MediaFile, 0, len(mm.files))
        for _, file := range mm.files </span><span class="cov0" title="0">{
                files = append(files, file)
        }</span>

        <span class="cov0" title="0">return files</span>
}

// Count returns the number of media files.
func (mm *MediaManager) Count() int <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        return len(mm.files)
}</span>

// Delete removes a media file by ID.
func (mm *MediaManager) Delete(id string) error <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()

        if _, exists := mm.files[id]; !exists </span><span class="cov0" title="0">{
                return errors.NotFound("MediaManager.Delete", "media file")
        }</span>

        <span class="cov0" title="0">delete(mm.files, id)
        return nil</span>
}

// detectContentType returns the MIME type for a file extension.
func (mm *MediaManager) detectContentType(ext string) string <span class="cov0" title="0">{
        switch ext </span>{
        case ".png":<span class="cov0" title="0">
                return constants.ContentTypePNG</span>
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                return constants.ContentTypeJPEG</span>
        case ".gif":<span class="cov0" title="0">
                return constants.ContentTypeGIF</span>
        case ".bmp":<span class="cov0" title="0">
                return constants.ContentTypeBMP</span>
        case ".tiff", ".tif":<span class="cov0" title="0">
                return constants.ContentTypeTIFF</span>
        case ".wmf":<span class="cov0" title="0">
                return constants.ContentTypeWMF</span>
        case ".emf":<span class="cov0" title="0">
                return constants.ContentTypeEMF</span>
        default:<span class="cov0" title="0">
                return "application/octet-stream"</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// paragraphStyle implements domain.ParagraphStyle.
type paragraphStyle struct {
        mu              sync.RWMutex
        id              string
        name            string
        basedOn         string
        next            string
        font            domain.Font
        isDefault       bool
        isBuiltIn       bool
        alignment       domain.Alignment
        spacingBefore   int
        spacingAfter    int
        lineSpacing     int
        indentation     domain.Indentation
        keepNext        bool
        keepLines       bool
        pageBreakBefore bool
        outlineLevel    int
        runBold         bool
        runItalic       bool
        runUnderline    domain.UnderlineStyle
        runColor        domain.Color
        runSize         int
}

// newParagraphStyle creates a new paragraph style.
// Note: builtIn parameter is used in tests to create custom styles.
//
//nolint:unparam // builtIn always true in production, but false in tests
func newParagraphStyle(id, name string, builtIn bool) *paragraphStyle <span class="cov8" title="1">{
        return &amp;paragraphStyle{
                id:            id,
                name:          name,
                isBuiltIn:     builtIn,
                font:          domain.Font{Name: constants.DefaultFontName},
                alignment:     domain.AlignmentLeft,
                spacingBefore: 0,
                spacingAfter:  0,
                lineSpacing:   240, // Single spacing (240 = 1.0)
                outlineLevel:  0,   // Body text level
                runUnderline:  domain.UnderlineNone,
                runColor:      domain.ColorBlack,
                runSize:       constants.DefaultFontSize,
        }
}</span>

// ID returns the unique style identifier.
func (ps *paragraphStyle) ID() string <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.id
}</span>

// Name returns the style display name.
func (ps *paragraphStyle) Name() string <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.name
}</span>

// Type returns the style type.
func (ps *paragraphStyle) Type() domain.StyleType <span class="cov8" title="1">{
        return domain.StyleTypeParagraph
}</span>

// BasedOn returns the style ID this style is based on.
func (ps *paragraphStyle) BasedOn() string <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.basedOn
}</span>

// SetBasedOn sets the parent style.
func (ps *paragraphStyle) SetBasedOn(styleID string) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.basedOn = styleID
        return nil
}</span>

// Next returns the style ID to use for the next paragraph.
func (ps *paragraphStyle) Next() string <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.next
}</span>

// SetNext sets the next paragraph style.
func (ps *paragraphStyle) SetNext(styleID string) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.next = styleID
        return nil
}</span>

// Font returns the font settings.
func (ps *paragraphStyle) Font() domain.Font <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.font
}</span>

// SetFont sets the font settings.
func (ps *paragraphStyle) SetFont(font domain.Font) error <span class="cov8" title="1">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetFont",
                        "font.Name",
                        "",
                        "font name cannot be empty",
                )
        }</span>

        <span class="cov8" title="1">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.font = font
        return nil</span>
}

// IsDefault returns whether this is a default style.
func (ps *paragraphStyle) IsDefault() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.isDefault
}</span>

// SetDefault marks this style as default.
func (ps *paragraphStyle) SetDefault(isDefault bool) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.isDefault = isDefault
        return nil
}</span>

// IsCustom returns whether this is a custom style.
func (ps *paragraphStyle) IsCustom() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return !ps.isBuiltIn
}</span>

// Alignment returns the paragraph alignment.
func (ps *paragraphStyle) Alignment() domain.Alignment <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.alignment
}</span>

// SetAlignment sets the paragraph alignment.
func (ps *paragraphStyle) SetAlignment(align domain.Alignment) error <span class="cov8" title="1">{
        if align &lt; domain.AlignmentLeft || align &gt; domain.AlignmentDistribute </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetAlignment",
                        "alignment",
                        align,
                        "invalid alignment value",
                )
        }</span>

        <span class="cov8" title="1">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.alignment = align
        return nil</span>
}

// SpacingBefore returns spacing before paragraph in twips.
func (ps *paragraphStyle) SpacingBefore() int <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.spacingBefore
}</span>

// SetSpacingBefore sets spacing before paragraph.
func (ps *paragraphStyle) SetSpacingBefore(twips int) error <span class="cov8" title="1">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetSpacingBefore",
                        "twips",
                        twips,
                        "spacing cannot be negative",
                )
        }</span>

        <span class="cov8" title="1">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.spacingBefore = twips
        return nil</span>
}

// SpacingAfter returns spacing after paragraph in twips.
func (ps *paragraphStyle) SpacingAfter() int <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.spacingAfter
}</span>

// SetSpacingAfter sets spacing after paragraph.
func (ps *paragraphStyle) SetSpacingAfter(twips int) error <span class="cov8" title="1">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetSpacingAfter",
                        "twips",
                        twips,
                        "spacing cannot be negative",
                )
        }</span>

        <span class="cov8" title="1">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.spacingAfter = twips
        return nil</span>
}

// LineSpacing returns the line spacing value.
func (ps *paragraphStyle) LineSpacing() int <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.lineSpacing
}</span>

// SetLineSpacing sets the line spacing.
func (ps *paragraphStyle) SetLineSpacing(value int) error <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetLineSpacing",
                        "value",
                        value,
                        "line spacing cannot be negative",
                )
        }</span>

        <span class="cov0" title="0">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.lineSpacing = value
        return nil</span>
}

// Indentation returns the paragraph indentation.
func (ps *paragraphStyle) Indentation() domain.Indentation <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.indentation
}</span>

// SetIndentation sets the paragraph indentation.
func (ps *paragraphStyle) SetIndentation(indent domain.Indentation) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.indentation = indent
        return nil
}</span>

// KeepNext returns whether to keep with next paragraph.
func (ps *paragraphStyle) KeepNext() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.keepNext
}</span>

// SetKeepNext sets keep with next paragraph.
func (ps *paragraphStyle) SetKeepNext(keep bool) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.keepNext = keep
        return nil
}</span>

// KeepLines returns whether to keep lines together.
func (ps *paragraphStyle) KeepLines() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.keepLines
}</span>

// SetKeepLines sets keep lines together.
func (ps *paragraphStyle) SetKeepLines(keep bool) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.keepLines = keep
        return nil
}</span>

// PageBreakBefore returns whether to insert page break before.
func (ps *paragraphStyle) PageBreakBefore() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.pageBreakBefore
}</span>

// SetPageBreakBefore sets page break before.
func (ps *paragraphStyle) SetPageBreakBefore(breakBefore bool) error <span class="cov0" title="0">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.pageBreakBefore = breakBefore
        return nil
}</span>

// OutlineLevel returns the outline level.
func (ps *paragraphStyle) OutlineLevel() int <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.outlineLevel
}</span>

// SetOutlineLevel sets the outline level.
func (ps *paragraphStyle) SetOutlineLevel(level int) error <span class="cov8" title="1">{
        if level &lt; 0 || level &gt; 9 </span><span class="cov8" title="1">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetOutlineLevel",
                        "level",
                        level,
                        "outline level must be 0-9 (0=body text, 1-9=heading levels)",
                )
        }</span>

        <span class="cov8" title="1">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.outlineLevel = level
        return nil</span>
}

// Bold returns whether the default run is bold.
func (ps *paragraphStyle) Bold() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.runBold
}</span>

// SetBold sets bold on the default run formatting.
func (ps *paragraphStyle) SetBold(bold bool) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.runBold = bold
        return nil
}</span>

// Italic returns whether the default run is italic.
func (ps *paragraphStyle) Italic() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.runItalic
}</span>

// SetItalic sets italic on the default run formatting.
func (ps *paragraphStyle) SetItalic(italic bool) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.runItalic = italic
        return nil
}</span>

// Underline returns the underline style for the default run.
func (ps *paragraphStyle) Underline() domain.UnderlineStyle <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.runUnderline
}</span>

// SetUnderline sets underline style for the default run.
func (ps *paragraphStyle) SetUnderline(style domain.UnderlineStyle) error <span class="cov0" title="0">{
        if style &lt; domain.UnderlineNone || style &gt; domain.UnderlineWave </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetUnderline",
                        "style",
                        style,
                        "invalid underline style",
                )
        }</span>

        <span class="cov0" title="0">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.runUnderline = style
        return nil</span>
}

// Color returns the default run color.
func (ps *paragraphStyle) Color() domain.Color <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.runColor
}</span>

// SetColor sets the default run color.
func (ps *paragraphStyle) SetColor(color domain.Color) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.runColor = color
        return nil
}</span>

// Size returns the default run font size in half-points.
func (ps *paragraphStyle) Size() int <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.runSize
}</span>

// SetSize sets the default run font size in half-points.
func (ps *paragraphStyle) SetSize(halfPoints int) error <span class="cov8" title="1">{
        if halfPoints &lt; constants.MinFontSize || halfPoints &gt; constants.MaxFontSize </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetSize",
                        "halfPoints",
                        halfPoints,
                        "font size must be between 2 and 3276 half-points (1pt - 1638pt)",
                )
        }</span>

        <span class="cov8" title="1">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.runSize = halfPoints
        return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package manager

import (
        "strings"
        "sync"

        "github.com/mmonterroca/docxgo/internal/xml"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// Relationship represents an OOXML relationship.
type Relationship struct {
        ID         string // Relationship ID (e.g., "rId1")
        Type       string // Relationship type (e.g., "http://schemas.openxmlformats.org/.../image")
        Target     string // Target path (e.g., "media/image1.png")
        TargetMode string // "Internal" or "External"
}

// RelationshipManager manages relationships for a document part.
// It is thread-safe.
type RelationshipManager struct {
        mu            sync.RWMutex
        relationships map[string]*Relationship // key is ID
        idGen         *IDGenerator
}

// NewRelationshipManager creates a new relationship manager.
func NewRelationshipManager(idGen *IDGenerator) *RelationshipManager <span class="cov0" title="0">{
        return &amp;RelationshipManager{
                relationships: make(map[string]*Relationship, constants.DefaultRelCapacity),
                idGen:         idGen,
        }
}</span>

// Add adds a new relationship and returns its ID.
func (rm *RelationshipManager) Add(relType, target, targetMode string) (string, error) <span class="cov0" title="0">{
        if relType == "" </span><span class="cov0" title="0">{
                return "", errors.InvalidArgument("RelationshipManager.Add", "relType", relType, "relationship type cannot be empty")
        }</span>
        <span class="cov0" title="0">if target == "" </span><span class="cov0" title="0">{
                return "", errors.InvalidArgument("RelationshipManager.Add", "target", target, "target cannot be empty")
        }</span>

        <span class="cov0" title="0">rm.mu.Lock()
        defer rm.mu.Unlock()

        // Generate new ID
        id := rm.idGen.NextRelID()

        // Only "External" requires TargetMode attribute. For internal
        // relationships Word expects the attribute to be omitted entirely.
        mode := strings.TrimSpace(targetMode)
        if strings.EqualFold(mode, "internal") || mode == "" </span><span class="cov0" title="0">{
                mode = ""
        }</span>

        <span class="cov0" title="0">rel := &amp;Relationship{
                ID:         id,
                Type:       relType,
                Target:     target,
                TargetMode: mode,
        }

        rm.relationships[id] = rel
        return id, nil</span>
}

// Get retrieves a relationship by ID.
func (rm *RelationshipManager) Get(id string) (*Relationship, error) <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rel, exists := rm.relationships[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NotFound("RelationshipManager.Get", "relationship")
        }</span>

        <span class="cov0" title="0">return rel, nil</span>
}

// GetByTarget retrieves a relationship by target path.
// Returns the first relationship matching the target.
func (rm *RelationshipManager) GetByTarget(target string) (*Relationship, error) <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        for _, rel := range rm.relationships </span><span class="cov0" title="0">{
                if rel.Target == target </span><span class="cov0" title="0">{
                        return rel, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.NotFound("RelationshipManager.GetByTarget", "relationship")</span>
}

// All returns all relationships.
func (rm *RelationshipManager) All() []*Relationship <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rels := make([]*Relationship, 0, len(rm.relationships))
        for _, rel := range rm.relationships </span><span class="cov0" title="0">{
                rels = append(rels, rel)
        }</span>

        <span class="cov0" title="0">return rels</span>
}

// Count returns the number of relationships.
func (rm *RelationshipManager) Count() int <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        return len(rm.relationships)
}</span>

// Delete removes a relationship by ID.
func (rm *RelationshipManager) Delete(id string) error <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        if _, exists := rm.relationships[id]; !exists </span><span class="cov0" title="0">{
                return errors.NotFound("RelationshipManager.Delete", "relationship")
        }</span>

        <span class="cov0" title="0">delete(rm.relationships, id)
        return nil</span>
}

// AddImage adds an image relationship.
func (rm *RelationshipManager) AddImage(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeImage, target, "Internal")
}</span>

// AddHyperlink adds a hyperlink relationship.
func (rm *RelationshipManager) AddHyperlink(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeHyperlink, target, "External")
}</span>

// AddHeader adds a header relationship.
func (rm *RelationshipManager) AddHeader(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeHeader, target, "Internal")
}</span>

// AddFooter adds a footer relationship.
func (rm *RelationshipManager) AddFooter(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeFooter, target, "Internal")
}</span>

// ToXML converts relationships to XML structure.
func (rm *RelationshipManager) ToXML() *xml.Relationships <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rels := &amp;xml.Relationships{
                Xmlns:         constants.NamespacePackageRels,
                Relationships: make([]*xml.Relationship, 0, len(rm.relationships)),
        }

        for _, rel := range rm.relationships </span><span class="cov0" title="0">{
                xmlRel := &amp;xml.Relationship{
                        ID:         rel.ID,
                        Type:       rel.Type,
                        Target:     rel.Target,
                        TargetMode: rel.TargetMode,
                }
                rels.Relationships = append(rels.Relationships, xmlRel)
        }</span>

        <span class="cov0" title="0">return rels</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// styleManager implements domain.StyleManager.
type styleManager struct {
        mu              sync.RWMutex
        styles          map[string]domain.Style
        defaultStyles   map[domain.StyleType]string
        builtInStyleIDs map[string]bool
}

// NewStyleManager creates a new StyleManager with built-in styles.
func NewStyleManager() domain.StyleManager <span class="cov8" title="1">{
        sm := &amp;styleManager{
                styles:          make(map[string]domain.Style),
                defaultStyles:   make(map[domain.StyleType]string),
                builtInStyleIDs: make(map[string]bool),
        }

        // Initialize built-in styles
        sm.initializeBuiltInStyles()

        return sm
}</span>

// initializeBuiltInStyles creates all built-in OOXML styles.
func (sm *styleManager) initializeBuiltInStyles() <span class="cov8" title="1">{
        // Mark built-in paragraph style IDs
        builtInParagraphStyles := []string{
                domain.StyleIDNormal,
                domain.StyleIDHeading1, domain.StyleIDHeading2, domain.StyleIDHeading3,
                domain.StyleIDHeading4, domain.StyleIDHeading5, domain.StyleIDHeading6,
                domain.StyleIDHeading7, domain.StyleIDHeading8, domain.StyleIDHeading9,
                domain.StyleIDTitle, domain.StyleIDSubtitle,
                domain.StyleIDQuote, domain.StyleIDIntenseQuote,
                domain.StyleIDListParagraph, domain.StyleIDCaption,
                domain.StyleIDTOC1, domain.StyleIDTOC2, domain.StyleIDTOC3,
                domain.StyleIDTOC4, domain.StyleIDTOC5, domain.StyleIDTOC6,
                domain.StyleIDTOC7, domain.StyleIDTOC8, domain.StyleIDTOC9,
                domain.StyleIDHeader, domain.StyleIDFooter,
                domain.StyleIDFootnoteText, domain.StyleIDEndnoteText,
                domain.StyleIDBodyText, domain.StyleIDBodyTextIndent,
                domain.StyleIDNoSpacing,
        }

        for _, id := range builtInParagraphStyles </span><span class="cov8" title="1">{
                sm.builtInStyleIDs[id] = true
        }</span>

        // Mark built-in character style IDs
        <span class="cov8" title="1">builtInCharacterStyles := []string{
                domain.StyleIDDefaultParagraphFont,
                domain.StyleIDEmphasis, domain.StyleIDStrong, domain.StyleIDSubtle,
                domain.StyleIDIntenseEmphasis, domain.StyleIDIntenseReference,
                domain.StyleIDBookTitle,
                domain.StyleIDHyperlink, domain.StyleIDFollowedHyperlink,
        }

        for _, id := range builtInCharacterStyles </span><span class="cov8" title="1">{
                sm.builtInStyleIDs[id] = true
        }</span>

        // Mark built-in table style IDs
        <span class="cov8" title="1">builtInTableStyles := []string{
                domain.StyleIDTableNormal,
                domain.StyleIDTableGrid,
                domain.StyleIDTablePlain,
                domain.StyleIDTableMediumShading,
                domain.StyleIDTableLightShading,
                domain.StyleIDTableColorful,
                domain.StyleIDTableAccent1,
                domain.StyleIDTableAccent2,
        }

        for _, id := range builtInTableStyles </span><span class="cov8" title="1">{
                sm.builtInStyleIDs[id] = true
        }</span>

        // Create and add built-in styles
        <span class="cov8" title="1">sm.createBuiltInParagraphStyles()
        sm.createBuiltInCharacterStyles()
        sm.createBuiltInTableStyles()

        // Set default styles
        sm.defaultStyles[domain.StyleTypeParagraph] = domain.StyleIDNormal
        sm.defaultStyles[domain.StyleTypeCharacter] = domain.StyleIDDefaultParagraphFont
        sm.defaultStyles[domain.StyleTypeTable] = domain.StyleIDTableNormal</span>
}

// createBuiltInTableStyles creates all built-in table styles.
// Note: Error returns are intentionally ignored for built-in styles as they
// use only valid, hardcoded values that cannot fail under normal circumstances.
//
//nolint:errcheck // Built-in styles use hardcoded valid values
func (sm *styleManager) createBuiltInTableStyles() <span class="cov8" title="1">{
        styles := []struct {
                id   string
                name string
        }{
                {domain.StyleIDTableNormal, "Table Normal"},
                {domain.StyleIDTableGrid, "Table Grid"},
                {domain.StyleIDTablePlain, "Plain Table 1"},
                {domain.StyleIDTableMediumShading, "Medium Shading 1"},
                {domain.StyleIDTableLightShading, "Light Shading"},
                {domain.StyleIDTableColorful, "Colorful List"},
                {domain.StyleIDTableAccent1, "Medium Shading 1 Accent 1"},
                {domain.StyleIDTableAccent2, "Medium Shading 1 Accent 2"},
        }

        for idx, def := range styles </span><span class="cov8" title="1">{
                style := newTableStyle(def.id, def.name, true)
                if def.id != domain.StyleIDTableNormal </span><span class="cov8" title="1">{
                        style.SetBasedOn(domain.StyleIDTableNormal)
                }</span>
                <span class="cov8" title="1">if idx == 0 </span><span class="cov8" title="1">{ // Table Normal is the default
                        style.SetDefault(true)
                }</span>
                <span class="cov8" title="1">sm.styles[def.id] = style</span>
        }
}

// createBuiltInParagraphStyles creates all built-in paragraph styles.
// Note: Error returns are intentionally ignored for built-in styles as they
// use only valid, hardcoded values that cannot fail under normal circumstances.
//
//nolint:errcheck // Built-in styles use hardcoded valid values
func (sm *styleManager) createBuiltInParagraphStyles() <span class="cov8" title="1">{
        // Normal style (base for all paragraphs)
        normal := newParagraphStyle(domain.StyleIDNormal, "Normal", true)
        normal.SetAlignment(domain.AlignmentLeft)
        normal.SetDefault(true)
        sm.styles[domain.StyleIDNormal] = normal

        // Heading styles
        // Note: outlineLevel is 0-based (0 for Heading 1, 1 for Heading 2, etc.)
        // This is required for TOC functionality - Word uses outline levels to build TOC
        headings := []struct {
                id           string
                name         string
                outlineLevel int
                size         int // in half-points
                bold         bool
        }{
                {domain.StyleIDHeading1, "Heading 1", 0, 32, true},  // 16pt, outline level 0
                {domain.StyleIDHeading2, "Heading 2", 1, 26, true},  // 13pt, outline level 1
                {domain.StyleIDHeading3, "Heading 3", 2, 24, true},  // 12pt, outline level 2
                {domain.StyleIDHeading4, "Heading 4", 3, 24, true},  // 12pt, outline level 3
                {domain.StyleIDHeading5, "Heading 5", 4, 22, true},  // 11pt, outline level 4
                {domain.StyleIDHeading6, "Heading 6", 5, 22, false}, // 11pt, outline level 5
                {domain.StyleIDHeading7, "Heading 7", 6, 22, false}, // 11pt, outline level 6
                {domain.StyleIDHeading8, "Heading 8", 7, 22, false}, // 11pt, outline level 7
                {domain.StyleIDHeading9, "Heading 9", 8, 22, false}, // 11pt, outline level 8
        }

        for _, h := range headings </span><span class="cov8" title="1">{
                style := newParagraphStyle(h.id, h.name, true)
                style.SetBasedOn(domain.StyleIDNormal)
                style.SetOutlineLevel(h.outlineLevel)
                style.SetSpacingBefore(240) // 240 twips = 12pt
                style.SetSpacingAfter(120)  // 120 twips = 6pt
                style.SetKeepNext(true)
                style.SetKeepLines(true)

                font := domain.Font{Name: "Calibri Light"}
                style.SetFont(font)
                style.SetSize(h.size)
                style.SetBold(h.bold)

                sm.styles[h.id] = style
        }</span>

        // Title and Subtitle
        <span class="cov8" title="1">title := newParagraphStyle(domain.StyleIDTitle, "Title", true)
        title.SetBasedOn(domain.StyleIDNormal)
        title.SetAlignment(domain.AlignmentCenter)
        title.SetSpacingAfter(180)
        title.SetFont(domain.Font{Name: "Calibri Light"})
        title.SetSize(52) // 26pt
        title.SetBold(true)
        sm.styles[domain.StyleIDTitle] = title

        subtitle := newParagraphStyle(domain.StyleIDSubtitle, "Subtitle", true)
        subtitle.SetBasedOn(domain.StyleIDNormal)
        subtitle.SetAlignment(domain.AlignmentCenter)
        subtitle.SetFont(domain.Font{Name: "Calibri"})
        subtitle.SetSize(28) // 14pt
        subtitle.SetItalic(true)
        subtitle.SetColor(domain.Color{R: 90, G: 90, B: 90})
        sm.styles[domain.StyleIDSubtitle] = subtitle

        // Quote styles
        quote := newParagraphStyle(domain.StyleIDQuote, "Quote", true)
        quote.SetBasedOn(domain.StyleIDNormal)
        quote.SetIndentation(domain.Indentation{Left: 720, Right: 720}) // 0.5 inch
        quote.SetItalic(true)
        quote.SetColor(domain.Color{R: 89, G: 89, B: 89})
        sm.styles[domain.StyleIDQuote] = quote

        intenseQuote := newParagraphStyle(domain.StyleIDIntenseQuote, "Intense Quote", true)
        intenseQuote.SetBasedOn(domain.StyleIDNormal)
        intenseQuote.SetIndentation(domain.Indentation{Left: 720, Right: 720})
        intenseQuote.SetSpacingBefore(120)
        intenseQuote.SetSpacingAfter(120)
        intenseQuote.SetAlignment(domain.AlignmentCenter)
        intenseQuote.SetItalic(true)
        intenseQuote.SetBold(true)
        intenseQuote.SetColor(domain.Color{R: 79, G: 129, B: 189})
        intenseQuote.SetSize(28) // 14pt
        sm.styles[domain.StyleIDIntenseQuote] = intenseQuote

        // List Paragraph
        listPara := newParagraphStyle(domain.StyleIDListParagraph, "List Paragraph", true)
        listPara.SetBasedOn(domain.StyleIDNormal)
        listPara.SetIndentation(domain.Indentation{Left: 720})
        listPara.SetSpacingAfter(80)
        sm.styles[domain.StyleIDListParagraph] = listPara

        // Caption style (used for figure/table captions)
        caption := newParagraphStyle(domain.StyleIDCaption, "caption", true)
        caption.SetBasedOn(domain.StyleIDNormal)
        caption.SetNext(domain.StyleIDNormal)
        caption.SetSpacingAfter(200)
        caption.SetItalic(true)
        sm.styles[domain.StyleIDCaption] = caption

        // TOC styles
        // Note: TOC styles format the table of contents entries after generation
        // outlineLevel matches the TOC level (0-based: TOC1=0, TOC2=1, etc.)
        for i := 1; i &lt;= 9; i++ </span><span class="cov8" title="1">{
                id := ""
                name := ""
                switch i </span>{
                case 1:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC1, "TOC 1"</span>
                case 2:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC2, "TOC 2"</span>
                case 3:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC3, "TOC 3"</span>
                case 4:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC4, "TOC 4"</span>
                case 5:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC5, "TOC 5"</span>
                case 6:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC6, "TOC 6"</span>
                case 7:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC7, "TOC 7"</span>
                case 8:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC8, "TOC 8"</span>
                case 9:<span class="cov8" title="1">
                        id, name = domain.StyleIDTOC9, "TOC 9"</span>
                }
                <span class="cov8" title="1">tocStyle := newParagraphStyle(id, name, true)
                tocStyle.SetBasedOn(domain.StyleIDNormal)
                tocStyle.SetOutlineLevel(i - 1) // 0-based: TOC 1 = level 0, TOC 2 = level 1, etc.
                tocStyle.SetIndentation(domain.Indentation{Left: (i - 1) * 220})
                sm.styles[id] = tocStyle</span>
        }

        // Header and Footer
        <span class="cov8" title="1">header := newParagraphStyle(domain.StyleIDHeader, "Header", true)
        header.SetBasedOn(domain.StyleIDNormal)
        header.SetSize(20) // 10pt
        sm.styles[domain.StyleIDHeader] = header

        footer := newParagraphStyle(domain.StyleIDFooter, "Footer", true)
        footer.SetBasedOn(domain.StyleIDNormal)
        footer.SetSize(20)
        sm.styles[domain.StyleIDFooter] = footer

        // Body Text variants
        bodyText := newParagraphStyle(domain.StyleIDBodyText, "Body Text", true)
        bodyText.SetBasedOn(domain.StyleIDNormal)
        sm.styles[domain.StyleIDBodyText] = bodyText

        noSpacing := newParagraphStyle(domain.StyleIDNoSpacing, "No Spacing", true)
        noSpacing.SetBasedOn(domain.StyleIDNormal)
        noSpacing.SetSpacingBefore(0)
        noSpacing.SetSpacingAfter(0)
        sm.styles[domain.StyleIDNoSpacing] = noSpacing</span>
}

// createBuiltInCharacterStyles creates all built-in character styles.
// Note: Error returns are intentionally ignored for built-in styles as they
// use only valid, hardcoded values that cannot fail under normal circumstances.
//
//nolint:errcheck // Built-in styles use hardcoded valid values
func (sm *styleManager) createBuiltInCharacterStyles() <span class="cov8" title="1">{
        // Default Paragraph Font (base for all character styles)
        defaultFont := newCharacterStyle(domain.StyleIDDefaultParagraphFont, "Default Paragraph Font", true)
        defaultFont.SetDefault(true)
        sm.styles[domain.StyleIDDefaultParagraphFont] = defaultFont

        // Emphasis (italic)
        emphasis := newCharacterStyle(domain.StyleIDEmphasis, "Emphasis", true)
        emphasis.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        emphasis.SetItalic(true)
        sm.styles[domain.StyleIDEmphasis] = emphasis

        // Strong (bold)
        strong := newCharacterStyle(domain.StyleIDStrong, "Strong", true)
        strong.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        strong.SetBold(true)
        sm.styles[domain.StyleIDStrong] = strong

        // Hyperlink (blue, underlined)
        hyperlink := newCharacterStyle(domain.StyleIDHyperlink, "Hyperlink", true)
        hyperlink.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        hyperlink.SetColor(domain.Color{R: 0, G: 0, B: 255}) // Blue
        hyperlink.SetUnderline(domain.UnderlineSingle)
        sm.styles[domain.StyleIDHyperlink] = hyperlink

        // Followed Hyperlink (purple, underlined)
        followedHyperlink := newCharacterStyle(domain.StyleIDFollowedHyperlink, "Followed Hyperlink", true)
        followedHyperlink.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        followedHyperlink.SetColor(domain.Color{R: 128, G: 0, B: 128}) // Purple
        followedHyperlink.SetUnderline(domain.UnderlineSingle)
        sm.styles[domain.StyleIDFollowedHyperlink] = followedHyperlink
}</span>

// GetStyle retrieves a style by ID.
func (sm *styleManager) GetStyle(styleID string) (domain.Style, error) <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        style, exists := sm.styles[styleID]
        if !exists </span><span class="cov8" title="1">{
                return nil, errors.NewNotFoundError(
                        "StyleManager.GetStyle",
                        "style",
                        styleID,
                        "style not found",
                )
        }</span>

        <span class="cov8" title="1">return style, nil</span>
}

// AddStyle adds a new custom style.
func (sm *styleManager) AddStyle(style domain.Style) error <span class="cov8" title="1">{
        if style == nil </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "style",
                        nil,
                        "style cannot be nil",
                )
        }</span>

        <span class="cov8" title="1">styleID := style.ID()
        if styleID == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "style.ID",
                        "",
                        "style ID cannot be empty",
                )
        }</span>

        <span class="cov8" title="1">sm.mu.Lock()
        defer sm.mu.Unlock()

        // Check if it's a built-in style
        if sm.builtInStyleIDs[styleID] </span><span class="cov8" title="1">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "styleID",
                        styleID,
                        "cannot override built-in style",
                )
        }</span>

        // Check if already exists
        <span class="cov8" title="1">if _, exists := sm.styles[styleID]; exists </span><span class="cov8" title="1">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "styleID",
                        styleID,
                        "style already exists",
                )
        }</span>

        <span class="cov8" title="1">sm.styles[styleID] = style
        return nil</span>
}

// RemoveStyle removes a custom style.
func (sm *styleManager) RemoveStyle(styleID string) error <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Cannot remove built-in styles
        if sm.builtInStyleIDs[styleID] </span><span class="cov8" title="1">{
                return errors.NewValidationError(
                        "StyleManager.RemoveStyle",
                        "styleID",
                        styleID,
                        "cannot remove built-in style",
                )
        }</span>

        <span class="cov8" title="1">if _, exists := sm.styles[styleID]; !exists </span><span class="cov8" title="1">{
                return errors.NewNotFoundError(
                        "StyleManager.RemoveStyle",
                        "style",
                        styleID,
                        "style not found",
                )
        }</span>

        <span class="cov8" title="1">delete(sm.styles, styleID)
        return nil</span>
}

// ListStyles returns all available styles.
func (sm *styleManager) ListStyles() []domain.Style <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        styles := make([]domain.Style, 0, len(sm.styles))
        for _, style := range sm.styles </span><span class="cov8" title="1">{
                styles = append(styles, style)
        }</span>

        <span class="cov8" title="1">return styles</span>
}

// ListStylesByType returns all styles of a specific type.
func (sm *styleManager) ListStylesByType(styleType domain.StyleType) []domain.Style <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        styles := make([]domain.Style, 0)
        for _, style := range sm.styles </span><span class="cov8" title="1">{
                if style.Type() == styleType </span><span class="cov8" title="1">{
                        styles = append(styles, style)
                }</span>
        }

        <span class="cov8" title="1">return styles</span>
}

// DefaultStyle returns the default style for a type.
func (sm *styleManager) DefaultStyle(styleType domain.StyleType) (domain.Style, error) <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        styleID, exists := sm.defaultStyles[styleType]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NewNotFoundError(
                        "StyleManager.DefaultStyle",
                        "default style",
                        styleType,
                        "no default style set for type",
                )
        }</span>

        <span class="cov8" title="1">return sm.styles[styleID], nil</span>
}

// SetDefaultStyle sets the default style for a type.
func (sm *styleManager) SetDefaultStyle(styleType domain.StyleType, styleID string) error <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Verify style exists
        style, exists := sm.styles[styleID]
        if !exists </span><span class="cov8" title="1">{
                return errors.NewNotFoundError(
                        "StyleManager.SetDefaultStyle",
                        "style",
                        styleID,
                        "style not found",
                )
        }</span>

        // Verify style type matches
        <span class="cov8" title="1">if style.Type() != styleType </span><span class="cov8" title="1">{
                return errors.NewValidationError(
                        "StyleManager.SetDefaultStyle",
                        "styleType",
                        styleType,
                        "style type mismatch",
                )
        }</span>

        <span class="cov8" title="1">sm.defaultStyles[styleType] = styleID
        return nil</span>
}

// HasStyle checks if a style exists.
func (sm *styleManager) HasStyle(styleID string) bool <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        _, exists := sm.styles[styleID]
        return exists
}</span>

// IsBuiltIn checks if a style is built-in (not custom).
func (sm *styleManager) IsBuiltIn(styleID string) bool <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        return sm.builtInStyleIDs[styleID]
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// tableStyle implements domain.Style for table styles.
type tableStyle struct {
        mu        sync.RWMutex
        id        string
        name      string
        basedOn   string
        next      string
        font      domain.Font
        isDefault bool
        isBuiltIn bool
}

// newTableStyle creates a new table style.
// Note: builtIn parameter is used in tests to create custom styles.
func newTableStyle(id, name string, builtIn bool) *tableStyle <span class="cov8" title="1">{
        return &amp;tableStyle{
                id:        id,
                name:      name,
                next:      "",
                font:      domain.Font{Name: constants.DefaultFontName},
                isBuiltIn: builtIn,
        }
}</span>

// ID returns the style identifier.
func (ts *tableStyle) ID() string <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.id
}</span>

// Name returns the localized style name.
func (ts *tableStyle) Name() string <span class="cov0" title="0">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.name
}</span>

// Type identifies the style as a table style.
func (ts *tableStyle) Type() domain.StyleType <span class="cov8" title="1">{
        return domain.StyleTypeTable
}</span>

// BasedOn returns the parent style identifier.
func (ts *tableStyle) BasedOn() string <span class="cov0" title="0">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.basedOn
}</span>

// SetBasedOn sets the parent style identifier.
func (ts *tableStyle) SetBasedOn(styleID string) error <span class="cov8" title="1">{
        ts.mu.Lock()
        defer ts.mu.Unlock()
        ts.basedOn = styleID
        return nil
}</span>

// Next returns the recommended follow-on style identifier.
func (ts *tableStyle) Next() string <span class="cov0" title="0">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.next
}</span>

// SetNext sets the recommended follow-on style identifier.
func (ts *tableStyle) SetNext(styleID string) error <span class="cov0" title="0">{
        ts.mu.Lock()
        defer ts.mu.Unlock()
        ts.next = styleID
        return nil
}</span>

// Font returns the default font metadata associated with the style.
func (ts *tableStyle) Font() domain.Font <span class="cov0" title="0">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.font
}</span>

// SetFont updates the default font metadata for the style.
func (ts *tableStyle) SetFont(font domain.Font) error <span class="cov0" title="0">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "TableStyle.SetFont",
                        "font.Name",
                        "",
                        "font name cannot be empty",
                )
        }</span>

        <span class="cov0" title="0">ts.mu.Lock()
        defer ts.mu.Unlock()
        ts.font = font
        return nil</span>
}

// IsDefault reports whether this style is the default for tables.
func (ts *tableStyle) IsDefault() bool <span class="cov0" title="0">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.isDefault
}</span>

// SetDefault marks this style as default for its type.
func (ts *tableStyle) SetDefault(isDefault bool) error <span class="cov8" title="1">{
        ts.mu.Lock()
        defer ts.mu.Unlock()
        ts.isDefault = isDefault
        return nil
}</span>

// IsCustom reports whether the style is user-defined.
func (ts *tableStyle) IsCustom() bool <span class="cov0" title="0">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return !ts.isBuiltIn
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package serializer converts domain objects into XML structures for OOXML serialization.
// It provides serializers for documents, paragraphs, runs, tables, and other document elements.
package serializer

/*
   Copyright (c) 2025 Misael Monterroca

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published
   by the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
*/

import (
        "fmt"
        "strings"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/xml"
        "github.com/mmonterroca/docxgo/pkg/color"
        "github.com/mmonterroca/docxgo/pkg/constants"
)

type drawingIDProvider interface {
        NextDrawingID() int
}

// RunSerializer converts a domain.Run to xml.Run
type RunSerializer struct {
        idProvider drawingIDProvider
}

// NewRunSerializer creates a new RunSerializer.
func NewRunSerializer() *RunSerializer <span class="cov8" title="1">{
        return &amp;RunSerializer{}
}</span>

// SetDrawingIDProvider injects a provider for generating unique drawing IDs.
func (s *RunSerializer) SetDrawingIDProvider(provider drawingIDProvider) <span class="cov8" title="1">{
        s.idProvider = provider
}</span>

// Serialize converts a domain.Run to xml.Run.
func (s *RunSerializer) Serialize(run domain.Run) *xml.Run <span class="cov8" title="1">{
        xmlRun := &amp;xml.Run{
                Properties: s.serializeProperties(run),
                Text:       s.serializeText(run),
        }

        if imageProvider, ok := run.(interface{ Image() domain.Image }); ok </span><span class="cov8" title="1">{
                if img := imageProvider.Image(); img != nil </span><span class="cov0" title="0">{
                        drawingID := 1
                        if s.idProvider != nil </span><span class="cov0" title="0">{
                                drawingID = s.idProvider.NextDrawingID()
                        }</span>
                        <span class="cov0" title="0">xmlRun.Drawing = s.serializeDrawing(img, drawingID)
                        // For image runs we don't include text content.
                        xmlRun.Text = nil</span>
                }
        }

        // Add breaks if any
        <span class="cov8" title="1">if breaks := run.(interface{ Breaks() []domain.BreakType }).Breaks(); breaks != nil </span><span class="cov0" title="0">{
                for _, br := range breaks </span><span class="cov0" title="0">{
                        xmlRun.Break = s.serializeBreak(br)
                }</span>
        }

        <span class="cov8" title="1">return xmlRun</span>
}

func (s *RunSerializer) serializeDrawing(img domain.Image, drawingID int) *xml.Drawing <span class="cov0" title="0">{
        if img == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">pos := img.Position()
        if pos.Type == domain.ImagePositionFloating </span><span class="cov0" title="0">{
                return xml.NewFloatingDrawing(img, drawingID)
        }</span>
        <span class="cov0" title="0">return xml.NewInlineDrawing(img, drawingID)</span>
}

func (s *RunSerializer) serializeProperties(run domain.Run) *xml.RunProperties <span class="cov8" title="1">{
        props := &amp;xml.RunProperties{}

        // Bold
        if run.Bold() </span><span class="cov8" title="1">{
                props.Bold = &amp;xml.BoolValue{Val: boolPtr(true)}
        }</span>

        // Italic
        <span class="cov8" title="1">if run.Italic() </span><span class="cov8" title="1">{
                props.Italic = &amp;xml.BoolValue{Val: boolPtr(true)}
        }</span>

        // Strike
        <span class="cov8" title="1">if run.Strike() </span><span class="cov0" title="0">{
                props.Strike = &amp;xml.BoolValue{Val: boolPtr(true)}
        }</span>

        // Underline
        <span class="cov8" title="1">if run.Underline() != domain.UnderlineNone </span><span class="cov0" title="0">{
                props.Underline = &amp;xml.Underline{
                        Val: s.underlineStyleToString(run.Underline()),
                }
        }</span>

        // Color
        <span class="cov8" title="1">if run.Color() != domain.ColorBlack </span><span class="cov8" title="1">{
                props.Color = &amp;xml.Color{
                        Val: color.ToHex(run.Color()),
                }
        }</span>

        // Font size
        <span class="cov8" title="1">if run.Size() != constants.DefaultFontSize </span><span class="cov8" title="1">{
                props.Size = &amp;xml.HalfPt{Val: run.Size()}
                props.SizeCS = &amp;xml.HalfPt{Val: run.Size()}
        }</span>

        // Font
        <span class="cov8" title="1">font := run.Font()
        if font.Name != "" &amp;&amp; font.Name != constants.DefaultFontName </span><span class="cov0" title="0">{
                props.Font = &amp;xml.Font{
                        ASCII:    font.Name,
                        HAnsi:    font.Name,
                        EastAsia: font.EastAsia,
                        CS:       font.CS,
                }
        }</span>

        // Highlight
        <span class="cov8" title="1">if run.Highlight() != domain.HighlightNone </span><span class="cov0" title="0">{
                props.Highlight = &amp;xml.Highlight{
                        Val: s.highlightColorToString(run.Highlight()),
                }
        }</span>

        <span class="cov8" title="1">return props</span>
}

func (s *RunSerializer) serializeText(run domain.Run) *xml.Text <span class="cov8" title="1">{
        return s.serializeTextContent(run.Text())
}</span>

func (s *RunSerializer) serializeTextContent(text string) *xml.Text <span class="cov8" title="1">{
        if text == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">xmlText := &amp;xml.Text{
                Content: text,
        }

        if len(text) &gt; 0 &amp;&amp; (text[0] == ' ' || text[len(text)-1] == ' ') </span><span class="cov8" title="1">{
                xmlText.Space = "preserve"
        }</span>

        <span class="cov8" title="1">return xmlText</span>
}

func (s *RunSerializer) serializeBreak(breakType domain.BreakType) *xml.Break <span class="cov0" title="0">{
        xmlBreak := &amp;xml.Break{}

        switch breakType </span>{
        case domain.BreakTypePage:<span class="cov0" title="0">
                xmlBreak.Type = "page"</span>
        case domain.BreakTypeColumn:<span class="cov0" title="0">
                xmlBreak.Type = "column"</span>
        case domain.BreakTypeLine:<span class="cov0" title="0">
                xmlBreak.Type = "textWrapping"</span>
        default:<span class="cov0" title="0">
                xmlBreak.Type = "textWrapping"</span>
        }

        <span class="cov0" title="0">return xmlBreak</span>
}

func (s *RunSerializer) underlineStyleToString(style domain.UnderlineStyle) string <span class="cov0" title="0">{
        switch style </span>{
        case domain.UnderlineNone:<span class="cov0" title="0">
                return constants.UnderlineValueNone</span>
        case domain.UnderlineSingle:<span class="cov0" title="0">
                return constants.UnderlineValueSingle</span>
        case domain.UnderlineDouble:<span class="cov0" title="0">
                return constants.UnderlineValueDouble</span>
        case domain.UnderlineThick:<span class="cov0" title="0">
                return constants.UnderlineValueThick</span>
        case domain.UnderlineDotted:<span class="cov0" title="0">
                return constants.UnderlineValueDotted</span>
        case domain.UnderlineDashed:<span class="cov0" title="0">
                return constants.UnderlineValueDashed</span>
        case domain.UnderlineWave:<span class="cov0" title="0">
                return constants.UnderlineValueWave</span>
        default:<span class="cov0" title="0">
                return constants.UnderlineValueSingle</span>
        }
}

func (s *RunSerializer) highlightColorToString(hlColor domain.HighlightColor) string <span class="cov0" title="0">{
        switch hlColor </span>{
        case domain.HighlightNone:<span class="cov0" title="0">
                return constants.HighlightValueNone</span>
        case domain.HighlightYellow:<span class="cov0" title="0">
                return constants.HighlightValueYellow</span>
        case domain.HighlightGreen:<span class="cov0" title="0">
                return constants.HighlightValueGreen</span>
        case domain.HighlightCyan:<span class="cov0" title="0">
                return constants.HighlightValueCyan</span>
        case domain.HighlightMagenta:<span class="cov0" title="0">
                return constants.HighlightValueMagenta</span>
        case domain.HighlightBlue:<span class="cov0" title="0">
                return constants.HighlightValueBlue</span>
        case domain.HighlightRed:<span class="cov0" title="0">
                return constants.HighlightValueRed</span>
        case domain.HighlightDarkBlue:<span class="cov0" title="0">
                return constants.HighlightValueDarkBlue</span>
        case domain.HighlightDarkCyan:<span class="cov0" title="0">
                return constants.HighlightValueDarkCyan</span>
        case domain.HighlightDarkGreen:<span class="cov0" title="0">
                return constants.HighlightValueDarkGreen</span>
        case domain.HighlightDarkMagenta:<span class="cov0" title="0">
                return constants.HighlightValueDarkMagenta</span>
        case domain.HighlightDarkRed:<span class="cov0" title="0">
                return constants.HighlightValueDarkRed</span>
        case domain.HighlightDarkYellow:<span class="cov0" title="0">
                return constants.HighlightValueDarkYellow</span>
        case domain.HighlightDarkGray:<span class="cov0" title="0">
                return constants.HighlightValueDarkGray</span>
        case domain.HighlightLightGray:<span class="cov0" title="0">
                return constants.HighlightValueLightGray</span>
        default:<span class="cov0" title="0">
                return constants.HighlightValueNone</span>
        }
}

// ParagraphSerializer converts a domain.Paragraph to xml.Paragraph
type ParagraphSerializer struct {
        runSerializer *RunSerializer
}

// NewParagraphSerializer creates a new ParagraphSerializer.
func NewParagraphSerializer() *ParagraphSerializer <span class="cov8" title="1">{
        return &amp;ParagraphSerializer{
                runSerializer: NewRunSerializer(),
        }
}</span>

// Serialize converts a domain.Paragraph to xml.Paragraph.
func (s *ParagraphSerializer) Serialize(para domain.Paragraph) *xml.Paragraph <span class="cov8" title="1">{
        xmlPara := &amp;xml.Paragraph{
                Properties: s.serializeProperties(para),
                Elements:   make([]interface{}, 0, len(para.Runs())+2),
        }

        // Add bookmark if this paragraph has one (needed for TOC)
        if corePara, ok := para.(interface {
                BookmarkID() string
                BookmarkName() string
        }); ok </span><span class="cov8" title="1">{
                if bookmarkID := corePara.BookmarkID(); bookmarkID != "" </span><span class="cov0" title="0">{
                        xmlPara.Elements = append(xmlPara.Elements, &amp;xml.BookmarkStart{
                                ID:   bookmarkID,
                                Name: corePara.BookmarkName(),
                        })
                }</span>
        }

        // Serialize runs - expand runs with fields into multiple XML runs
        <span class="cov8" title="1">for _, run := range para.Runs() </span><span class="cov8" title="1">{
                // Check if run has fields
                if runWithFields, ok := run.(interface{ Fields() []domain.Field }); ok </span><span class="cov8" title="1">{
                        fields := runWithFields.Fields()
                        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                                // Expand run with fields into multiple XML runs
                                xmlPara.Elements = append(xmlPara.Elements, s.expandRunWithFields(run, fields)...)
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if text := run.Text(); strings.Contains(text, "\n") </span><span class="cov0" title="0">{
                        xmlPara.Elements = append(xmlPara.Elements, s.expandRunWithNewlines(run, text)...)
                        continue</span>
                }

                // Regular run without fields
                <span class="cov8" title="1">xmlPara.Elements = append(xmlPara.Elements, s.runSerializer.Serialize(run))</span>
        }

        // Add bookmark end if this paragraph has a bookmark
        <span class="cov8" title="1">if corePara, ok := para.(interface{ BookmarkID() string }); ok </span><span class="cov8" title="1">{
                if bookmarkID := corePara.BookmarkID(); bookmarkID != "" </span><span class="cov0" title="0">{
                        xmlPara.Elements = append(xmlPara.Elements, &amp;xml.BookmarkEnd{ID: bookmarkID})
                }</span>
        }

        <span class="cov8" title="1">return xmlPara</span>
}

func (s *ParagraphSerializer) expandRunWithNewlines(run domain.Run, text string) []interface{} <span class="cov0" title="0">{
        parts := strings.Split(text, "\n")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return []interface{}{s.runSerializer.Serialize(run)}
        }</span>

        <span class="cov0" title="0">result := make([]interface{}, 0, len(parts)*2-1)

        var (
                setter   func(string) error
                restore  func()
                canSet   bool
                original string
        )

        if s, ok := run.(interface{ SetText(string) error }); ok </span><span class="cov0" title="0">{
                canSet = true
                original = run.Text()
                setter = s.SetText
                restore = func() </span><span class="cov0" title="0">{
                        _ = setter(original)
                }</span>
        }

        <span class="cov0" title="0">for idx, part := range parts </span><span class="cov0" title="0">{
                var xmlRun *xml.Run

                if canSet </span><span class="cov0" title="0">{
                        _ = setter(part)
                        xmlRun = s.runSerializer.Serialize(run)
                }</span> else<span class="cov0" title="0"> {
                        xmlRun = &amp;xml.Run{
                                Properties: s.runSerializer.serializeProperties(run),
                                Text:       s.runSerializer.serializeTextContent(part),
                        }
                }</span>

                <span class="cov0" title="0">if idx &lt; len(parts)-1 </span><span class="cov0" title="0">{
                        xmlRun.Break = &amp;xml.Break{}
                }</span>

                <span class="cov0" title="0">result = append(result, xmlRun)</span>
        }

        <span class="cov0" title="0">if canSet &amp;&amp; restore != nil </span><span class="cov0" title="0">{
                restore()
        }</span>

        <span class="cov0" title="0">return result</span>
}

// expandRunWithFields expands a run containing fields into XML elements while preserving formatting.
// The returned slice may include runs, hyperlinks, and field components.
func (s *ParagraphSerializer) expandRunWithFields(run domain.Run, fields []domain.Field) []interface{} <span class="cov0" title="0">{
        elements := make([]interface{}, 0, len(fields)*5)

        for _, field := range fields </span><span class="cov0" title="0">{
                wasDirty := false
                if dirtyChecker, ok := field.(interface{ IsDirty() bool }); ok </span><span class="cov0" title="0">{
                        wasDirty = dirtyChecker.IsDirty()
                }</span>
                <span class="cov0" title="0">if updater, ok := field.(interface{ Update() error }); ok </span><span class="cov0" title="0">{
                        _ = updater.Update()
                        if wasDirty </span><span class="cov0" title="0">{
                                if marker, ok := field.(interface{ MarkDirty() }); ok </span><span class="cov0" title="0">{
                                        marker.MarkDirty()
                                }</span>
                        }
                }

                <span class="cov0" title="0">switch field.Type() </span>{ //nolint:exhaustive // Only Hyperlink needs special handling; others use standard field serialization below
                case domain.FieldTypeHyperlink:<span class="cov0" title="0">
                        if accessor, ok := field.(interface {
                                GetProperty(string) (string, bool)
                        }); ok </span><span class="cov0" title="0">{
                                relID, relOK := accessor.GetProperty("relationshipID")
                                if relOK &amp;&amp; relID != "" </span><span class="cov0" title="0">{
                                        display := field.Result()
                                        if display == "" </span><span class="cov0" title="0">{
                                                if disp, ok := accessor.GetProperty("display"); ok </span><span class="cov0" title="0">{
                                                        display = disp
                                                }</span>
                                        }

                                        <span class="cov0" title="0">var xmlRun *xml.Run
                                        if setter, ok := run.(interface{ SetText(string) error }); ok </span><span class="cov0" title="0">{
                                                origText := run.Text()
                                                _ = setter.SetText(display)
                                                xmlRun = s.runSerializer.Serialize(run)
                                                _ = setter.SetText(origText)
                                        }</span> else<span class="cov0" title="0"> {
                                                xmlRun = &amp;xml.Run{
                                                        Properties: s.runSerializer.serializeProperties(run),
                                                        Text:       &amp;xml.Text{Content: display},
                                                }
                                        }</span>

                                        <span class="cov0" title="0">if xmlRun.Text == nil </span><span class="cov0" title="0">{
                                                xmlRun.Text = &amp;xml.Text{Content: display}
                                        }</span> else<span class="cov0" title="0"> {
                                                xmlRun.Text.Content = display
                                        }</span>

                                        <span class="cov0" title="0">xmlRun.FieldChar = nil
                                        xmlRun.InstrText = nil

                                        if xmlRun.Properties == nil </span><span class="cov0" title="0">{
                                                xmlRun.Properties = &amp;xml.RunProperties{}
                                        }</span>
                                        <span class="cov0" title="0">xmlRun.Properties.Style = &amp;xml.RunStyle{Val: "Hyperlink"}

                                        hyperlink := &amp;xml.Hyperlink{
                                                ID:   relID,
                                                Runs: []*xml.Run{xmlRun},
                                        }
                                        elements = append(elements, hyperlink)
                                        continue</span>
                                }
                        }
                default:<span class="cov0" title="0"></span>
                        // Other field types (TOC, PageNumber, Date, etc.) use standard field serialization
                        // which is handled below
                }

                <span class="cov0" title="0">beginRun := &amp;xml.Run{FieldChar: xml.NewFieldBegin()}
                if dirtyField, ok := field.(interface{ IsDirty() bool }); ok </span><span class="cov0" title="0">{
                        if dirtyField.IsDirty() </span><span class="cov0" title="0">{
                                dirty := true
                                beginRun.FieldChar.Dirty = &amp;dirty
                        }</span>
                }
                <span class="cov0" title="0">elements = append(elements, beginRun)

                instrRun := &amp;xml.Run{InstrText: xml.NewInstrText(field.Code())}
                elements = append(elements, instrRun)

                sepRun := &amp;xml.Run{FieldChar: xml.NewFieldSeparate()}
                elements = append(elements, sepRun)

                resultText := field.Result()
                if resultText != "" </span><span class="cov0" title="0">{
                        resultRun := &amp;xml.Run{
                                Properties: s.runSerializer.serializeProperties(run),
                                Text:       &amp;xml.Text{Content: resultText},
                        }
                        elements = append(elements, resultRun)
                }</span>

                <span class="cov0" title="0">endRun := &amp;xml.Run{FieldChar: xml.NewFieldEnd()}
                elements = append(elements, endRun)</span>
        }

        <span class="cov0" title="0">if run.Text() != "" </span><span class="cov0" title="0">{
                elements = append(elements, s.runSerializer.Serialize(run))
        }</span>

        <span class="cov0" title="0">return elements</span>
}

func (s *ParagraphSerializer) serializeProperties(para domain.Paragraph) *xml.ParagraphProperties <span class="cov8" title="1">{
        props := &amp;xml.ParagraphProperties{}

        // Style - access the internal styleName field via type assertion
        if corePara, ok := para.(interface{ StyleName() string }); ok </span><span class="cov8" title="1">{
                if styleName := corePara.StyleName(); styleName != "" </span><span class="cov0" title="0">{
                        props.Style = &amp;xml.ParagraphStyleRef{
                                Val: styleName,
                        }
                }</span>
        }

        // Alignment
        <span class="cov8" title="1">if para.Alignment() != domain.AlignmentLeft </span><span class="cov8" title="1">{
                props.Justification = &amp;xml.Justification{
                        Val: s.alignmentToString(para.Alignment()),
                }
        }</span>

        // Indentation
        <span class="cov8" title="1">indent := para.Indent()
        if indent.Left != 0 || indent.Right != 0 || indent.FirstLine != 0 || indent.Hanging != 0 </span><span class="cov8" title="1">{
                props.Indentation = &amp;xml.Indentation{
                        Left:      intPtrIfNotZero(indent.Left),
                        Right:     intPtrIfNotZero(indent.Right),
                        FirstLine: intPtrIfNotZero(indent.FirstLine),
                        Hanging:   intPtrIfNotZero(indent.Hanging),
                }
        }</span>

        // Spacing
        <span class="cov8" title="1">before := para.SpacingBefore()
        after := para.SpacingAfter()
        lineSpacing := para.LineSpacing()

        if before != 0 || after != 0 || lineSpacing.Value != constants.DefaultLineSpacing </span><span class="cov0" title="0">{
                props.Spacing = &amp;xml.Spacing{
                        Before:   intPtrIfNotZero(before),
                        After:    intPtrIfNotZero(after),
                        Line:     intPtrIfNotZero(lineSpacing.Value),
                        LineRule: s.lineSpacingRuleToString(lineSpacing.Rule),
                }
        }</span>

        <span class="cov8" title="1">return props</span>
}

func (s *ParagraphSerializer) alignmentToString(align domain.Alignment) string <span class="cov8" title="1">{
        switch align </span>{
        case domain.AlignmentLeft:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        case domain.AlignmentCenter:<span class="cov8" title="1">
                return constants.AlignmentValueCenter</span>
        case domain.AlignmentRight:<span class="cov0" title="0">
                return constants.AlignmentValueRight</span>
        case domain.AlignmentJustify:<span class="cov0" title="0">
                return constants.AlignmentValueJustify</span>
        case domain.AlignmentDistribute:<span class="cov0" title="0">
                return constants.AlignmentValueDistribute</span>
        default:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        }
}

func (s *ParagraphSerializer) lineSpacingRuleToString(rule domain.LineSpacingRule) *string <span class="cov0" title="0">{
        var val string
        switch rule </span>{
        case domain.LineSpacingAuto:<span class="cov0" title="0">
                val = constants.LineSpacingRuleAuto</span>
        case domain.LineSpacingExact:<span class="cov0" title="0">
                val = constants.LineSpacingRuleExact</span>
        case domain.LineSpacingAtLeast:<span class="cov0" title="0">
                val = constants.LineSpacingRuleAtLeast</span>
        default:<span class="cov0" title="0">
                val = constants.LineSpacingRuleAuto</span>
        }
        <span class="cov0" title="0">return &amp;val</span>
}

// TableSerializer converts domain tables to XML
type TableSerializer struct {
        paraSerializer *ParagraphSerializer
}

// NewTableSerializer creates a new TableSerializer.
func NewTableSerializer() *TableSerializer <span class="cov8" title="1">{
        return &amp;TableSerializer{
                paraSerializer: NewParagraphSerializer(),
        }
}</span>

// Serialize converts a domain.Table to xml.Table.
func (s *TableSerializer) Serialize(table domain.Table) *xml.Table <span class="cov8" title="1">{
        xmlTable := &amp;xml.Table{
                Properties: s.serializeTableProperties(table),
                Grid:       s.serializeGrid(table),
                Rows:       make([]*xml.TableRow, 0, table.RowCount()),
        }

        // Serialize rows
        for i := 0; i &lt; table.RowCount(); i++ </span><span class="cov8" title="1">{
                row, _ := table.Row(i)
                xmlTable.Rows = append(xmlTable.Rows, s.serializeRow(row))
        }</span>

        <span class="cov8" title="1">return xmlTable</span>
}

func (s *TableSerializer) serializeTableProperties(table domain.Table) *xml.TableProperties <span class="cov8" title="1">{
        props := &amp;xml.TableProperties{}

        // Width
        width := table.Width()
        props.Width = &amp;xml.TableWidth{
                Type: s.widthTypeToString(width.Type),
                W:    width.Value,
        }

        // Default look hints so Word can map header/footer banding expectations.
        props.Look = &amp;xml.TableLook{
                Val:         "04A0",
                FirstRow:    "1",
                LastRow:     "0",
                FirstColumn: "1",
                LastColumn:  "0",
                NoHBand:     "0",
                NoVBand:     "1",
        }

        // Alignment
        if table.Alignment() != domain.AlignmentLeft </span><span class="cov0" title="0">{
                props.Jc = &amp;xml.Justification{
                        Val: s.alignmentToString(table.Alignment()),
                }
        }</span>

        // Style
        <span class="cov8" title="1">if style := table.Style(); style.Name != "" </span><span class="cov0" title="0">{
                props.Style = &amp;xml.TableStyle{
                        Val: style.Name,
                }
        }</span>

        <span class="cov8" title="1">return props</span>
}

func (s *TableSerializer) serializeGrid(table domain.Table) *xml.TableGrid <span class="cov8" title="1">{
        grid := &amp;xml.TableGrid{
                Cols: make([]*xml.GridCol, table.ColumnCount()),
        }

        for i := 0; i &lt; table.ColumnCount(); i++ </span><span class="cov8" title="1">{
                grid.Cols[i] = &amp;xml.GridCol{W: intPtr(0)}
        }</span>

        <span class="cov8" title="1">return grid</span>
}

func (s *TableSerializer) serializeRow(row domain.TableRow) *xml.TableRow <span class="cov8" title="1">{
        xmlRow := &amp;xml.TableRow{
                Cells: make([]*xml.TableCell, 0, len(row.Cells())),
        }

        // Height
        if row.Height() &gt; 0 </span><span class="cov0" title="0">{
                xmlRow.Properties = &amp;xml.TableRowProperties{
                        Height: &amp;xml.TableRowHeight{
                                Val:  row.Height(),
                                Rule: "atLeast",
                        },
                }
        }</span>

        // Serialize cells, skipping horizontal merge continuations
        <span class="cov8" title="1">for _, cell := range row.Cells() </span><span class="cov8" title="1">{
                if cell.IsHorizontallyMergedContinuation() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">xmlRow.Cells = append(xmlRow.Cells, s.serializeCell(cell))</span>
        }

        <span class="cov8" title="1">return xmlRow</span>
}

func (s *TableSerializer) serializeCell(cell domain.TableCell) *xml.TableCell <span class="cov8" title="1">{
        paragraphs := cell.Paragraphs()
        tables := cell.Tables()

        content := make([]interface{}, 0, len(paragraphs)+len(tables)+1)

        for _, para := range paragraphs </span><span class="cov8" title="1">{
                content = append(content, s.paraSerializer.Serialize(para))
        }</span>

        <span class="cov8" title="1">if len(tables) &gt; 0 </span><span class="cov0" title="0">{
                // If the cell contains only nested tables, add a leading placeholder paragraph to anchor the table content.
                if len(paragraphs) == 0 </span><span class="cov0" title="0">{
                        content = append(content, emptyParagraph())
                }</span>

                <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                        content = append(content, s.Serialize(table))
                }</span>

                // Word expects a trailing empty paragraph after nested tables to keep the end-of-cell marker intact.
                <span class="cov0" title="0">content = append(content, emptyParagraph())</span>
        }

        <span class="cov8" title="1">if len(content) == 0 </span><span class="cov8" title="1">{
                content = append(content, emptyParagraph())
        }</span>

        <span class="cov8" title="1">return &amp;xml.TableCell{
                Properties: s.serializeCellProperties(cell),
                Content:    content,
        }</span>
}

func (s *TableSerializer) serializeCellProperties(cell domain.TableCell) *xml.TableCellProperties <span class="cov8" title="1">{
        props := &amp;xml.TableCellProperties{}

        // Width (Word expects tcW even for auto width)
        widthType := constants.WidthTypeAuto
        widthValue := 0
        if cell.Width() &gt; 0 </span><span class="cov0" title="0">{
                widthType = constants.WidthTypeDXA
                widthValue = cell.Width()
        }</span>
        <span class="cov8" title="1">props.Width = &amp;xml.TableWidth{
                Type: widthType,
                W:    widthValue,
        }

        // GridSpan (horizontal merge)
        if cell.GridSpan() &gt; 1 </span><span class="cov0" title="0">{
                props.GridSpan = &amp;xml.GridSpan{
                        Val: cell.GridSpan(),
                }
        }</span>

        // VMerge (vertical merge)
        <span class="cov8" title="1">if cell.VMerge() != domain.VMergeNone </span><span class="cov0" title="0">{
                vMerge := &amp;xml.VMerge{}
                if cell.VMerge() == domain.VMergeRestart </span><span class="cov0" title="0">{
                        vMerge.Val = "restart"
                }</span>
                // VMergeContinue uses empty Val (omitted)
                <span class="cov0" title="0">props.VMerge = vMerge</span>
        }

        // Vertical alignment
        <span class="cov8" title="1">if cell.VerticalAlignment() != domain.VerticalAlignTop </span><span class="cov0" title="0">{
                props.VAlign = &amp;xml.VerticalAlign{
                        Val: s.verticalAlignToString(cell.VerticalAlignment()),
                }
        }</span>

        // Shading
        <span class="cov8" title="1">if cell.Shading() != domain.ColorWhite </span><span class="cov0" title="0">{
                props.Shading = &amp;xml.Shading{
                        Val:  "clear",
                        Fill: color.ToHex(cell.Shading()),
                }
        }</span>

        <span class="cov8" title="1">return props</span>
}

func (s *TableSerializer) widthTypeToString(wType domain.WidthType) string <span class="cov8" title="1">{
        switch wType </span>{
        case domain.WidthAuto:<span class="cov8" title="1">
                return constants.WidthTypeAuto</span>
        case domain.WidthDXA:<span class="cov0" title="0">
                return constants.WidthTypeDXA</span>
        case domain.WidthPct:<span class="cov0" title="0">
                return constants.WidthTypePct</span>
        default:<span class="cov0" title="0">
                return constants.WidthTypeAuto</span>
        }
}

func (s *TableSerializer) alignmentToString(align domain.Alignment) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.AlignmentLeft:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        case domain.AlignmentCenter:<span class="cov0" title="0">
                return constants.AlignmentValueCenter</span>
        case domain.AlignmentRight:<span class="cov0" title="0">
                return constants.AlignmentValueRight</span>
        case domain.AlignmentJustify:<span class="cov0" title="0">
                return constants.AlignmentValueJustify</span>
        case domain.AlignmentDistribute:<span class="cov0" title="0">
                return constants.AlignmentValueDistribute</span>
        default:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        }
}

func emptyParagraph() *xml.Paragraph <span class="cov8" title="1">{
        return &amp;xml.Paragraph{
                Properties: &amp;xml.ParagraphProperties{},
        }
}</span>

func (s *TableSerializer) verticalAlignToString(align domain.VerticalAlignment) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.VerticalAlignTop:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueTop</span>
        case domain.VerticalAlignCenter:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueCenter</span>
        case domain.VerticalAlignBottom:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueBottom</span>
        default:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueTop</span>
        }
}

// Helper functions

func boolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

func intPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

func intPtrIfNotZero(i int) *int <span class="cov8" title="1">{
        if i == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;i</span>
}

// DocumentSerializer converts a domain.Document to XML structures
type DocumentSerializer struct {
        paraSerializer  *ParagraphSerializer
        tableSerializer *TableSerializer
        drawingCounter  int
}

// NewDocumentSerializer creates a new DocumentSerializer.
func NewDocumentSerializer() *DocumentSerializer <span class="cov8" title="1">{
        paraSer := NewParagraphSerializer()
        tableSer := NewTableSerializer()
        serializer := &amp;DocumentSerializer{
                paraSerializer:  paraSer,
                tableSerializer: tableSer,
        }

        paraSer.runSerializer.SetDrawingIDProvider(serializer)
        tableSer.paraSerializer.runSerializer.SetDrawingIDProvider(serializer)

        return serializer
}</span>

// NextDrawingID returns a unique ID for drawing elements.
func (s *DocumentSerializer) NextDrawingID() int <span class="cov0" title="0">{
        s.drawingCounter++
        return s.drawingCounter
}</span>

// SerializeBody converts document content to xml.Body while preserving insertion order.
func (s *DocumentSerializer) SerializeBody(doc domain.Document) *xml.Body <span class="cov8" title="1">{
        blocks := doc.Blocks()
        body := &amp;xml.Body{
                Content: make([]interface{}, 0, len(blocks)),
        }

        for _, block := range blocks </span><span class="cov8" title="1">{
                switch </span>{
                case block.Paragraph != nil:<span class="cov8" title="1">
                        body.Content = append(body.Content, s.paraSerializer.Serialize(block.Paragraph))</span>
                case block.Table != nil:<span class="cov8" title="1">
                        body.Content = append(body.Content, s.tableSerializer.Serialize(block.Table))</span>
                case block.SectionBreak != nil &amp;&amp; block.SectionBreak.Section != nil:<span class="cov8" title="1">
                        sectPr := s.serializeSectionProperties(block.SectionBreak.Section)
                        if sectPr == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if block.SectionBreak.Type &gt;= domain.SectionBreakTypeNextPage &amp;&amp;
                                block.SectionBreak.Type &lt;= domain.SectionBreakTypeOddPage </span><span class="cov8" title="1">{
                                sectPr.Type = &amp;xml.SectionType{Val: s.sectionBreakTypeToString(block.SectionBreak.Type)}
                        }</span>

                        <span class="cov8" title="1">para := &amp;xml.Paragraph{
                                Properties: &amp;xml.ParagraphProperties{
                                        SectionProperties: sectPr,
                                },
                        }
                        body.Content = append(body.Content, para)</span>
                }
        }

        <span class="cov8" title="1">sections := doc.Sections()
        if len(sections) &gt; 0 </span><span class="cov8" title="1">{
                if sectPr := s.serializeSectionProperties(sections[len(sections)-1]); sectPr != nil </span><span class="cov8" title="1">{
                        body.SectPr = sectPr
                }</span>
        }

        <span class="cov8" title="1">return body</span>
}

// SerializeDocument creates the complete document XML structure.
func (s *DocumentSerializer) SerializeDocument(doc domain.Document) *xml.Document <span class="cov8" title="1">{
        return &amp;xml.Document{
                XMLnsW:  constants.NamespaceMain,
                XMLnsR:  constants.NamespaceRelationships,
                XMLnsWP: constants.NamespaceWordprocessingDrawing,
                Body:    s.SerializeBody(doc),
        }
}</span>

// SerializeSectionParts converts headers and footers into their own XML parts.
// The returned maps are keyed by the part filename (e.g., "header1.xml").
func (s *DocumentSerializer) SerializeSectionParts(doc domain.Document) (map[string]*xml.Header, map[string]*xml.Footer) <span class="cov0" title="0">{
        headers := make(map[string]*xml.Header)
        footers := make(map[string]*xml.Footer)

        sections := doc.Sections()
        for _, section := range sections </span><span class="cov0" title="0">{
                secWithMaps, ok := section.(interface {
                        HeadersAll() map[domain.HeaderType]domain.Header
                        FootersAll() map[domain.FooterType]domain.Footer
                })
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, header := range secWithMaps.HeadersAll() </span><span class="cov0" title="0">{
                        headerMeta, ok := header.(interface {
                                Paragraphs() []domain.Paragraph
                                RelationshipID() string
                                TargetPath() string
                        })
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">target := headerMeta.TargetPath()
                        if target == "" || headerMeta.RelationshipID() == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, exists := headers[target]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">xmlHeader := xml.NewHeader()
                        for _, para := range headerMeta.Paragraphs() </span><span class="cov0" title="0">{
                                xmlHeader.AddParagraph(s.paraSerializer.Serialize(para))
                        }</span>
                        <span class="cov0" title="0">headers[target] = xmlHeader</span>
                }

                <span class="cov0" title="0">for _, footer := range secWithMaps.FootersAll() </span><span class="cov0" title="0">{
                        footerMeta, ok := footer.(interface {
                                Paragraphs() []domain.Paragraph
                                RelationshipID() string
                                TargetPath() string
                        })
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">target := footerMeta.TargetPath()
                        if target == "" || footerMeta.RelationshipID() == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, exists := footers[target]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">xmlFooter := xml.NewFooter()
                        for _, para := range footerMeta.Paragraphs() </span><span class="cov0" title="0">{
                                xmlFooter.AddParagraph(s.paraSerializer.Serialize(para))
                        }</span>
                        <span class="cov0" title="0">footers[target] = xmlFooter</span>
                }
        }

        <span class="cov0" title="0">if len(headers) == 0 </span><span class="cov0" title="0">{
                headers = nil
        }</span>
        <span class="cov0" title="0">if len(footers) == 0 </span><span class="cov0" title="0">{
                footers = nil
        }</span>

        <span class="cov0" title="0">return headers, footers</span>
}

// SerializeCoreProperties converts metadata to core properties.
func (s *DocumentSerializer) SerializeCoreProperties(meta *domain.Metadata) *xml.CoreProperties <span class="cov8" title="1">{
        props := &amp;xml.CoreProperties{
                XMLnsCP:      constants.NamespaceCoreProperties,
                XMLnsDC:      constants.NamespaceDC,
                XMLnsDCTerms: constants.NamespaceDCTerms,
                XMLnsXSI:     "http://www.w3.org/2001/XMLSchema-instance",
                Title:        meta.Title,
                Subject:      meta.Subject,
                Creator:      meta.Creator,
                Description:  meta.Description,
        }

        // Keywords
        if len(meta.Keywords) &gt; 0 </span><span class="cov0" title="0">{
                keywords := ""
                for i, kw := range meta.Keywords </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                keywords += ", "
                        }</span>
                        <span class="cov0" title="0">keywords += kw</span>
                }
                <span class="cov0" title="0">props.Keywords = keywords</span>
        }

        // Dates
        <span class="cov8" title="1">if meta.Created != "" </span><span class="cov0" title="0">{
                props.Created = &amp;xml.DCDate{
                        Type:  "dcterms:W3CDTF",
                        Value: meta.Created,
                }
        }</span>
        <span class="cov8" title="1">if meta.Modified != "" </span><span class="cov0" title="0">{
                props.Modified = &amp;xml.DCDate{
                        Type:  "dcterms:W3CDTF",
                        Value: meta.Modified,
                }
        }</span>

        <span class="cov8" title="1">return props</span>
}

// SerializeAppProperties creates app.xml properties.
func (s *DocumentSerializer) SerializeAppProperties(doc domain.Document) *xml.AppProperties <span class="cov0" title="0">{
        return &amp;xml.AppProperties{
                Xmlns:       constants.NamespaceExtendedProperties,
                Application: "go-docx/v2",
                DocSecurity: 0,
                Lines:       0,
                Paragraphs:  len(doc.Paragraphs()),
                Company:     "Misael Monterroca",
        }
}</span>

// DebugPrint outputs document statistics for testing and debugging purposes.
func (s *DocumentSerializer) DebugPrint(doc domain.Document) <span class="cov0" title="0">{
        fmt.Printf("Document has %d paragraphs and %d tables\n",
                len(doc.Paragraphs()), len(doc.Tables()))
}</span>

// SerializeStyles converts a domain.StyleManager to xml.Styles.
func (s *DocumentSerializer) SerializeStyles(styleManager domain.StyleManager) *xml.Styles <span class="cov0" title="0">{
        xmlStyles := xml.NewStyles()

        // Set doc defaults
        xmlStyles.DocDefaults = &amp;xml.DocDefaults{
                RunDefaults: &amp;xml.RunDefaults{
                        Properties: &amp;xml.RunProperties{
                                Font: &amp;xml.Font{
                                        ASCII:    "Calibri",
                                        HAnsi:    "Calibri",
                                        EastAsia: "Times New Roman",
                                        CS:       "Times New Roman",
                                },
                                Size: &amp;xml.HalfPt{Val: 22}, // 11pt
                                Lang: &amp;xml.Language{
                                        Val:      "en-MX",
                                        EastAsia: "en-US",
                                        Bidi:     "ar-SA",
                                },
                        },
                },
                ParaDefaults: &amp;xml.ParagraphDefaults{},
        }

        // Include Word's latent style catalog to avoid auto-added styles during repair
        xmlStyles.LatentStyles = defaultLatentStyles

        // Serialize all styles from the style manager
        for _, style := range styleManager.ListStyles() </span><span class="cov0" title="0">{
                xmlStyle := s.serializeStyle(style)
                if xmlStyle != nil </span><span class="cov0" title="0">{
                        xmlStyles.AddStyle(xmlStyle)
                }</span>
        }

        <span class="cov0" title="0">return xmlStyles</span>
}

func (s *DocumentSerializer) serializeStyle(style domain.Style) *xml.Style <span class="cov0" title="0">{
        if style == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">xmlStyle := &amp;xml.Style{
                Type:    s.styleTypeToString(style.Type()),
                StyleID: style.ID(),
                Name:    &amp;xml.StyleName{Val: style.Name()},
        }

        // Set default flag
        if style.IsDefault() </span><span class="cov0" title="0">{
                defaultVal := true
                xmlStyle.Default = &amp;defaultVal
        }</span>

        // Set basedOn if applicable
        <span class="cov0" title="0">if style.BasedOn() != "" </span><span class="cov0" title="0">{
                xmlStyle.BasedOn = &amp;xml.BasedOn{Val: style.BasedOn()}
        }</span>

        // For Heading styles and Normal, add qFormat
        <span class="cov0" title="0">styleID := style.ID()
        if styleID == "Normal" </span><span class="cov0" title="0">{
                // Normal is the base quick format style
                xmlStyle.QFormat = &amp;struct{}{}
                xmlStyle.UIPriority = &amp;xml.UIPriority{Val: 0}
        }</span> else<span class="cov0" title="0"> if len(styleID) &gt;= 7 &amp;&amp; styleID[:7] == "Heading" </span><span class="cov0" title="0">{
                // Mark as quick format
                xmlStyle.QFormat = &amp;struct{}{}
                // Next paragraph should be Normal
                xmlStyle.Next = &amp;xml.Next{Val: "Normal"}
                // Set UI priority (Headings should have high priority)
                if len(styleID) == 8 </span><span class="cov0" title="0">{ // Heading1-9
                        priority := int(styleID[7] - '0')                        // Extract digit
                        xmlStyle.UIPriority = &amp;xml.UIPriority{Val: priority + 8} // Priority 9-17
                }</span>
        }

        // Serialize properties based on style type
        <span class="cov0" title="0">switch style.Type() </span>{
        case domain.StyleTypeParagraph:<span class="cov0" title="0">
                xmlStyle.ParaProps = s.serializeParagraphStyleProperties(style)
                xmlStyle.RunProps = s.serializeRunStyleProperties(style)</span>
        case domain.StyleTypeCharacter:<span class="cov0" title="0">
                xmlStyle.RunProps = s.serializeRunStyleProperties(style)</span>
        case domain.StyleTypeTable:<span class="cov0" title="0"></span>
                // Table styles are handled differently, no props to serialize here
        case domain.StyleTypeNumbering:<span class="cov0" title="0"></span>
                // Numbering styles are handled differently, no props to serialize here
        }

        <span class="cov0" title="0">return xmlStyle</span>
}

func (s *DocumentSerializer) serializeParagraphStyleProperties(style domain.Style) *xml.StyleParagraphProperties <span class="cov0" title="0">{
        props := &amp;xml.StyleParagraphProperties{}
        hasProps := false

        // Try to access paragraph-specific properties via interface
        if ps, ok := style.(interface{ OutlineLevel() int }); ok </span><span class="cov0" title="0">{
                level := ps.OutlineLevel()
                // Only include outline level for Heading styles (styleId starts with "Heading")
                // Heading styles should have outline levels 0-8
                styleID := style.ID()
                if len(styleID) &gt;= 7 &amp;&amp; styleID[:7] == "Heading" &amp;&amp; level &gt;= 0 &amp;&amp; level &lt;= 8 </span><span class="cov0" title="0">{
                        props.OutlineLevel = &amp;xml.OutlineLevel{Val: level}
                        hasProps = true
                }</span>
        }

        <span class="cov0" title="0">if ps, ok := style.(interface{ SpacingBefore() int }); ok </span><span class="cov0" title="0">{
                if spacing := ps.SpacingBefore(); spacing &gt; 0 </span><span class="cov0" title="0">{
                        if props.Spacing == nil </span><span class="cov0" title="0">{
                                props.Spacing = &amp;xml.StyleSpacing{}
                        }</span>
                        <span class="cov0" title="0">props.Spacing.Before = &amp;spacing
                        hasProps = true</span>
                }
        }

        <span class="cov0" title="0">if ps, ok := style.(interface{ SpacingAfter() int }); ok </span><span class="cov0" title="0">{
                if spacing := ps.SpacingAfter(); spacing &gt; 0 </span><span class="cov0" title="0">{
                        if props.Spacing == nil </span><span class="cov0" title="0">{
                                props.Spacing = &amp;xml.StyleSpacing{}
                        }</span>
                        <span class="cov0" title="0">props.Spacing.After = &amp;spacing
                        hasProps = true</span>
                }
        }

        <span class="cov0" title="0">if ps, ok := style.(interface{ KeepNext() bool }); ok </span><span class="cov0" title="0">{
                if ps.KeepNext() </span><span class="cov0" title="0">{
                        props.KeepNext = &amp;struct{}{}
                        hasProps = true
                }</span>
        }

        <span class="cov0" title="0">if ps, ok := style.(interface{ KeepLines() bool }); ok </span><span class="cov0" title="0">{
                if ps.KeepLines() </span><span class="cov0" title="0">{
                        props.KeepLines = &amp;struct{}{}
                        hasProps = true
                }</span>
        }

        <span class="cov0" title="0">if ps, ok := style.(interface{ Indentation() domain.Indentation }); ok </span><span class="cov0" title="0">{
                indent := ps.Indentation()
                if indent.Left != 0 || indent.Right != 0 || indent.FirstLine != 0 || indent.Hanging != 0 </span><span class="cov0" title="0">{
                        props.Indentation = &amp;xml.StyleIndentation{
                                Left:      intPtrIfNotZero(indent.Left),
                                Right:     intPtrIfNotZero(indent.Right),
                                FirstLine: intPtrIfNotZero(indent.FirstLine),
                                Hanging:   intPtrIfNotZero(indent.Hanging),
                        }
                        hasProps = true
                }</span>
        }

        <span class="cov0" title="0">if !hasProps </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return props</span>
}

func (s *DocumentSerializer) serializeRunStyleProperties(style domain.Style) *xml.RunProperties <span class="cov0" title="0">{
        props := &amp;xml.RunProperties{}
        hasProps := false

        // Font
        font := style.Font()
        if font.Name != "" &amp;&amp; font.Name != constants.DefaultFontName </span><span class="cov0" title="0">{
                props.Font = &amp;xml.Font{
                        ASCII:    font.Name,
                        HAnsi:    font.Name,
                        EastAsia: font.EastAsia,
                        CS:       font.CS,
                }
                hasProps = true
        }</span>

        // Bold
        <span class="cov0" title="0">if rs, ok := style.(interface{ Bold() bool }); ok </span><span class="cov0" title="0">{
                if rs.Bold() </span><span class="cov0" title="0">{
                        props.Bold = &amp;xml.BoolValue{Val: boolPtr(true)}
                        hasProps = true
                }</span>
        }

        // Italic
        <span class="cov0" title="0">if rs, ok := style.(interface{ Italic() bool }); ok </span><span class="cov0" title="0">{
                if rs.Italic() </span><span class="cov0" title="0">{
                        props.Italic = &amp;xml.BoolValue{Val: boolPtr(true)}
                        hasProps = true
                }</span>
        }

        // Color
        <span class="cov0" title="0">if rs, ok := style.(interface{ Color() domain.Color }); ok </span><span class="cov0" title="0">{
                color := rs.Color()
                if color != domain.ColorBlack </span><span class="cov0" title="0">{
                        props.Color = &amp;xml.Color{
                                Val: fmt.Sprintf("%02X%02X%02X", color.R, color.G, color.B),
                        }
                        hasProps = true
                }</span>
        }

        // Size
        <span class="cov0" title="0">if rs, ok := style.(interface{ Size() int }); ok </span><span class="cov0" title="0">{
                if size := rs.Size(); size &gt; 0 &amp;&amp; size != constants.DefaultFontSize </span><span class="cov0" title="0">{
                        props.Size = &amp;xml.HalfPt{Val: size}
                        props.SizeCS = &amp;xml.HalfPt{Val: size}
                        hasProps = true
                }</span>
        }

        // Underline
        <span class="cov0" title="0">if rs, ok := style.(interface{ Underline() domain.UnderlineStyle }); ok </span><span class="cov0" title="0">{
                if underline := rs.Underline(); underline != domain.UnderlineNone </span><span class="cov0" title="0">{
                        props.Underline = &amp;xml.Underline{
                                Val: s.underlineStyleToString(underline),
                        }
                        hasProps = true
                }</span>
        }

        <span class="cov0" title="0">if !hasProps </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return props</span>
}

func (s *DocumentSerializer) styleTypeToString(t domain.StyleType) string <span class="cov0" title="0">{
        switch t </span>{
        case domain.StyleTypeParagraph:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.StyleTypeCharacter:<span class="cov0" title="0">
                return "character"</span>
        case domain.StyleTypeTable:<span class="cov0" title="0">
                return "table"</span>
        case domain.StyleTypeNumbering:<span class="cov0" title="0">
                return "numbering"</span>
        default:<span class="cov0" title="0">
                return "paragraph"</span>
        }
}

func (s *DocumentSerializer) serializeSectionProperties(section domain.Section) *xml.SectionProperties <span class="cov8" title="1">{
        if section == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">sectPr := xml.NewSectionProperties()

        pageSize := section.PageSize()
        orient := section.Orientation()
        landscape := orient == domain.OrientationLandscape
        if pageSize.Width == 0 || pageSize.Height == 0 </span><span class="cov0" title="0">{
                pageSize = domain.PageSizeLetter
        }</span>
        <span class="cov8" title="1">sectPr.SetPageSize(pageSize.Width, pageSize.Height, landscape)

        margins := section.Margins()
        if margins == (domain.Margins{}) </span><span class="cov0" title="0">{
                margins = domain.DefaultMargins
        }</span>
        <span class="cov8" title="1">sectPr.SetPageMargins(margins.Top, margins.Right, margins.Bottom, margins.Left, margins.Header, margins.Footer)

        if cols := section.Columns(); cols &gt; 1 </span><span class="cov8" title="1">{
                sectPr.SetColumns(cols)
        }</span>

        <span class="cov8" title="1">if secWithMaps, ok := section.(interface {
                HeadersAll() map[domain.HeaderType]domain.Header
                FootersAll() map[domain.FooterType]domain.Footer
        }); ok </span><span class="cov8" title="1">{
                for headerType, header := range secWithMaps.HeadersAll() </span><span class="cov0" title="0">{
                        headerMeta, ok := header.(interface {
                                RelationshipID() string
                        })
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if relID := headerMeta.RelationshipID(); relID != "" </span><span class="cov0" title="0">{
                                sectPr.AddHeaderRef(s.headerTypeToString(headerType), relID)
                        }</span>
                }

                <span class="cov8" title="1">for footerType, footer := range secWithMaps.FootersAll() </span><span class="cov0" title="0">{
                        footerMeta, ok := footer.(interface {
                                RelationshipID() string
                        })
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if relID := footerMeta.RelationshipID(); relID != "" </span><span class="cov0" title="0">{
                                sectPr.AddFooterRef(s.footerTypeToString(footerType), relID)
                        }</span>
                }
        }

        <span class="cov8" title="1">return sectPr</span>
}

func (s *DocumentSerializer) sectionBreakTypeToString(bt domain.SectionBreakType) string <span class="cov8" title="1">{
        switch bt </span>{
        case domain.SectionBreakTypeNextPage:<span class="cov0" title="0">
                return "nextPage"</span>
        case domain.SectionBreakTypeContinuous:<span class="cov0" title="0">
                return "continuous"</span>
        case domain.SectionBreakTypeEvenPage:<span class="cov8" title="1">
                return "evenPage"</span>
        case domain.SectionBreakTypeOddPage:<span class="cov0" title="0">
                return "oddPage"</span>
        default:<span class="cov0" title="0">
                return "nextPage"</span>
        }
}

func (s *DocumentSerializer) headerTypeToString(ht domain.HeaderType) string <span class="cov0" title="0">{
        switch ht </span>{
        case domain.HeaderDefault:<span class="cov0" title="0">
                return "default"</span>
        case domain.HeaderFirst:<span class="cov0" title="0">
                return "first"</span>
        case domain.HeaderEven:<span class="cov0" title="0">
                return "even"</span>
        default:<span class="cov0" title="0">
                return "default"</span>
        }
}

func (s *DocumentSerializer) footerTypeToString(ft domain.FooterType) string <span class="cov0" title="0">{
        switch ft </span>{
        case domain.FooterDefault:<span class="cov0" title="0">
                return "default"</span>
        case domain.FooterFirst:<span class="cov0" title="0">
                return "first"</span>
        case domain.FooterEven:<span class="cov0" title="0">
                return "even"</span>
        default:<span class="cov0" title="0">
                return "default"</span>
        }
}

func (s *DocumentSerializer) underlineStyleToString(style domain.UnderlineStyle) string <span class="cov0" title="0">{
        switch style </span>{
        case domain.UnderlineNone:<span class="cov0" title="0">
                return constants.UnderlineValueNone</span>
        case domain.UnderlineSingle:<span class="cov0" title="0">
                return constants.UnderlineValueSingle</span>
        case domain.UnderlineDouble:<span class="cov0" title="0">
                return constants.UnderlineValueDouble</span>
        case domain.UnderlineThick:<span class="cov0" title="0">
                return constants.UnderlineValueThick</span>
        case domain.UnderlineDotted:<span class="cov0" title="0">
                return constants.UnderlineValueDotted</span>
        case domain.UnderlineDashed:<span class="cov0" title="0">
                return constants.UnderlineValueDashed</span>
        case domain.UnderlineWave:<span class="cov0" title="0">
                return constants.UnderlineValueWave</span>
        default:<span class="cov0" title="0">
                return constants.UnderlineValueSingle</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package writer handles writing DOCX files as ZIP archives containing XML documents.
// It provides the ZipWriter for creating properly structured Office Open XML packages.
package writer

/*
   Copyright (c) 2025 Misael Monterroca

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

import (
        "archive/zip"
        "encoding/xml"
        "fmt"
        "io"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/internal/serializer"
        xmlstructs "github.com/mmonterroca/docxgo/internal/xml"
        "github.com/mmonterroca/docxgo/pkg/constants"
)

// ZipWriter writes a .docx file to an io.Writer.
type ZipWriter struct {
        zipWriter  *zip.Writer
        serializer *serializer.DocumentSerializer
}

// NewZipWriter creates a new ZipWriter.
func NewZipWriter(w io.Writer) *ZipWriter <span class="cov8" title="1">{
        return &amp;ZipWriter{
                zipWriter:  zip.NewWriter(w),
                serializer: serializer.NewDocumentSerializer(),
        }
}</span>

// WriteDocument writes a complete .docx document structure.
func (zw *ZipWriter) WriteDocument(doc *xmlstructs.Document, rels *xmlstructs.Relationships, coreProps *xmlstructs.CoreProperties, appProps *xmlstructs.AppProperties, styles *xmlstructs.Styles, media []*manager.MediaFile, headers map[string]*xmlstructs.Header, footers map[string]*xmlstructs.Footer) error <span class="cov8" title="1">{
        // Write [Content_Types].xml with optional header/footer overrides
        if err := zw.writeContentTypes(headers, footers, media); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write content types: %w", err)
        }</span>

        // Write _rels/.rels
        <span class="cov8" title="1">if err := zw.writeRootRels(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write root rels: %w", err)
        }</span>

        // Write word/document.xml
        <span class="cov8" title="1">if err := zw.writeMainDocument(doc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write main document: %w", err)
        }</span>

        // Write word/_rels/document.xml.rels
        <span class="cov8" title="1">if err := zw.writeDocumentRels(rels); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write document rels: %w", err)
        }</span>

        // Write docProps/core.xml
        <span class="cov8" title="1">if err := zw.writeCoreProperties(coreProps); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write core properties: %w", err)
        }</span>

        // Write docProps/app.xml
        <span class="cov8" title="1">if err := zw.writeAppProperties(appProps); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write app properties: %w", err)
        }</span>

        // Write word/styles.xml
        <span class="cov8" title="1">if err := zw.writeStyles(styles); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write styles: %w", err)
        }</span>

        // Write word/fontTable.xml (minimal default)
        <span class="cov8" title="1">if err := zw.writeDefaultFontTable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write font table: %w", err)
        }</span>

        // Write word/theme/theme1.xml (minimal default)
        <span class="cov8" title="1">if err := zw.writeDefaultTheme(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write theme: %w", err)
        }</span>

        // Write word/settings.xml (minimal default)
        <span class="cov8" title="1">if err := zw.writeDefaultSettings(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write settings: %w", err)
        }</span>

        // Write word/webSettings.xml (minimal default)
        <span class="cov8" title="1">if err := zw.writeDefaultWebSettings(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write web settings: %w", err)
        }</span>

        // Write media files to word/media
        <span class="cov8" title="1">if err := zw.writeMediaFiles(media); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write media: %w", err)
        }</span>

        // Write headers
        <span class="cov8" title="1">for name, header := range headers </span><span class="cov0" title="0">{
                if err := zw.writeXML(fmt.Sprintf("word/%s", name), header); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("write header %s: %w", name, err)
                }</span>
        }

        // Write footers
        <span class="cov8" title="1">for name, footer := range footers </span><span class="cov0" title="0">{
                if err := zw.writeXML(fmt.Sprintf("word/%s", name), footer); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("write footer %s: %w", name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Close closes the ZIP writer.
func (zw *ZipWriter) Close() error <span class="cov8" title="1">{
        return zw.zipWriter.Close()
}</span>

// writeContentTypes writes [Content_Types].xml
func (zw *ZipWriter) writeContentTypes(headers map[string]*xmlstructs.Header, footers map[string]*xmlstructs.Footer, media []*manager.MediaFile) error <span class="cov8" title="1">{
        ct := &amp;xmlstructs.ContentTypes{
                Xmlns: constants.NamespaceContentTypes,
                Defaults: []*xmlstructs.Default{
                        {Extension: "rels", ContentType: constants.ContentTypeRelationships},
                        {Extension: "xml", ContentType: "application/xml"},
                },
                Overrides: []*xmlstructs.Override{
                        {PartName: "/word/document.xml", ContentType: constants.ContentTypeDocument},
                        {PartName: "/word/styles.xml", ContentType: constants.ContentTypeStyles},
                        {PartName: "/word/fontTable.xml", ContentType: constants.ContentTypeFontTable},
                        {PartName: "/word/theme/theme1.xml", ContentType: constants.ContentTypeTheme},
                        {PartName: "/word/settings.xml", ContentType: constants.ContentTypeSettings},
                        {PartName: "/word/webSettings.xml", ContentType: constants.ContentTypeWebSettings},
                        {PartName: "/docProps/core.xml", ContentType: constants.ContentTypeCoreProperties},
                        {PartName: "/docProps/app.xml", ContentType: constants.ContentTypeExtendedProperties},
                },
        }

        addOverride := func(name, contentType string) </span><span class="cov0" title="0">{
                if name == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, existing := range ct.Overrides </span><span class="cov0" title="0">{
                        if existing.PartName == name </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">ct.Overrides = append(ct.Overrides, &amp;xmlstructs.Override{PartName: name, ContentType: contentType})</span>
        }

        <span class="cov8" title="1">for name := range headers </span><span class="cov0" title="0">{
                addOverride(fmt.Sprintf("/word/%s", name), constants.ContentTypeHeader)
        }</span>

        // Include defaults for media content types
        <span class="cov8" title="1">addDefault := func(extension, contentType string) </span><span class="cov0" title="0">{
                if extension == "" || contentType == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">ext := strings.ToLower(extension)
                for _, existing := range ct.Defaults </span><span class="cov0" title="0">{
                        if existing != nil &amp;&amp; strings.EqualFold(existing.Extension, ext) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">ct.Defaults = append(ct.Defaults, &amp;xmlstructs.Default{
                        Extension:   ext,
                        ContentType: contentType,
                })</span>
        }

        <span class="cov8" title="1">for _, file := range media </span><span class="cov0" title="0">{
                if file == nil || len(file.Data) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ext := strings.TrimPrefix(strings.ToLower(filepath.Ext(file.Name)), ".")
                addDefault(ext, file.ContentType)</span>
        }
        <span class="cov8" title="1">for name := range footers </span><span class="cov0" title="0">{
                addOverride(fmt.Sprintf("/word/%s", name), constants.ContentTypeFooter)
        }</span>

        <span class="cov8" title="1">return zw.writeXML("[Content_Types].xml", ct)</span>
}

// writeRootRels writes _rels/.rels
func (zw *ZipWriter) writeRootRels() error <span class="cov8" title="1">{
        rels := &amp;xmlstructs.Relationships{
                Xmlns: constants.NamespacePackageRels,
                Relationships: []*xmlstructs.Relationship{
                        {
                                ID:     "rId1",
                                Type:   constants.RelTypeDocument,
                                Target: "word/document.xml",
                        },
                        {
                                ID:     "rId2",
                                Type:   "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
                                Target: "docProps/core.xml",
                        },
                        {
                                ID:     "rId3",
                                Type:   "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
                                Target: "docProps/app.xml",
                        },
                },
        }

        return zw.writeXML("_rels/.rels", rels)
}</span>

// writeMainDocument writes word/document.xml
func (zw *ZipWriter) writeMainDocument(doc *xmlstructs.Document) error <span class="cov8" title="1">{
        return zw.writeXML("word/document.xml", doc)
}</span>

// writeDocumentRels writes word/_rels/document.xml.rels
func (zw *ZipWriter) writeDocumentRels(rels *xmlstructs.Relationships) error <span class="cov8" title="1">{
        if rels == nil </span><span class="cov0" title="0">{
                rels = &amp;xmlstructs.Relationships{
                        Xmlns:         constants.NamespacePackageRels,
                        Relationships: []*xmlstructs.Relationship{},
                }
        }</span>

        <span class="cov8" title="1">if rels.Xmlns == "" </span><span class="cov0" title="0">{
                rels.Xmlns = constants.NamespacePackageRels
        }</span>

        <span class="cov8" title="1">nextRelID := func() string </span><span class="cov8" title="1">{
                maxID := 0
                for _, rel := range rels.Relationships </span><span class="cov8" title="1">{
                        if rel == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if strings.HasPrefix(rel.ID, "rId") </span><span class="cov8" title="1">{
                                if n, err := strconv.Atoi(strings.TrimPrefix(rel.ID, "rId")); err == nil &amp;&amp; n &gt; maxID </span><span class="cov8" title="1">{
                                        maxID = n
                                }</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Sprintf("rId%d", maxID+1)</span>
        }

        <span class="cov8" title="1">ensureRel := func(relType, target string) </span><span class="cov8" title="1">{
                if target == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">for _, rel := range rels.Relationships </span><span class="cov8" title="1">{
                        if rel != nil &amp;&amp; rel.Target == target </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">rels.Relationships = append(rels.Relationships, &amp;xmlstructs.Relationship{
                        ID:     nextRelID(),
                        Type:   relType,
                        Target: target,
                })</span>
        }

        <span class="cov8" title="1">ensureRel(constants.RelTypeStyles, "styles.xml")
        ensureRel(constants.RelTypeFontTable, "fontTable.xml")
        ensureRel(constants.RelTypeTheme, "theme/theme1.xml")
        ensureRel(constants.RelTypeSettings, "settings.xml")
        ensureRel(constants.RelTypeWebSettings, "webSettings.xml")

        return zw.writeXML("word/_rels/document.xml.rels", rels)</span>
}

// writeCoreProperties writes docProps/core.xml
func (zw *ZipWriter) writeCoreProperties(props *xmlstructs.CoreProperties) error <span class="cov8" title="1">{
        if props == nil </span><span class="cov8" title="1">{
                now := time.Now()
                props = &amp;xmlstructs.CoreProperties{
                        XMLnsCP:      constants.NamespaceCoreProperties,
                        XMLnsDC:      constants.NamespaceDC,
                        XMLnsDCTerms: constants.NamespaceDCTerms,
                        XMLnsXSI:     "http://www.w3.org/2001/XMLSchema-instance",
                        Creator:      "go-docx v2",
                        Created: &amp;xmlstructs.DCDate{
                                Type:  "dcterms:W3CDTF",
                                Value: now.Format(time.RFC3339),
                        },
                        Modified: &amp;xmlstructs.DCDate{
                                Type:  "dcterms:W3CDTF",
                                Value: now.Format(time.RFC3339),
                        },
                }
        }</span>
        <span class="cov8" title="1">return zw.writeXML("docProps/core.xml", props)</span>
}

// writeAppProperties writes docProps/app.xml
func (zw *ZipWriter) writeAppProperties(props *xmlstructs.AppProperties) error <span class="cov8" title="1">{
        if props == nil </span><span class="cov8" title="1">{
                props = &amp;xmlstructs.AppProperties{
                        Xmlns:       constants.NamespaceExtendedProperties,
                        Application: "go-docx v2.0.0",
                        DocSecurity: 0,
                }
        }</span>
        <span class="cov8" title="1">return zw.writeXML("docProps/app.xml", props)</span>
}

// writeDefaultStyles writes minimal word/styles.xml
func (zw *ZipWriter) writeDefaultStyles() error <span class="cov8" title="1">{
        styles := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
  &lt;w:docDefaults&gt;
    &lt;w:rPrDefault&gt;
      &lt;w:rPr&gt;
        &lt;w:rFonts w:ascii="Calibri" w:hAnsi="Calibri"/&gt;
        &lt;w:sz w:val="22"/&gt;
      &lt;/w:rPr&gt;
    &lt;/w:rPrDefault&gt;
    &lt;w:pPrDefault/&gt;
  &lt;/w:docDefaults&gt;
&lt;/w:styles&gt;`
        return zw.writeRaw("word/styles.xml", []byte(styles))
}</span>

// writeStyles writes word/styles.xml from serialized styles.
func (zw *ZipWriter) writeStyles(styles *xmlstructs.Styles) error <span class="cov8" title="1">{
        // If no styles provided, use defaults
        if styles == nil </span><span class="cov8" title="1">{
                return zw.writeDefaultStyles()
        }</span>

        <span class="cov0" title="0">w, err := zw.zipWriter.Create("word/styles.xml")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write XML declaration
        <span class="cov0" title="0">if _, err := w.Write([]byte(xml.Header)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Marshal and write styles
        <span class="cov0" title="0">encoder := xml.NewEncoder(w)
        encoder.Indent("", "  ")
        return encoder.Encode(styles)</span>
}

// writeDefaultFontTable writes minimal word/fontTable.xml
func (zw *ZipWriter) writeDefaultFontTable() error <span class="cov8" title="1">{
        fontTable := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:fonts xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
  &lt;w:font w:name="Calibri"&gt;
    &lt;w:panose1 w:val="020F0502020204030204"/&gt;
    &lt;w:charset w:val="00"/&gt;
    &lt;w:family w:val="swiss"/&gt;
    &lt;w:pitch w:val="variable"/&gt;
  &lt;/w:font&gt;
&lt;/w:fonts&gt;`
        return zw.writeRaw("word/fontTable.xml", []byte(fontTable))
}</span>

// writeDefaultTheme writes minimal word/theme/theme1.xml
func (zw *ZipWriter) writeDefaultTheme() error <span class="cov8" title="1">{
        theme := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"&gt;
        &lt;a:themeElements&gt;
                &lt;a:clrScheme name="Office"&gt;
                        &lt;a:dk1&gt;&lt;a:sysClr val="windowText" lastClr="000000"/&gt;&lt;/a:dk1&gt;
                        &lt;a:lt1&gt;&lt;a:sysClr val="window" lastClr="FFFFFF"/&gt;&lt;/a:lt1&gt;
                        &lt;a:dk2&gt;&lt;a:srgbClr val="44546A"/&gt;&lt;/a:dk2&gt;
                        &lt;a:lt2&gt;&lt;a:srgbClr val="E7E6E6"/&gt;&lt;/a:lt2&gt;
                        &lt;a:accent1&gt;&lt;a:srgbClr val="4472C4"/&gt;&lt;/a:accent1&gt;
                        &lt;a:accent2&gt;&lt;a:srgbClr val="ED7D31"/&gt;&lt;/a:accent2&gt;
                        &lt;a:accent3&gt;&lt;a:srgbClr val="A5A5A5"/&gt;&lt;/a:accent3&gt;
                        &lt;a:accent4&gt;&lt;a:srgbClr val="FFC000"/&gt;&lt;/a:accent4&gt;
                        &lt;a:accent5&gt;&lt;a:srgbClr val="5B9BD5"/&gt;&lt;/a:accent5&gt;
                        &lt;a:accent6&gt;&lt;a:srgbClr val="70AD47"/&gt;&lt;/a:accent6&gt;
                        &lt;a:hlink&gt;&lt;a:srgbClr val="0563C1"/&gt;&lt;/a:hlink&gt;
                        &lt;a:folHlink&gt;&lt;a:srgbClr val="954F72"/&gt;&lt;/a:folHlink&gt;
                &lt;/a:clrScheme&gt;
                &lt;a:fontScheme name="Office"&gt;
                        &lt;a:majorFont&gt;
                                &lt;a:latin typeface="Calibri Light"/&gt;
                                &lt;a:ea typeface=""/&gt;
                                &lt;a:cs typeface=""/&gt;
                        &lt;/a:majorFont&gt;
                        &lt;a:minorFont&gt;
                                &lt;a:latin typeface="Calibri"/&gt;
                                &lt;a:ea typeface=""/&gt;
                                &lt;a:cs typeface=""/&gt;
                        &lt;/a:minorFont&gt;
                &lt;/a:fontScheme&gt;
                &lt;a:fmtScheme name="Office"&gt;
                        &lt;a:fillStyleLst&gt;
                                &lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;
                                &lt;a:gradFill rotWithShape="1"&gt;
                                        &lt;a:gsLst&gt;
                                                &lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="50000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                                &lt;a:gs pos="35000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="37000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                                &lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="15000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                        &lt;/a:gsLst&gt;
                                        &lt;a:lin ang="16200000" scaled="1"/&gt;
                                &lt;/a:gradFill&gt;
                                &lt;a:gradFill rotWithShape="1"&gt;
                                        &lt;a:gsLst&gt;
                                                &lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="51000"/&gt;&lt;a:satMod val="130000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                                &lt;a:gs pos="80000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="93000"/&gt;&lt;a:satMod val="130000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                                &lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="94000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                        &lt;/a:gsLst&gt;
                                        &lt;a:lin ang="16200000" scaled="1"/&gt;
                                &lt;/a:gradFill&gt;
                        &lt;/a:fillStyleLst&gt;
                        &lt;a:lnStyleLst&gt;
                                &lt;a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;a:miter lim="800000"/&gt;&lt;/a:ln&gt;
                                &lt;a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;a:miter lim="800000"/&gt;&lt;/a:ln&gt;
                                &lt;a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;a:miter lim="800000"/&gt;&lt;/a:ln&gt;
                        &lt;/a:lnStyleLst&gt;
                        &lt;a:effectStyleLst&gt;
                                &lt;a:effectStyle&gt;&lt;a:effectLst/&gt;&lt;/a:effectStyle&gt;
                                &lt;a:effectStyle&gt;&lt;a:effectLst/&gt;&lt;/a:effectStyle&gt;
                                &lt;a:effectStyle&gt;
                                        &lt;a:effectLst&gt;
                                                &lt;a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"&gt;
                                                        &lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="63000"/&gt;&lt;/a:srgbClr&gt;
                                                &lt;/a:outerShdw&gt;
                                        &lt;/a:effectLst&gt;
                                &lt;/a:effectStyle&gt;
                        &lt;/a:effectStyleLst&gt;
                        &lt;a:bgFillStyleLst&gt;
                                &lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;
                                &lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="95000"/&gt;&lt;a:satMod val="170000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:solidFill&gt;
                                &lt;a:gradFill rotWithShape="1"&gt;
                                        &lt;a:gsLst&gt;
                                                &lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="93000"/&gt;&lt;a:satMod val="150000"/&gt;&lt;a:shade val="98000"/&gt;&lt;a:lumMod val="102000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                                &lt;a:gs pos="50000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="98000"/&gt;&lt;a:satMod val="130000"/&gt;&lt;a:shade val="90000"/&gt;&lt;a:lumMod val="103000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                                &lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="63000"/&gt;&lt;a:satMod val="120000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;
                                        &lt;/a:gsLst&gt;
                                        &lt;a:lin ang="16200000" scaled="1"/&gt;
                                &lt;/a:gradFill&gt;
                        &lt;/a:bgFillStyleLst&gt;
                &lt;/a:fmtScheme&gt;
        &lt;/a:themeElements&gt;
        &lt;a:objectDefaults/&gt;
        &lt;a:extraClrSchemeLst/&gt;
&lt;/a:theme&gt;`
        return zw.writeRaw("word/theme/theme1.xml", []byte(theme))
}</span>

// writeDefaultSettings writes a baseline word/settings.xml part.
func (zw *ZipWriter) writeDefaultSettings() error <span class="cov8" title="1">{
        settings := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
        &lt;w:zoom w:percent="100"/&gt;
        &lt;w:defaultTabStop w:val="720"/&gt;
        &lt;w:characterSpacingControl w:val="doNotCompress"/&gt;
        &lt;w:compat&gt;
                &lt;w:compatSetting w:name="compatibilityMode" w:uri="http://schemas.microsoft.com/office/word" w:val="15"/&gt;
        &lt;/w:compat&gt;
&lt;/w:settings&gt;`
        return zw.writeRaw("word/settings.xml", []byte(settings))
}</span>

// writeDefaultWebSettings writes a baseline word/webSettings.xml part.
func (zw *ZipWriter) writeDefaultWebSettings() error <span class="cov8" title="1">{
        webSettings := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:webSettings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
        &lt;w:allowPNG/&gt;
&lt;/w:webSettings&gt;`
        return zw.writeRaw("word/webSettings.xml", []byte(webSettings))
}</span>

// writeXML marshals and writes an XML structure to the ZIP.
func (zw *ZipWriter) writeXML(path string, v interface{}) error <span class="cov8" title="1">{
        w, err := zw.zipWriter.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write XML header
        <span class="cov8" title="1">if _, err := w.Write([]byte(xml.Header)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Marshal and write XML
        <span class="cov8" title="1">encoder := xml.NewEncoder(w)
        encoder.Indent("", "  ")
        if err := encoder.Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// writeRaw writes raw bytes to the ZIP.
func (zw *ZipWriter) writeRaw(path string, data []byte) error <span class="cov8" title="1">{
        w, err := zw.zipWriter.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = w.Write(data)
        return err</span>
}

// writeMediaFiles writes all media assets into the DOCX package.
func (zw *ZipWriter) writeMediaFiles(media []*manager.MediaFile) error <span class="cov8" title="1">{
        for _, file := range media </span><span class="cov0" title="0">{
                if file == nil || len(file.Data) == 0 || file.Path == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err := zw.writeRaw(file.Path, file.Data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package xml

import "github.com/mmonterroca/docxgo/domain"

// NewInlineDrawing creates an inline drawing (flows with text).
func NewInlineDrawing(img domain.Image, drawingID int) *Drawing <span class="cov0" title="0">{
        size := img.Size()

        return &amp;Drawing{
                Inline: &amp;Inline{
                        DistT: 0,
                        DistB: 0,
                        DistL: 0,
                        DistR: 0,
                        Extent: &amp;Extent{
                                Cx: size.WidthEMU,
                                Cy: size.HeightEMU,
                        },
                        EffectExtent: &amp;EffectExtent{
                                L: 0,
                                T: 0,
                                R: 0,
                                B: 0,
                        },
                        DocPr: &amp;DocPr{
                                ID:    drawingID,
                                Name:  "Picture " + img.ID(),
                                Descr: img.Description(),
                        },
                        Graphic: newGraphic(img, size),
                },
        }
}</span>

// NewFloatingDrawing creates a floating drawing (absolute positioning).
func NewFloatingDrawing(img domain.Image, drawingID int) *Drawing <span class="cov0" title="0">{
        size := img.Size()
        pos := img.Position()

        // Convert position to anchor
        anchor := &amp;Anchor{
                DistT:          114300, // Default distances (0.125 inch)
                DistB:          114300,
                DistL:          114300,
                DistR:          114300,
                SimplePosAttr:  false,
                RelativeHeight: pos.ZOrder,
                BehindDoc:      pos.BehindText,
                Locked:         false,
                LayoutInCell:   true,
                AllowOverlap:   true,
                SimplePos: &amp;SimplePos{
                        X: 0,
                        Y: 0,
                },
                Extent: &amp;Extent{
                        Cx: size.WidthEMU,
                        Cy: size.HeightEMU,
                },
                EffectExtent: &amp;EffectExtent{
                        L: 0,
                        T: 0,
                        R: 0,
                        B: 0,
                },
                DocPr: &amp;DocPr{
                        ID:    drawingID,
                        Name:  "Picture " + img.ID(),
                        Descr: img.Description(),
                },
                Graphic: newGraphic(img, size),
        }

        // Set horizontal position
        anchor.PositionH = &amp;PositionH{
                RelativeFrom: convertHAlign(pos.HAlign),
        }
        if pos.OffsetX != 0 </span><span class="cov0" title="0">{
                offset := pos.OffsetX
                anchor.PositionH.PosOffset = &amp;offset
        }</span> else<span class="cov0" title="0"> {
                align := string(pos.HAlign)
                anchor.PositionH.Align = &amp;align
        }</span>

        // Set vertical position
        <span class="cov0" title="0">anchor.PositionV = &amp;PositionV{
                RelativeFrom: convertVAlign(pos.VAlign),
        }
        if pos.OffsetY != 0 </span><span class="cov0" title="0">{
                offset := pos.OffsetY
                anchor.PositionV.PosOffset = &amp;offset
        }</span> else<span class="cov0" title="0"> {
                align := string(pos.VAlign)
                anchor.PositionV.Align = &amp;align
        }</span>

        // Set wrap type
        <span class="cov0" title="0">if pos.WrapText != domain.WrapNone </span><span class="cov0" title="0">{
                anchor.WrapType = &amp;WrapType{
                        WrapText: "bothSides",
                }
        }</span>

        <span class="cov0" title="0">return &amp;Drawing{
                Anchor: anchor,
        }</span>
}

// newGraphic creates the graphic content for an image.
func newGraphic(img domain.Image, size domain.ImageSize) *Graphic <span class="cov0" title="0">{
        return &amp;Graphic{
                Xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
                GraphicData: &amp;GraphicData{
                        URI: "http://schemas.openxmlformats.org/drawingml/2006/picture",
                        Pic: &amp;Pic{
                                Xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture",
                                NvPicPr: &amp;NvPicPr{
                                        CNvPr: &amp;CNvPr{
                                                ID:    0,
                                                Name:  "Picture " + img.ID(),
                                                Descr: img.Description(),
                                        },
                                        CNvPicPr: &amp;CNvPicPr{
                                                PicLocks: &amp;PicLocks{
                                                        NoChangeAspect: true,
                                                },
                                        },
                                },
                                BlipFill: &amp;BlipFill{
                                        Blip: &amp;Blip{
                                                Xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
                                                Embed: img.RelationshipID(),
                                        },
                                        Stretch: &amp;Stretch{
                                                FillRect: &amp;FillRect{},
                                        },
                                },
                                SpPr: &amp;SpPr{
                                        Xfrm: &amp;Xfrm{
                                                Off: &amp;Off{X: 0, Y: 0},
                                                Ext: &amp;Ext{
                                                        Cx: size.WidthEMU,
                                                        Cy: size.HeightEMU,
                                                },
                                        },
                                        PrstGeom: &amp;PrstGeom{
                                                Prst:  "rect",
                                                AvLst: &amp;AvLst{},
                                        },
                                },
                        },
                },
        }
}</span>

// convertHAlign converts domain horizontal alignment to XML relative from.
func convertHAlign(align domain.HorizontalAlign) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.HAlignLeft:<span class="cov0" title="0">
                return "column"</span>
        case domain.HAlignCenter:<span class="cov0" title="0">
                return "column"</span>
        case domain.HAlignRight:<span class="cov0" title="0">
                return "column"</span>
        case domain.HAlignInside:<span class="cov0" title="0">
                return "margin"</span>
        case domain.HAlignOutside:<span class="cov0" title="0">
                return "margin"</span>
        default:<span class="cov0" title="0">
                return "column"</span>
        }
}

// convertVAlign converts domain vertical alignment to XML relative from.
func convertVAlign(align domain.VerticalAlign) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.VAlignTop:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.VAlignCenter:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.VAlignBottom:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.VAlignInside:<span class="cov0" title="0">
                return "margin"</span>
        case domain.VAlignOutside:<span class="cov0" title="0">
                return "margin"</span>
        default:<span class="cov0" title="0">
                return "paragraph"</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package xml

import "encoding/xml"

// FieldSimple represents a w:fldSimple element for simple fields.
// Complex fields use: w:fldChar (begin) -&gt; w:instrText -&gt; w:fldChar (separate) -&gt; result -&gt; w:fldChar (end)
type FieldSimple struct {
        XMLName xml.Name `xml:"w:fldSimple"`
        Instr   string   `xml:"w:instr,attr"`
        Text    *Text    `xml:"w:t,omitempty"`
}

// FieldChar represents w:fldChar element (field character).
type FieldChar struct {
        XMLName xml.Name `xml:"w:fldChar"`
        FldType string   `xml:"w:fldCharType,attr"` // begin, separate, end
        Dirty   *bool    `xml:"w:dirty,attr,omitempty"`
        FldLock *bool    `xml:"w:fldLock,attr,omitempty"`
}

// InstrText represents w:instrText element (field instruction text).
type InstrText struct {
        XMLName xml.Name `xml:"w:instrText"`
        Space   string   `xml:"xml:space,attr,omitempty"`
        Content string   `xml:",chardata"`
}

// NewFieldBegin creates a field begin character.
func NewFieldBegin() *FieldChar <span class="cov8" title="1">{
        return &amp;FieldChar{
                FldType: "begin",
        }
}</span>

// NewFieldSeparate creates a field separate character.
func NewFieldSeparate() *FieldChar <span class="cov8" title="1">{
        return &amp;FieldChar{
                FldType: "separate",
        }
}</span>

// NewFieldEnd creates a field end character.
func NewFieldEnd() *FieldChar <span class="cov8" title="1">{
        return &amp;FieldChar{
                FldType: "end",
        }
}</span>

// NewInstrText creates a field instruction text element.
func NewInstrText(instruction string) *InstrText <span class="cov8" title="1">{
        return &amp;InstrText{
                Space:   "preserve",
                Content: instruction,
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package xml

import "encoding/xml"

// Header represents a Word header document (header1.xml, header2.xml, etc.)
type Header struct {
        XMLName    xml.Name     `xml:"w:hdr"`
        Xmlns      string       `xml:"xmlns:w,attr"`
        XmlnsR     string       `xml:"xmlns:r,attr"`
        Paragraphs []*Paragraph `xml:"w:p"`
}

// Footer represents a Word footer document (footer1.xml, footer2.xml, etc.)
type Footer struct {
        XMLName    xml.Name     `xml:"w:ftr"`
        Xmlns      string       `xml:"xmlns:w,attr"`
        XmlnsR     string       `xml:"xmlns:r,attr"`
        Paragraphs []*Paragraph `xml:"w:p"`
}

// NewHeader creates a new header document.
func NewHeader() *Header <span class="cov8" title="1">{
        return &amp;Header{
                Xmlns:      "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
                XmlnsR:     "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
                Paragraphs: make([]*Paragraph, 0),
        }
}</span>

// NewFooter creates a new footer document.
func NewFooter() *Footer <span class="cov8" title="1">{
        return &amp;Footer{
                Xmlns:      "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
                XmlnsR:     "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
                Paragraphs: make([]*Paragraph, 0),
        }
}</span>

// AddParagraph adds a paragraph to the header.
func (h *Header) AddParagraph(p *Paragraph) <span class="cov8" title="1">{
        h.Paragraphs = append(h.Paragraphs, p)
}</span>

// AddParagraph adds a paragraph to the footer.
func (f *Footer) AddParagraph(p *Paragraph) <span class="cov8" title="1">{
        f.Paragraphs = append(f.Paragraphs, p)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package xml

import "encoding/xml"

// SectionProperties represents w:sectPr element (section properties).
type SectionProperties struct {
        XMLName     xml.Name     `xml:"w:sectPr"`
        HeaderRef   []HeaderRef  `xml:"w:headerReference,omitempty"`
        FooterRef   []FooterRef  `xml:"w:footerReference,omitempty"`
        Type        *SectionType `xml:"w:type,omitempty"`
        PageSize    *PageSize    `xml:"w:pgSz,omitempty"`
        PageMargins *PageMargins `xml:"w:pgMar,omitempty"`
        Columns     *Columns     `xml:"w:cols,omitempty"`
}

// PageSize represents w:pgSz element (page size).
type PageSize struct {
        XMLName xml.Name `xml:"w:pgSz"`
        Width   int      `xml:"w:w,attr"`                // Width in twips
        Height  int      `xml:"w:h,attr"`                // Height in twips
        Orient  string   `xml:"w:orient,attr,omitempty"` // portrait or landscape
}

// PageMargins represents w:pgMar element (page margins).
type PageMargins struct {
        XMLName xml.Name `xml:"w:pgMar"`
        Top     int      `xml:"w:top,attr"`
        Right   int      `xml:"w:right,attr"`
        Bottom  int      `xml:"w:bottom,attr"`
        Left    int      `xml:"w:left,attr"`
        Header  int      `xml:"w:header,attr"`
        Footer  int      `xml:"w:footer,attr"`
        Gutter  int      `xml:"w:gutter,attr,omitempty"`
}

// Columns represents w:cols element (column definition).
type Columns struct {
        XMLName xml.Name `xml:"w:cols"`
        Num     int      `xml:"w:num,attr,omitempty"`   // Number of columns
        Space   int      `xml:"w:space,attr,omitempty"` // Space between columns
        Sep     *bool    `xml:"w:sep,attr,omitempty"`   // Draw separator line
}

// HeaderRef represents w:headerReference element.
type HeaderRef struct {
        XMLName xml.Name `xml:"w:headerReference"`
        Type    string   `xml:"w:type,attr"` // default, first, even
        ID      string   `xml:"r:id,attr"`   // Relationship ID
}

// FooterRef represents w:footerReference element.
type FooterRef struct {
        XMLName xml.Name `xml:"w:footerReference"`
        Type    string   `xml:"w:type,attr"` // default, first, even
        ID      string   `xml:"r:id,attr"`   // Relationship ID
}

// SectionType represents w:type element (section type).
type SectionType struct {
        XMLName xml.Name `xml:"w:type"`
        Val     string   `xml:"w:val,attr"` // nextPage, continuous, evenPage, oddPage
}

// NewSectionProperties creates a new section properties element.
func NewSectionProperties() *SectionProperties <span class="cov8" title="1">{
        return &amp;SectionProperties{
                HeaderRef: make([]HeaderRef, 0),
                FooterRef: make([]FooterRef, 0),
        }
}</span>

// SetPageSize sets the page size for the section.
func (sp *SectionProperties) SetPageSize(width, height int, landscape bool) <span class="cov8" title="1">{
        pgWidth, pgHeight := width, height
        if landscape &amp;&amp; width &lt; height </span><span class="cov0" title="0">{
                pgWidth, pgHeight = height, width
        }</span>

        <span class="cov8" title="1">sp.PageSize = &amp;PageSize{
                Width:  pgWidth,
                Height: pgHeight,
        }

        if landscape </span><span class="cov8" title="1">{
                sp.PageSize.Orient = "landscape"
        }</span>
}

// SetPageMargins sets the page margins for the section.
func (sp *SectionProperties) SetPageMargins(top, right, bottom, left, header, footer int) <span class="cov8" title="1">{
        sp.PageMargins = &amp;PageMargins{
                Top:    top,
                Right:  right,
                Bottom: bottom,
                Left:   left,
                Header: header,
                Footer: footer,
        }
}</span>

// SetColumns sets the number of columns for the section.
func (sp *SectionProperties) SetColumns(num int) <span class="cov8" title="1">{
        sp.Columns = &amp;Columns{
                Num:   num,
                Space: 720,
        }
}</span>

// AddHeaderRef adds a header reference.
func (sp *SectionProperties) AddHeaderRef(headerType, rID string) <span class="cov8" title="1">{
        sp.HeaderRef = append(sp.HeaderRef, HeaderRef{
                Type: headerType,
                ID:   rID,
        })
}</span>

// AddFooterRef adds a footer reference.
func (sp *SectionProperties) AddFooterRef(footerType, rID string) <span class="cov8" title="1">{
        sp.FooterRef = append(sp.FooterRef, FooterRef{
                Type: footerType,
                ID:   rID,
        })
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package xml

import "encoding/xml"

// Styles represents the styles.xml document.
type Styles struct {
        XMLName      xml.Name      `xml:"w:styles"`
        Xmlns        string        `xml:"xmlns:w,attr"`
        LatentStyles *LatentStyles `xml:"w:latentStyles,omitempty"`
        DocDefaults  *DocDefaults  `xml:"w:docDefaults,omitempty"`
        Styles       []*Style      `xml:"w:style"`
}

// DocDefaults represents w:docDefaults element.
type DocDefaults struct {
        XMLName      xml.Name           `xml:"w:docDefaults"`
        RunDefaults  *RunDefaults       `xml:"w:rPrDefault,omitempty"`
        ParaDefaults *ParagraphDefaults `xml:"w:pPrDefault,omitempty"`
}

// RunDefaults represents default run properties.
type RunDefaults struct {
        XMLName    xml.Name       `xml:"w:rPrDefault"`
        Properties *RunProperties `xml:"w:rPr,omitempty"`
}

// ParagraphDefaults represents default paragraph properties.
type ParagraphDefaults struct {
        XMLName    xml.Name                  `xml:"w:pPrDefault"`
        Properties *StyleParagraphProperties `xml:"w:pPr,omitempty"`
}

// Style represents w:style element.
type Style struct {
        XMLName     xml.Name                  `xml:"w:style"`
        Type        string                    `xml:"w:type,attr"` // paragraph, character, table, numbering
        StyleID     string                    `xml:"w:styleId,attr"`
        Default     *bool                     `xml:"w:default,attr,omitempty"`
        CustomStyle *bool                     `xml:"w:customStyle,attr,omitempty"`
        Name        *StyleName                `xml:"w:name,omitempty"`
        BasedOn     *BasedOn                  `xml:"w:basedOn,omitempty"`
        Next        *Next                     `xml:"w:next,omitempty"`
        UIPriority  *UIPriority               `xml:"w:uiPriority,omitempty"`
        QFormat     *struct{}                 `xml:"w:qFormat,omitempty"`
        ParaProps   *StyleParagraphProperties `xml:"w:pPr,omitempty"` // Must come before rPr per OOXML spec
        RunProps    *RunProperties            `xml:"w:rPr,omitempty"`
}

// StyleName represents w:name element.
type StyleName struct {
        XMLName xml.Name `xml:"w:name"`
        Val     string   `xml:"w:val,attr"`
}

// BasedOn represents w:basedOn element.
type BasedOn struct {
        XMLName xml.Name `xml:"w:basedOn"`
        Val     string   `xml:"w:val,attr"`
}

// Next represents w:next element (next paragraph style).
type Next struct {
        XMLName xml.Name `xml:"w:next"`
        Val     string   `xml:"w:val,attr"`
}

// UIPriority represents w:uiPriority element.
type UIPriority struct {
        XMLName xml.Name `xml:"w:uiPriority"`
        Val     int      `xml:"w:val,attr"`
}

// StyleParagraphProperties represents w:pPr element (paragraph properties in styles).
type StyleParagraphProperties struct {
        XMLName         xml.Name          `xml:"w:pPr"`
        KeepNext        *struct{}         `xml:"w:keepNext,omitempty"`
        KeepLines       *struct{}         `xml:"w:keepLines,omitempty"`
        PageBreakBefore *struct{}         `xml:"w:pageBreakBefore,omitempty"`
        Spacing         *StyleSpacing     `xml:"w:spacing,omitempty"`
        Indentation     *StyleIndentation `xml:"w:ind,omitempty"`
        Alignment       *Alignment        `xml:"w:jc,omitempty"`
        OutlineLevel    *OutlineLevel     `xml:"w:outlineLvl,omitempty"`
}

// Alignment represents w:jc element (justification/alignment).
type Alignment struct {
        XMLName xml.Name `xml:"w:jc"`
        Val     string   `xml:"w:val,attr"` // left, center, right, both (justified), distribute
}

// StyleSpacing represents w:spacing element (paragraph spacing in styles).
type StyleSpacing struct {
        XMLName  xml.Name `xml:"w:spacing"`
        Before   *int     `xml:"w:before,attr,omitempty"`   // Space before in twips
        After    *int     `xml:"w:after,attr,omitempty"`    // Space after in twips
        Line     *int     `xml:"w:line,attr,omitempty"`     // Line spacing
        LineRule string   `xml:"w:lineRule,attr,omitempty"` // auto, exact, atLeast
}

// StyleIndentation represents w:ind element (paragraph indentation in styles).
type StyleIndentation struct {
        XMLName   xml.Name `xml:"w:ind"`
        Left      *int     `xml:"w:left,attr,omitempty"`      // Left indent in twips
        Right     *int     `xml:"w:right,attr,omitempty"`     // Right indent in twips
        FirstLine *int     `xml:"w:firstLine,attr,omitempty"` // First line indent
        Hanging   *int     `xml:"w:hanging,attr,omitempty"`   // Hanging indent
}

// OutlineLevel represents w:outlineLvl element (outline level 0-9).
type OutlineLevel struct {
        XMLName xml.Name `xml:"w:outlineLvl"`
        Val     int      `xml:"w:val,attr"`
}

// LatentStyles represents w:latentStyles element (latent style metadata).
type LatentStyles struct {
        XMLName           xml.Name                `xml:"w:latentStyles"`
        DefLockedState    string                  `xml:"w:defLockedState,attr,omitempty"`
        DefUIPriority     string                  `xml:"w:defUIPriority,attr,omitempty"`
        DefSemiHidden     string                  `xml:"w:defSemiHidden,attr,omitempty"`
        DefUnhideWhenUsed string                  `xml:"w:defUnhideWhenUsed,attr,omitempty"`
        DefQFormat        string                  `xml:"w:defQFormat,attr,omitempty"`
        Count             string                  `xml:"w:count,attr,omitempty"`
        Exceptions        []*LatentStyleException `xml:"w:lsdException,omitempty"`
}

// LatentStyleException represents w:lsdException element (latent style exception definition).
type LatentStyleException struct {
        XMLName        xml.Name `xml:"w:lsdException"`
        Name           string   `xml:"w:name,attr"`
        UIPriority     string   `xml:"w:uiPriority,attr,omitempty"`
        QFormat        string   `xml:"w:qFormat,attr,omitempty"`
        SemiHidden     string   `xml:"w:semiHidden,attr,omitempty"`
        UnhideWhenUsed string   `xml:"w:unhideWhenUsed,attr,omitempty"`
        Locked         string   `xml:"w:locked,attr,omitempty"`
}

// NewStyles creates a new styles document.
func NewStyles() *Styles <span class="cov8" title="1">{
        return &amp;Styles{
                Xmlns:  "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
                Styles: make([]*Style, 0),
        }
}</span>

// AddStyle adds a style to the styles collection.
func (s *Styles) AddStyle(style *Style) <span class="cov8" title="1">{
        s.Styles = append(s.Styles, style)
}</span>

// NewParagraphStyle creates a new paragraph style.
func NewParagraphStyle(styleID, name string, isDefault bool) *Style <span class="cov8" title="1">{
        style := &amp;Style{
                Type:    "paragraph",
                StyleID: styleID,
                Name:    &amp;StyleName{Val: name},
        }
        if isDefault </span><span class="cov8" title="1">{
                defaultVal := true
                style.Default = &amp;defaultVal
        }</span>
        <span class="cov8" title="1">return style</span>
}

// NewCharacterStyle creates a new character style.
func NewCharacterStyle(styleID, name string, isDefault bool) *Style <span class="cov8" title="1">{
        style := &amp;Style{
                Type:    "character",
                StyleID: styleID,
                Name:    &amp;StyleName{Val: name},
        }
        if isDefault </span><span class="cov0" title="0">{
                defaultVal := true
                style.Default = &amp;defaultVal
        }</span>
        <span class="cov8" title="1">return style</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package docx

import (
        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
)

// Config contains configuration options for document creation.
type Config struct {
        DefaultFont      string
        DefaultFontSize  int
        PageSize         PageSize
        Margins          Margins
        StrictValidation bool
        Metadata         *domain.Metadata
}

// PageSize represents paper dimensions.
type PageSize struct {
        Width  int // in twips (1/1440 inch)
        Height int // in twips
}

// Margins represents page margins.
type Margins struct {
        Top    int // in twips
        Bottom int // in twips
        Left   int // in twips
        Right  int // in twips
}

// Common page sizes in twips (1/1440 inch)
var (
        // A4 is 210mm x 297mm
        A4 = PageSize{Width: 11906, Height: 16838}

        // Letter is 8.5" x 11"
        Letter = PageSize{Width: 12240, Height: 15840}

        // Legal is 8.5" x 14"
        Legal = PageSize{Width: 12240, Height: 20160}

        // A3 is 297mm x 420mm
        A3 = PageSize{Width: 16838, Height: 23811}

        // Tabloid is 11" x 17"
        Tabloid = PageSize{Width: 15840, Height: 24480}
)

// Common margins presets
var (
        // NormalMargins is 1 inch on all sides
        NormalMargins = Margins{
                Top:    1440,
                Bottom: 1440,
                Left:   1440,
                Right:  1440,
        }

        // NarrowMargins is 0.5 inch on all sides
        NarrowMargins = Margins{
                Top:    720,
                Bottom: 720,
                Left:   720,
                Right:  720,
        }

        // WideMargins is 1 inch top/bottom, 2 inch left/right
        WideMargins = Margins{
                Top:    1440,
                Bottom: 1440,
                Left:   2880,
                Right:  2880,
        }
)

// Option is a function that configures a Config.
type Option func(*Config)

// defaultConfig returns the default configuration.
func defaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DefaultFont:      constants.DefaultFontName,
                DefaultFontSize:  constants.DefaultFontSize,
                PageSize:         Letter,
                Margins:          NormalMargins,
                StrictValidation: false,
                Metadata:         &amp;domain.Metadata{},
        }
}</span>

// WithDefaultFont sets the default font for the document.
//
// Example:
//
//        builder := docx.NewDocumentBuilder(
//            docx.WithDefaultFont("Arial"),
//        )
func WithDefaultFont(font string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.DefaultFont = font
        }</span>
}

// WithDefaultFontSize sets the default font size in half-points.
//
// Example:
//
//        builder := docx.NewDocumentBuilder(
//            docx.WithDefaultFontSize(24), // 12pt
//        )
func WithDefaultFontSize(halfPoints int) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.DefaultFontSize = halfPoints
        }</span>
}

// WithPageSize sets the page size for the document.
//
// Example:
//
//        builder := docx.NewDocumentBuilder(
//            docx.WithPageSize(docx.A4),
//        )
func WithPageSize(size PageSize) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.PageSize = size
        }</span>
}

// WithMargins sets the page margins for the document.
//
// Example:
//
//        builder := docx.NewDocumentBuilder(
//            docx.WithMargins(docx.NarrowMargins),
//        )
func WithMargins(margins Margins) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Margins = margins
        }</span>
}

// WithStrictValidation enables strict validation of the document structure.
// When enabled, Build() will perform more rigorous checks.
//
// Example:
//
//        builder := docx.NewDocumentBuilder(
//            docx.WithStrictValidation(),
//        )
func WithStrictValidation() Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.StrictValidation = true
        }</span>
}

// WithMetadata sets the document metadata.
//
// Example:
//
//        meta := &amp;domain.Metadata{
//            Title:   "My Document",
//            Author:  "John Doe",
//            Subject: "Report",
//        }
//        builder := docx.NewDocumentBuilder(
//            docx.WithMetadata(meta),
//        )
func WithMetadata(meta *domain.Metadata) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Metadata = meta
        }</span>
}

// WithTitle is a convenience function to set the document title.
func WithTitle(title string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                if c.Metadata == nil </span><span class="cov0" title="0">{
                        c.Metadata = &amp;domain.Metadata{}
                }</span>
                <span class="cov8" title="1">c.Metadata.Title = title</span>
        }
}

// WithAuthor is a convenience function to set the document author.
func WithAuthor(author string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                if c.Metadata == nil </span><span class="cov0" title="0">{
                        c.Metadata = &amp;domain.Metadata{}
                }</span>
                <span class="cov8" title="1">c.Metadata.Creator = author</span>
        }
}

// WithSubject is a convenience function to set the document subject.
func WithSubject(subject string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                if c.Metadata == nil </span><span class="cov0" title="0">{
                        c.Metadata = &amp;domain.Metadata{}
                }</span>
                <span class="cov8" title="1">c.Metadata.Subject = subject</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Package color provides color utilities for go-docx v2.
package color

import (
        "fmt"
        "strconv"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// Common color constants for convenience.
var (
        Black   = domain.Color{R: 0, G: 0, B: 0}
        White   = domain.Color{R: 255, G: 255, B: 255}
        Red     = domain.Color{R: 255, G: 0, B: 0}
        Green   = domain.Color{R: 0, G: 128, B: 0}
        Blue    = domain.Color{R: 0, G: 0, B: 255}
        Yellow  = domain.Color{R: 255, G: 255, B: 0}
        Cyan    = domain.Color{R: 0, G: 255, B: 255}
        Magenta = domain.Color{R: 255, G: 0, B: 255}
        Orange  = domain.Color{R: 255, G: 165, B: 0}
        Purple  = domain.Color{R: 128, G: 0, B: 128}
        Gray    = domain.Color{R: 128, G: 128, B: 128}
        Silver  = domain.Color{R: 192, G: 192, B: 192}
)

// ToHex converts a Color to a hex string (e.g., "FF0000" for red).
func ToHex(c domain.Color) string <span class="cov8" title="1">{
        return fmt.Sprintf("%02X%02X%02X", c.R, c.G, c.B)
}</span>

// FromHex creates a Color from a hex string.
// Accepts formats: "RGB", "RRGGBB", "#RGB", "#RRGGBB"
func FromHex(hex string) (domain.Color, error) <span class="cov8" title="1">{
        // Remove # if present
        if len(hex) &gt; 0 &amp;&amp; hex[0] == '#' </span><span class="cov8" title="1">{
                hex = hex[1:]
        }</span>

        <span class="cov8" title="1">var r, g, b uint8

        switch len(hex) </span>{
        case 3:<span class="cov8" title="1">
                // Short form: RGB -&gt; RRGGBB
                rv, err := strconv.ParseUint(string(hex[0]), 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid red component")
                }</span>
                <span class="cov8" title="1">gv, err := strconv.ParseUint(string(hex[1]), 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid green component")
                }</span>
                <span class="cov8" title="1">bv, err := strconv.ParseUint(string(hex[2]), 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid blue component")
                }</span>
                <span class="cov8" title="1">r = uint8(rv*16 + rv)
                g = uint8(gv*16 + gv)
                b = uint8(bv*16 + bv)</span>

        case 6:<span class="cov8" title="1">
                // Full form: RRGGBB
                rv, err := strconv.ParseUint(hex[0:2], 16, 8)
                if err != nil </span><span class="cov8" title="1">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid red component")
                }</span>
                <span class="cov8" title="1">gv, err := strconv.ParseUint(hex[2:4], 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid green component")
                }</span>
                <span class="cov8" title="1">bv, err := strconv.ParseUint(hex[4:6], 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid blue component")
                }</span>
                <span class="cov8" title="1">r = uint8(rv)
                g = uint8(gv)
                b = uint8(bv)</span>

        default:<span class="cov8" title="1">
                return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex,
                        "hex color must be 3 or 6 characters (optionally prefixed with #)")</span>
        }

        <span class="cov8" title="1">return domain.Color{R: r, G: g, B: b}, nil</span>
}

// Validate checks if a color is valid (all components in range 0-255).
func Validate(_ domain.Color) error <span class="cov8" title="1">{
        // uint8 automatically ensures 0-255 range, so this is always valid
        return nil
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Monterroca
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Package errors provides structured error types for go-docx v2.
package errors

import (
        "fmt"
        "strings"
)

// Error codes for categorizing errors
const (
        ErrCodeValidation   = "VALIDATION_ERROR"
        ErrCodeNotFound     = "NOT_FOUND"
        ErrCodeInvalidState = "INVALID_STATE"
        ErrCodeIO           = "IO_ERROR"
        ErrCodeXML          = "XML_ERROR"
        ErrCodeInternal     = "INTERNAL_ERROR"
        ErrCodeUnsupported  = "UNSUPPORTED"
)

// DocxError represents a structured error in go-docx v2.
type DocxError struct {
        Code    string                 // Error code (e.g., "VALIDATION_ERROR")
        Op      string                 // Operation that failed (e.g., "Document.AddParagraph")
        Err     error                  // Underlying error
        Message string                 // Human-readable message
        Context map[string]interface{} // Additional context
}

// Error implements the error interface.
func (e *DocxError) Error() string <span class="cov8" title="1">{
        var parts []string

        if e.Op != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("operation=%s", e.Op))
        }</span>

        <span class="cov8" title="1">if e.Code != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("code=%s", e.Code))
        }</span>

        <span class="cov8" title="1">if e.Message != "" </span><span class="cov8" title="1">{
                parts = append(parts, e.Message)
        }</span>

        <span class="cov8" title="1">if e.Err != nil </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("cause=%v", e.Err))
        }</span>

        <span class="cov8" title="1">if len(e.Context) &gt; 0 </span><span class="cov8" title="1">{
                var ctx []string
                for k, v := range e.Context </span><span class="cov8" title="1">{
                        ctx = append(ctx, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("context={%s}", strings.Join(ctx, ", ")))</span>
        }

        <span class="cov8" title="1">return strings.Join(parts, " | ")</span>
}

// Unwrap returns the underlying error.
func (e *DocxError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// Is checks if the error matches the target error.
func (e *DocxError) Is(target error) bool <span class="cov8" title="1">{
        t, ok := target.(*DocxError)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return e.Code == t.Code</span>
}

// ValidationError represents a validation error.
type ValidationError struct {
        Field      string      // Field name that failed validation
        Value      interface{} // Invalid value
        Constraint string      // Constraint that was violated
        Message    string      // Human-readable message
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("validation error: field=%s, value=%v, constraint=%s, message=%s",
                        e.Field, e.Value, e.Constraint, e.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("validation error: field=%s, value=%v, constraint=%s",
                e.Field, e.Value, e.Constraint)</span>
}

// BuilderError wraps an error and allows method chaining to continue
// while capturing the first error that occurred.
type BuilderError struct {
        err error
}

// Error implements the error interface.
func (b *BuilderError) Error() string <span class="cov8" title="1">{
        if b.err == nil </span><span class="cov8" title="1">{
                return "no error"
        }</span>
        <span class="cov8" title="1">return b.err.Error()</span>
}

// Unwrap returns the underlying error.
func (b *BuilderError) Unwrap() error <span class="cov8" title="1">{
        return b.err
}</span>

// HasError returns true if an error has been captured.
func (b *BuilderError) HasError() bool <span class="cov8" title="1">{
        return b.err != nil
}</span>

// Get returns the captured error (may be nil).
func (b *BuilderError) Get() error <span class="cov8" title="1">{
        return b.err
}</span>

// Set sets the error if one hasn't been set already.
func (b *BuilderError) Set(err error) <span class="cov8" title="1">{
        if b.err == nil &amp;&amp; err != nil </span><span class="cov8" title="1">{
                b.err = err
        }</span>
}

// Helper functions for creating common errors

// Errorf creates a new DocxError with formatted message.
func Errorf(code, op, format string, args ...interface{}) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code:    code,
                Op:      op,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

// Wrap wraps an error with operation context.
func Wrap(err error, op string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;DocxError{
                Code: ErrCodeInternal,
                Op:   op,
                Err:  err,
        }</span>
}

// WrapWithCode wraps an error with operation and error code.
func WrapWithCode(err error, code, op string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;DocxError{
                Code: code,
                Op:   op,
                Err:  err,
        }</span>
}

// WrapWithContext wraps an error with operation and additional context.
func WrapWithContext(err error, op string, context map[string]interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;DocxError{
                Code:    ErrCodeInternal,
                Op:      op,
                Err:     err,
                Context: context,
        }</span>
}

// NotFound creates a "not found" error.
func NotFound(op, item string) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code:    ErrCodeNotFound,
                Op:      op,
                Message: fmt.Sprintf("%s not found", item),
        }
}</span>

// InvalidState creates an "invalid state" error.
func InvalidState(op, message string) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code:    ErrCodeInvalidState,
                Op:      op,
                Message: message,
        }
}</span>

// Validation creates a validation error.
func Validation(field string, value interface{}, constraint, message string) error <span class="cov8" title="1">{
        return &amp;ValidationError{
                Field:      field,
                Value:      value,
                Constraint: constraint,
                Message:    message,
        }
}</span>

// NewValidationError creates a validation error with operation context.
// This is a convenience function for backward compatibility.
func NewValidationError(op, field string, value interface{}, message string) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code: ErrCodeValidation,
                Op:   op,
                Err: &amp;ValidationError{
                        Field:   field,
                        Value:   value,
                        Message: message,
                },
        }
}</span>

// NewNotFoundError creates a "not found" error.
// This is a convenience function for backward compatibility.
func NewNotFoundError(op, field string, value interface{}, message string) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code:    ErrCodeNotFound,
                Op:      op,
                Message: fmt.Sprintf("%s: %v - %s", field, value, message),
        }
}</span>

// InvalidArgument creates a validation error for invalid arguments.
func InvalidArgument(op, field string, value interface{}, message string) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code: ErrCodeValidation,
                Op:   op,
                Err: &amp;ValidationError{
                        Field:   field,
                        Value:   value,
                        Message: message,
                },
        }
}</span>

// Unsupported creates an "unsupported" error.
func Unsupported(op, feature string) error <span class="cov8" title="1">{
        return &amp;DocxError{
                Code:    ErrCodeUnsupported,
                Op:      op,
                Message: fmt.Sprintf("%s is not supported", feature),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
