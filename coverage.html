
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mmonterroca/docxgo/internal/core/document.go (57.1%)</option>
				
				<option value="file1">github.com/mmonterroca/docxgo/internal/core/field.go (87.8%)</option>
				
				<option value="file2">github.com/mmonterroca/docxgo/internal/core/image.go (74.4%)</option>
				
				<option value="file3">github.com/mmonterroca/docxgo/internal/core/paragraph.go (22.0%)</option>
				
				<option value="file4">github.com/mmonterroca/docxgo/internal/core/run.go (44.9%)</option>
				
				<option value="file5">github.com/mmonterroca/docxgo/internal/core/section.go (0.0%)</option>
				
				<option value="file6">github.com/mmonterroca/docxgo/internal/core/table.go (72.7%)</option>
				
				<option value="file7">github.com/mmonterroca/docxgo/internal/manager/character_style.go (62.7%)</option>
				
				<option value="file8">github.com/mmonterroca/docxgo/internal/manager/id.go (0.0%)</option>
				
				<option value="file9">github.com/mmonterroca/docxgo/internal/manager/media.go (0.0%)</option>
				
				<option value="file10">github.com/mmonterroca/docxgo/internal/manager/paragraph_style.go (52.6%)</option>
				
				<option value="file11">github.com/mmonterroca/docxgo/internal/manager/relationship.go (0.0%)</option>
				
				<option value="file12">github.com/mmonterroca/docxgo/internal/manager/style.go (98.1%)</option>
				
				<option value="file13">github.com/mmonterroca/docxgo/internal/serializer/serializer.go (54.5%)</option>
				
				<option value="file14">github.com/mmonterroca/docxgo/internal/writer/zip.go (75.4%)</option>
				
				<option value="file15">github.com/mmonterroca/docxgo/internal/xml/drawing_helper.go (0.0%)</option>
				
				<option value="file16">github.com/mmonterroca/docxgo/internal/xml/field.go (100.0%)</option>
				
				<option value="file17">github.com/mmonterroca/docxgo/internal/xml/headerfooter.go (100.0%)</option>
				
				<option value="file18">github.com/mmonterroca/docxgo/internal/xml/section.go (88.9%)</option>
				
				<option value="file19">github.com/mmonterroca/docxgo/internal/xml/style.go (83.3%)</option>
				
				<option value="file20">github.com/mmonterroca/docxgo/pkg/color/color.go (0.0%)</option>
				
				<option value="file21">github.com/mmonterroca/docxgo/pkg/errors/errors.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Package core provides concrete implementations of domain interfaces for go-docx v2.
//
// This package contains the core document model implementations including:
// - Document: The main document structure
// - Paragraph: Paragraph implementation with formatting
// - Run: Text run implementation with character formatting
// - Table: Table implementation with cells and rows
// - Section: Section implementation with page settings
// - Image: Image embedding and positioning
// - Field: Field implementation (TOC, page numbers, etc.)
//
// These implementations handle the business logic and coordinate with
// internal managers (ID generation, relationships, media, styles) and
// serialization to XML structures.
package core

import (
        "io"
        "os"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/internal/serializer"
        "github.com/mmonterroca/docxgo/internal/writer"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// document implements the domain.Document interface.
type document struct {
        paragraphs   []domain.Paragraph
        tables       []domain.Table
        sections     []domain.Section
        metadata     *domain.Metadata
        idGen        *manager.IDGenerator
        relManager   *manager.RelationshipManager
        mediaManager *manager.MediaManager
}

// NewDocument creates a new Document.
func NewDocument() domain.Document <span class="cov10" title="15">{
        idGen := manager.NewIDGenerator()
        return &amp;document{
                paragraphs:   make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                tables:       make([]domain.Table, 0, constants.DefaultTableCapacity),
                sections:     make([]domain.Section, 0, 1),
                metadata:     &amp;domain.Metadata{},
                idGen:        idGen,
                relManager:   manager.NewRelationshipManager(idGen),
                mediaManager: manager.NewMediaManager(idGen),
        }
}</span>

// AddParagraph adds a new paragraph to the document.
func (d *document) AddParagraph() (domain.Paragraph, error) <span class="cov9" title="12">{
        id := d.idGen.NextParagraphID()
        para := NewParagraph(id, d.idGen, d.relManager)
        d.paragraphs = append(d.paragraphs, para)
        return para, nil
}</span>

// AddTable adds a new table with the specified dimensions.
func (d *document) AddTable(rows, cols int) (domain.Table, error) <span class="cov8" title="10">{
        if rows &lt; constants.MinTableRows || rows &gt; constants.MaxTableRows </span><span class="cov4" title="3">{
                return nil, errors.InvalidArgument("Document.AddTable", "rows", rows,
                        "rows must be between 1 and 1000")
        }</span>
        <span class="cov7" title="7">if cols &lt; constants.MinTableCols || cols &gt; constants.MaxTableCols </span><span class="cov4" title="3">{
                return nil, errors.InvalidArgument("Document.AddTable", "cols", cols,
                        "columns must be between 1 and 63")
        }</span>

        <span class="cov5" title="4">id := d.idGen.NextTableID()
        table := NewTable(id, rows, cols, d.idGen, d.relManager)
        d.tables = append(d.tables, table)
        return table, nil</span>
}

// AddSection adds a new section to the document.
func (d *document) AddSection() (domain.Section, error) <span class="cov0" title="0">{
        // TODO: Implement section creation
        return nil, errors.Unsupported("Document.AddSection", "sections not yet implemented")
}</span>

// DefaultSection returns the default (first) section of the document.
func (d *document) DefaultSection() (domain.Section, error) <span class="cov0" title="0">{
        if len(d.sections) == 0 </span><span class="cov0" title="0">{
                // Create default section if it doesn't exist
                section := NewSection(d.relManager, d.idGen)
                d.sections = append(d.sections, section)
                return section, nil
        }</span>
        <span class="cov0" title="0">return d.sections[0], nil</span>
}

// Paragraphs returns all paragraphs in the document.
func (d *document) Paragraphs() []domain.Paragraph <span class="cov8" title="11">{
        // Return a copy to prevent external modification
        paras := make([]domain.Paragraph, len(d.paragraphs))
        copy(paras, d.paragraphs)
        return paras
}</span>

// Tables returns all tables in the document.
func (d *document) Tables() []domain.Table <span class="cov6" title="6">{
        tables := make([]domain.Table, len(d.tables))
        copy(tables, d.tables)
        return tables
}</span>

// Sections returns all sections in the document.
func (d *document) Sections() []domain.Section <span class="cov0" title="0">{
        sections := make([]domain.Section, len(d.sections))
        copy(sections, d.sections)
        return sections
}</span>

// WriteTo writes the document to the provided writer in .docx format.
func (d *document) WriteTo(w io.Writer) (int64, error) <span class="cov4" title="3">{
        // Serialize domain objects to XML structures
        ser := serializer.NewDocumentSerializer()
        xmlDoc := ser.SerializeDocument(d)

        // Create ZIP writer
        zipWriter := writer.NewZipWriter(w)
        defer zipWriter.Close()

        // Build relationships from relationship manager
        rels := d.relManager.ToXML()

        // Serialize metadata
        coreProps := ser.SerializeCoreProperties(d.metadata)
        appProps := ser.SerializeAppProperties(d)

        // Write document structure
        if err := zipWriter.WriteDocument(xmlDoc, rels, coreProps, appProps); err != nil </span><span class="cov0" title="0">{
                return 0, errors.WrapWithCode(err, errors.ErrCodeIO, "Document.WriteTo")
        }</span>

        // Get byte count from writer if available
        // For now, return 0 as ZipWriter doesn't track total bytes
        // This could be enhanced by wrapping the writer with a counting writer
        <span class="cov4" title="3">return 0, nil</span>
}

// SaveAs saves the document to the specified file path.
func (d *document) SaveAs(path string) error <span class="cov1" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Document.SaveAs", "path", path, "path cannot be empty")
        }</span>

        // Create file
        <span class="cov1" title="1">file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.WrapWithCode(err, errors.ErrCodeIO, "Document.SaveAs")
        }</span>
        <span class="cov1" title="1">defer file.Close()

        // Write document
        _, err = d.WriteTo(file)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Document.SaveAs")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Validate checks if the document structure is valid.
func (d *document) Validate() error <span class="cov0" title="0">{
        // Basic validation
        if len(d.paragraphs) == 0 &amp;&amp; len(d.tables) == 0 </span><span class="cov0" title="0">{
                return errors.InvalidState("Document.Validate", "document is empty")
        }</span>

        // Validate each paragraph
        <span class="cov0" title="0">for i, para := range d.paragraphs </span><span class="cov0" title="0">{
                if para == nil </span><span class="cov0" title="0">{
                        return errors.InvalidState("Document.Validate",
                                "paragraph at index "+string(rune(i))+" is nil")
                }</span>
        }

        // Validate each table
        <span class="cov0" title="0">for i, table := range d.tables </span><span class="cov0" title="0">{
                if table == nil </span><span class="cov0" title="0">{
                        return errors.InvalidState("Document.Validate",
                                "table at index "+string(rune(i))+" is nil")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Metadata returns the document's metadata.
func (d *document) Metadata() *domain.Metadata <span class="cov0" title="0">{
        return d.metadata
}</span>

// SetMetadata updates the document's metadata.
func (d *document) SetMetadata(meta *domain.Metadata) error <span class="cov0" title="0">{
        if meta == nil </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Document.SetMetadata", "meta", meta, "metadata cannot be nil")
        }</span>
        <span class="cov0" title="0">d.metadata = meta
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package core

import (
        "fmt"
        "strings"
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// docxField implements the Field interface.
type docxField struct {
        mu         sync.RWMutex
        fieldType  domain.FieldType
        code       string
        result     string
        isDirty    bool // Indicates if field needs recalculation
        properties map[string]string
}

// NewField creates a new field with the specified type.
func NewField(fieldType domain.FieldType) domain.Field <span class="cov6" title="23">{
        field := &amp;docxField{
                fieldType:  fieldType,
                isDirty:    true,
                properties: make(map[string]string),
        }

        // Set default code based on type
        field.code = field.getDefaultCode()

        return field
}</span>

// NewPageNumberField creates a field for page numbering.
func NewPageNumberField() domain.Field <span class="cov1" title="1">{
        field := NewField(domain.FieldTypePageNumber)
        return field
}</span>

// NewPageCountField creates a field for total page count.
func NewPageCountField() domain.Field <span class="cov1" title="1">{
        field := NewField(domain.FieldTypePageCount)
        return field
}</span>

// NewTOCField creates a Table of Contents field with options.
func NewTOCField(switches map[string]string) domain.Field <span class="cov3" title="3">{
        field := NewField(domain.FieldTypeTOC).(*docxField)
        
        // Apply switches
        for key, value := range switches </span><span class="cov2" title="2">{
                field.properties[key] = value
        }</span>
        
        // Rebuild code with switches
        <span class="cov3" title="3">field.code = field.buildTOCCode()
        
        return field</span>
}

// NewHyperlinkField creates a hyperlink field.
func NewHyperlinkField(url, displayText string) domain.Field <span class="cov2" title="2">{
        field := NewField(domain.FieldTypeHyperlink).(*docxField)
        field.properties["url"] = url
        field.properties["display"] = displayText
        field.code = fmt.Sprintf(`HYPERLINK "%s"`, url)
        field.result = displayText
        field.isDirty = false
        return field
}</span>

// NewStyleRefField creates a STYLEREF field.
func NewStyleRefField(styleName string) domain.Field <span class="cov2" title="2">{
        field := NewField(domain.FieldTypeStyleRef).(*docxField)
        field.properties["style"] = styleName
        field.code = fmt.Sprintf(`STYLEREF "%s"`, styleName)
        return field
}</span>

// Type returns the field type.
func (f *docxField) Type() domain.FieldType <span class="cov9" title="111">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.fieldType
}</span>

// Code returns the field code.
func (f *docxField) Code() string <span class="cov10" title="112">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.code
}</span>

// SetCode sets the field code.
func (f *docxField) SetCode(code string) error <span class="cov3" title="4">{
        if strings.TrimSpace(code) == "" </span><span class="cov2" title="2">{
                return errors.NewValidationError(
                        "SetCode",
                        "code",
                        code,
                        "field code cannot be empty",
                )
        }</span>

        <span class="cov2" title="2">f.mu.Lock()
        defer f.mu.Unlock()
        
        f.code = code
        f.isDirty = true
        
        return nil</span>
}

// Result returns the field result (calculated value).
func (f *docxField) Result() string <span class="cov9" title="107">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.result
}</span>

// Update recalculates the field result.
func (f *docxField) Update() error <span class="cov9" title="109">{
        f.mu.Lock()
        defer f.mu.Unlock()

        if !f.isDirty </span><span class="cov9" title="99">{
                return nil // No update needed
        }</span>

        // Update based on field type
        <span class="cov5" title="10">switch f.fieldType </span>{
        case domain.FieldTypePageNumber:<span class="cov4" title="5">
                f.result = "1"</span> // Placeholder - actual value determined by Word
        case domain.FieldTypePageCount:<span class="cov1" title="1">
                f.result = "1"</span> // Placeholder - actual value determined by Word
        case domain.FieldTypeNumPages:<span class="cov0" title="0">
                f.result = "1"</span> // Placeholder - actual value determined by Word
        case domain.FieldTypeTOC:<span class="cov1" title="1">
                f.result = "Table of Contents"</span> // Placeholder
        case domain.FieldTypeStyleRef:<span class="cov0" title="0">
                f.result = ""</span> // Placeholder - populated by Word
        case domain.FieldTypeHyperlink:<span class="cov0" title="0">
                // Result is the display text
                if display, ok := f.properties["display"]; ok </span><span class="cov0" title="0">{
                        f.result = display
                }</span>
        case domain.FieldTypeDate:<span class="cov1" title="1">
                f.result = "1/1/2025"</span> // Placeholder
        case domain.FieldTypeTime:<span class="cov0" title="0">
                f.result = "12:00:00"</span> // Placeholder
        case domain.FieldTypeSeq:<span class="cov1" title="1">
                f.result = "1"</span> // Placeholder
        case domain.FieldTypeRef:<span class="cov0" title="0">
                f.result = ""</span> // Placeholder - populated by Word
        case domain.FieldTypeCustom:<span class="cov1" title="1">
                f.result = ""</span> // Custom fields have user-defined results
        default:<span class="cov0" title="0">
                f.result = ""</span> // Unknown field type
        }

        <span class="cov5" title="10">f.isDirty = false
        return nil</span>
}

// getDefaultCode returns the default field code for the field type.
func (f *docxField) getDefaultCode() string <span class="cov6" title="23">{
        switch f.fieldType </span>{
        case domain.FieldTypePageNumber:<span class="cov4" title="5">
                return constants.FieldCodePageNumber</span>
        case domain.FieldTypePageCount:<span class="cov3" title="3">
                return constants.FieldCodeNumPages</span>
        case domain.FieldTypeNumPages:<span class="cov0" title="0">
                return constants.FieldCodeNumPages</span>
        case domain.FieldTypeTOC:<span class="cov4" title="5">
                return constants.FieldCodeTOC + ` \\o "1-3" \\h \\z \\u`</span>
        case domain.FieldTypeDate:<span class="cov2" title="2">
                return constants.FieldCodeDate</span>
        case domain.FieldTypeTime:<span class="cov0" title="0">
                return constants.FieldCodeTime</span>
        case domain.FieldTypeStyleRef:<span class="cov2" title="2">
                return constants.FieldCodeStyleRef + ` "Heading 1"`</span>
        case domain.FieldTypeSeq:<span class="cov1" title="1">
                return constants.FieldCodeSeq + ` Figure`</span>
        case domain.FieldTypeRef:<span class="cov0" title="0">
                return constants.FieldCodeRef</span>
        case domain.FieldTypeHyperlink:<span class="cov2" title="2">
                return "HYPERLINK"</span> // Hyperlink fields use HYPERLINK code
        case domain.FieldTypeCustom:<span class="cov3" title="3">
                return ""</span> // Custom fields require user-defined codes
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// buildTOCCode builds a TOC field code with switches.
func (f *docxField) buildTOCCode() string <span class="cov3" title="3">{
        code := constants.FieldCodeTOC

        // Heading levels (default 1-3)
        if levels, ok := f.properties["levels"]; ok </span><span class="cov1" title="1">{
                code += fmt.Sprintf(` \\o "%s"`, levels)
        }</span> else<span class="cov2" title="2"> {
                code += ` \\o "1-3"`
        }</span>

        // Hyperlinks (always included by default)
        <span class="cov3" title="3">code += ` \\h`

        // Hide page numbers
        if _, ok := f.properties["hidePageNumbers"]; ok </span><span class="cov1" title="1">{
                code += ` \\n`
        }</span>

        // Hide tab leader
        <span class="cov3" title="3">if _, ok := f.properties["hideTabLeader"]; ok </span><span class="cov0" title="0">{
                code += ` \\p`
        }</span>

        // Preserve tab entries
        <span class="cov3" title="3">code += ` \\z`

        // Use styles
        code += ` \\u`

        return code</span>
}

// SetProperty sets a field property (for advanced customization).
func (f *docxField) SetProperty(key, value string) <span class="cov2" title="2">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.properties[key] = value
        f.isDirty = true
}</span>

// GetProperty gets a field property.
func (f *docxField) GetProperty(key string) (string, bool) <span class="cov4" title="5">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        value, ok := f.properties[key]
        return value, ok
}</span>

// IsDirty returns whether the field needs updating.
func (f *docxField) IsDirty() bool <span class="cov4" title="5">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return f.isDirty
}</span>

// MarkDirty marks the field as needing an update.
func (f *docxField) MarkDirty() <span class="cov1" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.isDirty = true
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package core

import (
        "fmt"
        "image"
        _ "image/gif"  // Register GIF format decoder
        _ "image/jpeg" // Register JPEG format decoder
        _ "image/png"  // Register PNG format decoder
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// docxImage implements the domain.Image interface.
type docxImage struct {
        id             string
        format         domain.ImageFormat
        size           domain.ImageSize
        originalSize   domain.ImageSize
        data           []byte
        relationshipID string
        target         string
        description    string
        position       domain.ImagePosition
}

// NewImage creates a new image from a file path.
func NewImage(id, path string) (domain.Image, error) <span class="cov10" title="19">{
        // Read image file
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WrapWithCode(err, errors.ErrCodeIO, "NewImage")
        }</span>

        // Detect format from extension
        <span class="cov10" title="19">format := detectImageFormat(path)
        if format == "" </span><span class="cov1" title="1">{
                return nil, errors.InvalidArgument("NewImage", "path", path, "unsupported image format")
        }</span>

        // Get image dimensions
        <span class="cov9" title="18">size, err := getImageDimensions(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "NewImage")
        }</span>

        // Generate target path
        <span class="cov9" title="18">ext := strings.ToLower(filepath.Ext(path))
        if ext == "" </span><span class="cov0" title="0">{
                ext = "." + string(format)
        }</span>
        <span class="cov9" title="18">target := fmt.Sprintf("media/image%s%s", id, ext)

        return &amp;docxImage{
                id:           id,
                format:       format,
                size:         size,
                originalSize: size,
                data:         data,
                target:       target,
                description:  "",
                position:     domain.DefaultImagePosition(),
        }, nil</span>
}

// NewImageWithSize creates a new image with custom dimensions.
func NewImageWithSize(id, path string, size domain.ImageSize) (domain.Image, error) <span class="cov3" title="2">{
        img, err := NewImage(id, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if err := img.SetSize(size); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return img, nil</span>
}

// NewImageWithPosition creates a new image with custom positioning.
func NewImageWithPosition(id, path string, size domain.ImageSize, pos domain.ImagePosition) (domain.Image, error) <span class="cov1" title="1">{
        img, err := NewImageWithSize(id, path, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">docxImg := img.(*docxImage)
        docxImg.position = pos

        return img, nil</span>
}

// ID returns the unique image ID.
func (img *docxImage) ID() string <span class="cov6" title="6">{
        return img.id
}</span>

// Format returns the image format.
func (img *docxImage) Format() domain.ImageFormat <span class="cov9" title="14">{
        return img.format
}</span>

// Size returns the image dimensions.
func (img *docxImage) Size() domain.ImageSize <span class="cov6" title="6">{
        return img.size
}</span>

// SetSize sets custom dimensions for the image.
func (img *docxImage) SetSize(size domain.ImageSize) error <span class="cov4" title="3">{
        // If width or height is 0, maintain aspect ratio
        if size.WidthPx == 0 &amp;&amp; size.HeightPx == 0 </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Image.SetSize", "size", size, "both width and height cannot be zero")
        }</span>

        <span class="cov4" title="3">if size.WidthPx == 0 </span><span class="cov0" title="0">{
                // Calculate width from height maintaining aspect ratio
                ratio := float64(img.originalSize.WidthPx) / float64(img.originalSize.HeightPx)
                size.WidthPx = int(float64(size.HeightPx) * ratio)
                size.WidthEMU = size.WidthPx * 9525
        }</span> else<span class="cov4" title="3"> if size.HeightPx == 0 </span><span class="cov0" title="0">{
                // Calculate height from width maintaining aspect ratio
                ratio := float64(img.originalSize.HeightPx) / float64(img.originalSize.WidthPx)
                size.HeightPx = int(float64(size.WidthPx) * ratio)
                size.HeightEMU = size.HeightPx * 9525
        }</span>

        <span class="cov4" title="3">img.size = size
        return nil</span>
}

// Data returns the raw image data.
func (img *docxImage) Data() []byte <span class="cov4" title="3">{
        // Return copy to prevent external modification
        data := make([]byte, len(img.data))
        copy(data, img.data)
        return data
}</span>

// RelationshipID returns the relationship ID for this image.
func (img *docxImage) RelationshipID() string <span class="cov3" title="2">{
        return img.relationshipID
}</span>

// SetRelationshipID sets the relationship ID (called by manager).
func (img *docxImage) SetRelationshipID(id string) <span class="cov0" title="0">{
        img.relationshipID = id
}</span>

// Target returns the target path in the .docx package.
func (img *docxImage) Target() string <span class="cov4" title="3">{
        return img.target
}</span>

// Description returns the alt text description.
func (img *docxImage) Description() string <span class="cov1" title="1">{
        return img.description
}</span>

// SetDescription sets the alt text description.
func (img *docxImage) SetDescription(desc string) error <span class="cov1" title="1">{
        img.description = desc
        return nil
}</span>

// Position returns the image position settings.
func (img *docxImage) Position() domain.ImagePosition <span class="cov1" title="1">{
        return img.position
}</span>

// detectImageFormat detects the image format from file extension.
func detectImageFormat(path string) domain.ImageFormat <span class="cov10" title="19">{
        ext := strings.ToLower(filepath.Ext(path))
        ext = strings.TrimPrefix(ext, ".")

        switch ext </span>{
        case "png":<span class="cov8" title="10">
                return domain.ImageFormatPNG</span>
        case "jpg", "jpeg":<span class="cov3" title="2">
                return domain.ImageFormatJPEG</span>
        case "gif":<span class="cov1" title="1">
                return domain.ImageFormatGIF</span>
        case "bmp":<span class="cov1" title="1">
                return domain.ImageFormatBMP</span>
        case "tif", "tiff":<span class="cov3" title="2">
                return domain.ImageFormatTIFF</span>
        case "svg":<span class="cov1" title="1">
                return domain.ImageFormatSVG</span>
        case "webp":<span class="cov1" title="1">
                return domain.ImageFormatWEBP</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

// getImageDimensions reads image dimensions from image data.
func getImageDimensions(data []byte) (domain.ImageSize, error) <span class="cov10" title="19">{
        // Decode image to get dimensions
        img, format, err := image.DecodeConfig(strings.NewReader(string(data)))
        if err != nil </span><span class="cov0" title="0">{
                // If decode fails, try reading as binary
                reader := strings.NewReader(string(data))
                img, format, err = image.DecodeConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.ImageSize{}, errors.Wrap(err, "getImageDimensions")
                }</span>
        }

        <span class="cov10" title="19">_ = format // format string is for logging if needed

        return domain.NewImageSize(img.Width, img.Height), nil</span>
}

// ReadImageFromReader creates an image from an io.Reader.
func ReadImageFromReader(id string, reader io.Reader, format domain.ImageFormat) (domain.Image, error) <span class="cov1" title="1">{
        // Read all data
        data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WrapWithCode(err, errors.ErrCodeIO, "ReadImageFromReader")
        }</span>

        // Get dimensions
        <span class="cov1" title="1">size, err := getImageDimensions(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "ReadImageFromReader")
        }</span>

        // Generate target
        <span class="cov1" title="1">target := fmt.Sprintf("media/image%s.%s", id, format)

        return &amp;docxImage{
                id:           id,
                format:       format,
                size:         size,
                originalSize: size,
                data:         data,
                target:       target,
                description:  "",
                position:     domain.DefaultImagePosition(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package core

import (
        "strings"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// IDGenerator interface for testing purposes
type IDGenerator interface {
        NextParagraphID() string
        NextRunID() string
        NextImageID() string
        GenerateID(prefix string) string
}

// paragraph implements the domain.Paragraph interface.
type paragraph struct {
        id            string
        runs          []domain.Run
        fields        []domain.Field
        images        []domain.Image
        styleName     string
        alignment     domain.Alignment
        indent        domain.Indentation
        spacingBefore int
        spacingAfter  int
        lineSpacing   domain.LineSpacing
        idGen         IDGenerator
        relManager    *manager.RelationshipManager
}

// NewParagraph creates a new Paragraph.
func NewParagraph(id string, idGen IDGenerator, relManager *manager.RelationshipManager) domain.Paragraph <span class="cov9" title="19">{
        return &amp;paragraph{
                id:            id,
                runs:          make([]domain.Run, 0, constants.DefaultRunCapacity),
                fields:        make([]domain.Field, 0, 4),
                images:        make([]domain.Image, 0, 4),
                alignment:     domain.AlignmentLeft,
                indent:        domain.Indentation{},
                spacingBefore: constants.DefaultParagraphSpacing,
                spacingAfter:  constants.DefaultParagraphSpacing,
                lineSpacing:   domain.LineSpacing{Rule: domain.LineSpacingAuto, Value: constants.DefaultLineSpacing},
                idGen:         idGen,
                relManager:    relManager,
        }
}</span>

// AddRun adds a new text run to the paragraph.
func (p *paragraph) AddRun() (domain.Run, error) <span class="cov8" title="14">{
        id := p.idGen.NextRunID()
        run := NewRun(id)
        p.runs = append(p.runs, run)
        return run, nil
}</span>

// AddField adds a field to the paragraph.
func (p *paragraph) AddField(_ domain.FieldType) (domain.Field, error) <span class="cov0" title="0">{
        // TODO: Implement field creation
        return nil, errors.Unsupported("Paragraph.AddField", "fields not yet implemented")
}</span>

// AddHyperlink adds a hyperlink to the paragraph.
func (p *paragraph) AddHyperlink(url, displayText string) (domain.Run, error) <span class="cov0" title="0">{
        if url == "" </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Paragraph.AddHyperlink", "url", url, "URL cannot be empty")
        }</span>

        // Add relationship for hyperlink
        <span class="cov0" title="0">_, err := p.relManager.AddHyperlink(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddHyperlink")
        }</span>

        // Create run with hyperlink text
        <span class="cov0" title="0">run, err := p.AddRun()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddHyperlink")
        }</span>

        <span class="cov0" title="0">text := displayText
        if text == "" </span><span class="cov0" title="0">{
                text = url
        }</span>

        <span class="cov0" title="0">err = run.SetText(text)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddHyperlink")
        }</span>

        // Set hyperlink styling (blue, underlined)
        <span class="cov0" title="0">_ = run.SetColor(domain.ColorBlue)
        _ = run.SetUnderline(domain.UnderlineSingle)

        return run, nil</span>
}

// AddImage adds an image to the paragraph from a file path.
func (p *paragraph) AddImage(path string) (domain.Image, error) <span class="cov0" title="0">{
        id := p.idGen.NextImageID()
        img, err := NewImage(id, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImage")
        }</span>

        // Add relationship for image
        <span class="cov0" title="0">relID, err := p.relManager.AddImage(img.Target())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImage")
        }</span>

        // Set relationship ID on image
        <span class="cov0" title="0">if docxImg, ok := img.(*docxImage); ok </span><span class="cov0" title="0">{
                docxImg.SetRelationshipID(relID)
        }</span>

        <span class="cov0" title="0">p.images = append(p.images, img)
        return img, nil</span>
}

// AddImageWithSize adds an image with custom dimensions.
func (p *paragraph) AddImageWithSize(path string, size domain.ImageSize) (domain.Image, error) <span class="cov0" title="0">{
        id := p.idGen.NextImageID()
        img, err := NewImageWithSize(id, path, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImageWithSize")
        }</span>

        // Add relationship for image
        <span class="cov0" title="0">relID, err := p.relManager.AddImage(img.Target())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImageWithSize")
        }</span>

        // Set relationship ID on image
        <span class="cov0" title="0">if docxImg, ok := img.(*docxImage); ok </span><span class="cov0" title="0">{
                docxImg.SetRelationshipID(relID)
        }</span>

        <span class="cov0" title="0">p.images = append(p.images, img)
        return img, nil</span>
}

// AddImageWithPosition adds an image with custom positioning.
func (p *paragraph) AddImageWithPosition(path string, size domain.ImageSize, pos domain.ImagePosition) (domain.Image, error) <span class="cov0" title="0">{
        id := p.idGen.NextImageID()
        img, err := NewImageWithPosition(id, path, size, pos)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImageWithPosition")
        }</span>

        // Add relationship for image
        <span class="cov0" title="0">relID, err := p.relManager.AddImage(img.Target())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Paragraph.AddImageWithPosition")
        }</span>

        // Set relationship ID on image
        <span class="cov0" title="0">if docxImg, ok := img.(*docxImage); ok </span><span class="cov0" title="0">{
                docxImg.SetRelationshipID(relID)
        }</span>

        <span class="cov0" title="0">p.images = append(p.images, img)
        return img, nil</span>
}

// Images returns all images in this paragraph.
func (p *paragraph) Images() []domain.Image <span class="cov0" title="0">{
        images := make([]domain.Image, len(p.images))
        copy(images, p.images)
        return images
}</span>

// Runs returns all runs in this paragraph.
func (p *paragraph) Runs() []domain.Run <span class="cov10" title="23">{
        // Return a copy to prevent external modification
        runs := make([]domain.Run, len(p.runs))
        copy(runs, p.runs)
        return runs
}</span>

// Fields returns all fields in this paragraph.
func (p *paragraph) Fields() []domain.Field <span class="cov0" title="0">{
        fields := make([]domain.Field, len(p.fields))
        copy(fields, p.fields)
        return fields
}</span>

// Text returns the plain text content of the paragraph.
func (p *paragraph) Text() string <span class="cov0" title="0">{
        var sb strings.Builder
        for _, run := range p.runs </span><span class="cov0" title="0">{
                sb.WriteString(run.Text())
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// Style returns the style applied to this paragraph.
func (p *paragraph) Style() domain.Style <span class="cov0" title="0">{
        // TODO: Implement style retrieval
        return nil
}</span>

// SetStyle applies a named style to the paragraph.
func (p *paragraph) SetStyle(styleName string) error <span class="cov0" title="0">{
        if styleName == "" </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetStyle", "styleName", styleName, "style name cannot be empty")
        }</span>
        <span class="cov0" title="0">p.styleName = styleName
        return nil</span>
}

// Alignment returns the paragraph's horizontal alignment.
func (p *paragraph) Alignment() domain.Alignment <span class="cov8" title="16">{
        return p.alignment
}</span>

// SetAlignment sets the paragraph's horizontal alignment.
func (p *paragraph) SetAlignment(align domain.Alignment) error <span class="cov5" title="5">{
        if align &lt; domain.AlignmentLeft || align &gt; domain.AlignmentDistribute </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetAlignment", "align", align, "invalid alignment value")
        }</span>
        <span class="cov5" title="5">p.alignment = align
        return nil</span>
}

// Indent returns the paragraph's indentation settings.
func (p *paragraph) Indent() domain.Indentation <span class="cov8" title="12">{
        return p.indent
}</span>

// SetIndent sets the paragraph's indentation.
func (p *paragraph) SetIndent(indent domain.Indentation) error <span class="cov2" title="2">{
        // Validate indentation values
        if indent.Left &lt; constants.MinIndent || indent.Left &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.Left", indent.Left,
                        "left indent must be between -31680 and 31680 twips (-22 to 22 inches)")
        }</span>
        <span class="cov2" title="2">if indent.Right &lt; constants.MinIndent || indent.Right &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.Right", indent.Right,
                        "right indent must be between -31680 and 31680 twips (-22 to 22 inches)")
        }</span>
        <span class="cov2" title="2">if indent.FirstLine &lt; 0 || indent.FirstLine &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.FirstLine", indent.FirstLine,
                        "first line indent must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov2" title="2">if indent.Hanging &lt; 0 || indent.Hanging &gt; constants.MaxIndent </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent.Hanging", indent.Hanging,
                        "hanging indent must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov2" title="2">if indent.FirstLine &gt; 0 &amp;&amp; indent.Hanging &gt; 0 </span><span class="cov1" title="1">{
                return errors.InvalidArgument("Paragraph.SetIndent", "indent", indent,
                        "cannot have both first line indent and hanging indent")
        }</span>

        <span class="cov1" title="1">p.indent = indent
        return nil</span>
}

// SpacingBefore returns spacing before the paragraph (in twips).
func (p *paragraph) SpacingBefore() int <span class="cov7" title="11">{
        return p.spacingBefore
}</span>

// SetSpacingBefore sets spacing before the paragraph.
func (p *paragraph) SetSpacingBefore(twips int) error <span class="cov0" title="0">{
        if twips &lt; constants.MinSpacing || twips &gt; constants.MaxSpacing </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetSpacingBefore", "twips", twips,
                        "spacing must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov0" title="0">p.spacingBefore = twips
        return nil</span>
}

// SpacingAfter returns spacing after the paragraph (in twips).
func (p *paragraph) SpacingAfter() int <span class="cov7" title="11">{
        return p.spacingAfter
}</span>

// SetSpacingAfter sets spacing after the paragraph.
func (p *paragraph) SetSpacingAfter(twips int) error <span class="cov0" title="0">{
        if twips &lt; constants.MinSpacing || twips &gt; constants.MaxSpacing </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetSpacingAfter", "twips", twips,
                        "spacing must be between 0 and 31680 twips (0 to 22 inches)")
        }</span>
        <span class="cov0" title="0">p.spacingAfter = twips
        return nil</span>
}

// LineSpacing returns the line spacing setting.
func (p *paragraph) LineSpacing() domain.LineSpacing <span class="cov7" title="11">{
        return p.lineSpacing
}</span>

// SetLineSpacing sets the line spacing.
func (p *paragraph) SetLineSpacing(spacing domain.LineSpacing) error <span class="cov0" title="0">{
        if spacing.Rule &lt; domain.LineSpacingAuto || spacing.Rule &gt; domain.LineSpacingAtLeast </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetLineSpacing", "spacing.Rule", spacing.Rule,
                        "invalid line spacing rule")
        }</span>
        <span class="cov0" title="0">if spacing.Value &lt; constants.MinLineSpacing || spacing.Value &gt; constants.MaxLineSpacing </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Paragraph.SetLineSpacing", "spacing.Value", spacing.Value,
                        "line spacing value must be between 0 and 31680 twips")
        }</span>
        <span class="cov0" title="0">p.lineSpacing = spacing
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



// Package core provides core implementations of domain interfaces.
package core

import (
        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// run implements the domain.Run interface.
type run struct {
        id        string
        text      string
        font      domain.Font
        color     domain.Color
        size      int // in half-points
        bold      bool
        italic    bool
        underline domain.UnderlineStyle
        strike    bool
        highlight domain.HighlightColor
        fields    []domain.Field // Fields embedded in this run
}

// NewRun creates a new Run.
func NewRun(id string) domain.Run <span class="cov10" title="14">{
        return &amp;run{
                id:        id,
                font:      domain.Font{Name: constants.DefaultFontName},
                color:     domain.ColorBlack,
                size:      constants.DefaultFontSize,
                underline: domain.UnderlineNone,
                highlight: domain.HighlightNone,
        }
}</span>

// Text returns the text content of this run.
func (r *run) Text() string <span class="cov9" title="12">{
        return r.text
}</span>

// SetText sets the text content of this run.
func (r *run) SetText(text string) error <span class="cov9" title="12">{
        r.text = text
        return nil
}</span>

// Font returns the font settings for this run.
func (r *run) Font() domain.Font <span class="cov9" title="11">{
        return r.font
}</span>

// SetFont sets the font for this run.
func (r *run) SetFont(font domain.Font) error <span class="cov0" title="0">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.SetFont", "font.Name", font.Name, "font name cannot be empty")
        }</span>
        <span class="cov0" title="0">r.font = font
        return nil</span>
}

// Color returns the text color.
func (r *run) Color() domain.Color <span class="cov9" title="12">{
        return r.color
}</span>

// SetColor sets the text color.
func (r *run) SetColor(color domain.Color) error <span class="cov1" title="1">{
        // Color validation is implicit via uint8 type (0-255)
        r.color = color
        return nil
}</span>

// Size returns the font size in half-points.
func (r *run) Size() int <span class="cov10" title="14">{
        return r.size
}</span>

// SetSize sets the font size in half-points.
func (r *run) SetSize(halfPoints int) error <span class="cov7" title="7">{
        if halfPoints &lt; constants.MinFontSize || halfPoints &gt; constants.MaxFontSize </span><span class="cov3" title="2">{
                return errors.InvalidArgument("Run.SetSize", "halfPoints", halfPoints,
                        "font size must be between 2 and 3276 half-points (1pt - 1638pt)")
        }</span>
        <span class="cov6" title="5">r.size = halfPoints
        return nil</span>
}

// Bold returns whether the text is bold.
func (r *run) Bold() bool <span class="cov9" title="12">{
        return r.bold
}</span>

// SetBold sets whether the text is bold.
func (r *run) SetBold(bold bool) error <span class="cov4" title="3">{
        r.bold = bold
        return nil
}</span>

// Italic returns whether the text is italic.
func (r *run) Italic() bool <span class="cov9" title="12">{
        return r.italic
}</span>

// SetItalic sets whether the text is italic.
func (r *run) SetItalic(italic bool) error <span class="cov1" title="1">{
        r.italic = italic
        return nil
}</span>

// Underline returns the underline style.
func (r *run) Underline() domain.UnderlineStyle <span class="cov9" title="11">{
        return r.underline
}</span>

// SetUnderline sets the underline style.
func (r *run) SetUnderline(style domain.UnderlineStyle) error <span class="cov0" title="0">{
        // Validate underline style
        if style &lt; domain.UnderlineNone || style &gt; domain.UnderlineWave </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.SetUnderline", "style", style,
                        "invalid underline style")
        }</span>
        <span class="cov0" title="0">r.underline = style
        return nil</span>
}

// Strike returns whether the text is struck through.
func (r *run) Strike() bool <span class="cov9" title="11">{
        return r.strike
}</span>

// SetStrike sets whether the text is struck through.
func (r *run) SetStrike(strike bool) error <span class="cov0" title="0">{
        r.strike = strike
        return nil
}</span>

// Highlight returns the highlight color.
func (r *run) Highlight() domain.HighlightColor <span class="cov9" title="11">{
        return r.highlight
}</span>

// SetHighlight sets the highlight color.
func (r *run) SetHighlight(color domain.HighlightColor) error <span class="cov0" title="0">{
        // Validate highlight color
        if color &lt; domain.HighlightNone || color &gt; domain.HighlightLightGray </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.SetHighlight", "color", color,
                        "invalid highlight color")
        }</span>
        <span class="cov0" title="0">r.highlight = color
        return nil</span>
}

// AddText is a convenience method that appends text to the run.
func (r *run) AddText(text string) error <span class="cov0" title="0">{
        r.text += text
        return nil
}</span>

// AddField adds a field to this run (e.g., page number, TOC, hyperlink).
func (r *run) AddField(field domain.Field) error <span class="cov0" title="0">{
        if field == nil </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Run.AddField", "field", nil, "field cannot be nil")
        }</span>
        
        <span class="cov0" title="0">if r.fields == nil </span><span class="cov0" title="0">{
                r.fields = make([]domain.Field, 0, 2)
        }</span>
        
        <span class="cov0" title="0">r.fields = append(r.fields, field)
        return nil</span>
}

// Fields returns all fields in this run.
func (r *run) Fields() []domain.Field <span class="cov0" title="0">{
        if r.fields == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Return a defensive copy
        <span class="cov0" title="0">result := make([]domain.Field, len(r.fields))
        copy(result, r.fields)
        return result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package core

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// docxSection implements the Section interface.
type docxSection struct {
        mu            sync.RWMutex
        pageSize      domain.PageSize
        margins       domain.Margins
        orientation   domain.Orientation
        columns       int
        headers       map[domain.HeaderType]*docxHeader
        footers       map[domain.FooterType]*docxFooter
        relationMgr   *manager.RelationshipManager
        idGen         *manager.IDGenerator
}

// NewSection creates a new section with default settings.
func NewSection(relationMgr *manager.RelationshipManager, idGen *manager.IDGenerator) domain.Section <span class="cov0" title="0">{
        return &amp;docxSection{
                pageSize:    domain.PageSizeA4,
                margins:     domain.DefaultMargins,
                orientation: domain.OrientationPortrait,
                columns:     1,
                headers:     make(map[domain.HeaderType]*docxHeader),
                footers:     make(map[domain.FooterType]*docxFooter),
                relationMgr: relationMgr,
                idGen:       idGen,
        }
}</span>

// PageSize returns the page size for this section.
func (s *docxSection) PageSize() domain.PageSize <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.pageSize
}</span>

// SetPageSize sets the page size.
func (s *docxSection) SetPageSize(size domain.PageSize) error <span class="cov0" title="0">{
        if size.Width &lt;= 0 || size.Height &lt;= 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetPageSize",
                        "page size",
                        size,
                        "width and height must be positive",
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.pageSize = size
        return nil</span>
}

// Margins returns the page margins.
func (s *docxSection) Margins() domain.Margins <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.margins
}</span>

// SetMargins sets the page margins.
func (s *docxSection) SetMargins(margins domain.Margins) error <span class="cov0" title="0">{
        if margins.Top &lt; 0 || margins.Right &lt; 0 || margins.Bottom &lt; 0 || margins.Left &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetMargins",
                        "margins",
                        margins,
                        "margins cannot be negative",
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.margins = margins
        return nil</span>
}

// Orientation returns the page orientation.
func (s *docxSection) Orientation() domain.Orientation <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.orientation
}</span>

// SetOrientation sets the page orientation.
func (s *docxSection) SetOrientation(orient domain.Orientation) error <span class="cov0" title="0">{
        if orient != domain.OrientationPortrait &amp;&amp; orient != domain.OrientationLandscape </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetOrientation",
                        "orientation",
                        orient,
                        "must be Portrait or Landscape",
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.orientation = orient
        return nil</span>
}

// Columns returns the number of columns.
func (s *docxSection) Columns() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.columns
}</span>

// SetColumns sets the number of columns.
func (s *docxSection) SetColumns(count int) error <span class="cov0" title="0">{
        if count &lt; 1 || count &gt; constants.MaxColumns </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "SetColumns",
                        "columns",
                        count,
                        "must be between 1 and "+string(rune(constants.MaxColumns)),
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()
        s.columns = count
        return nil</span>
}

// Header returns the header for this section.
func (s *docxSection) Header(headerType domain.HeaderType) (domain.Header, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if header already exists
        if header, exists := s.headers[headerType]; exists </span><span class="cov0" title="0">{
                return header, nil
        }</span>

        // Create new header
        <span class="cov0" title="0">header := &amp;docxHeader{
                headerType:  headerType,
                paragraphs:  make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                relationMgr: s.relationMgr,
                idGen:       s.idGen,
        }

        s.headers[headerType] = header
        return header, nil</span>
}

// Footer returns the footer for this section.
func (s *docxSection) Footer(footerType domain.FooterType) (domain.Footer, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if footer already exists
        if footer, exists := s.footers[footerType]; exists </span><span class="cov0" title="0">{
                return footer, nil
        }</span>

        // Create new footer
        <span class="cov0" title="0">footer := &amp;docxFooter{
                footerType:  footerType,
                paragraphs:  make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                relationMgr: s.relationMgr,
                idGen:       s.idGen,
        }

        s.footers[footerType] = footer
        return footer, nil</span>
}

// docxHeader implements the Header interface.
type docxHeader struct {
        mu          sync.RWMutex
        headerType  domain.HeaderType
        paragraphs  []domain.Paragraph
        relationMgr *manager.RelationshipManager
        idGen       *manager.IDGenerator
}

// AddParagraph adds a paragraph to the header.
func (h *docxHeader) AddParagraph() (domain.Paragraph, error) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        id := h.idGen.NextParagraphID()
        para := NewParagraph(id, h.idGen, h.relationMgr)
        h.paragraphs = append(h.paragraphs, para)
        return para, nil
}</span>

// Paragraphs returns all paragraphs in the header.
func (h *docxHeader) Paragraphs() []domain.Paragraph <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        // Return defensive copy
        result := make([]domain.Paragraph, len(h.paragraphs))
        copy(result, h.paragraphs)
        return result
}</span>

// docxFooter implements the Footer interface.
type docxFooter struct {
        mu          sync.RWMutex
        footerType  domain.FooterType
        paragraphs  []domain.Paragraph
        relationMgr *manager.RelationshipManager
        idGen       *manager.IDGenerator
}

// AddParagraph adds a paragraph to the footer.
func (f *docxFooter) AddParagraph() (domain.Paragraph, error) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()

        id := f.idGen.NextParagraphID()
        para := NewParagraph(id, f.idGen, f.relationMgr)
        f.paragraphs = append(f.paragraphs, para)
        return para, nil
}</span>

// Paragraphs returns all paragraphs in the footer.
func (f *docxFooter) Paragraphs() []domain.Paragraph <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        // Return defensive copy
        result := make([]domain.Paragraph, len(f.paragraphs))
        copy(result, f.paragraphs)
        return result
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package core

import (
        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/manager"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// table implements the domain.Table interface.
type table struct {
        id         string
        rows       []domain.TableRow
        cols       int
        width      domain.TableWidth
        alignment  domain.Alignment
        style      domain.TableStyle
        idGen      *manager.IDGenerator
        relManager *manager.RelationshipManager
}

// NewTable creates a new Table.
func NewTable(id string, rows, cols int, idGen *manager.IDGenerator, relManager *manager.RelationshipManager) domain.Table <span class="cov6" title="19">{
        t := &amp;table{
                id:         id,
                rows:       make([]domain.TableRow, 0, rows),
                cols:       cols,
                width:      domain.TableWidth{Type: domain.WidthAuto, Value: 0},
                alignment:  domain.AlignmentLeft,
                style:      domain.TableStyle{},
                idGen:      idGen,
                relManager: relManager,
        }

        // Create initial rows
        for i := 0; i &lt; rows; i++ </span><span class="cov7" title="46">{
                rowID := idGen.NextRowID()
                row := NewTableRow(rowID, cols, idGen, relManager)
                t.rows = append(t.rows, row)
        }</span>

        <span class="cov6" title="19">return t</span>
}

// Row returns the row at the specified index.
func (t *table) Row(index int) (domain.TableRow, error) <span class="cov5" title="16">{
        if index &lt; 0 || index &gt;= len(t.rows) </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Table.Row", "index", index,
                        "row index out of bounds")
        }</span>
        <span class="cov5" title="16">return t.rows[index], nil</span>
}

// Rows returns all rows in the table.
func (t *table) Rows() []domain.TableRow <span class="cov2" title="3">{
        rows := make([]domain.TableRow, len(t.rows))
        copy(rows, t.rows)
        return rows
}</span>

// AddRow adds a new row to the end of the table.
func (t *table) AddRow() (domain.TableRow, error) <span class="cov1" title="1">{
        rowID := t.idGen.NextRowID()
        row := NewTableRow(rowID, t.cols, t.idGen, t.relManager)
        t.rows = append(t.rows, row)
        return row, nil
}</span>

// InsertRow inserts a new row at the specified index.
func (t *table) InsertRow(index int) (domain.TableRow, error) <span class="cov1" title="1">{
        if index &lt; 0 || index &gt; len(t.rows) </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("Table.InsertRow", "index", index,
                        "row index out of bounds")
        }</span>

        <span class="cov1" title="1">rowID := t.idGen.NextRowID()
        row := NewTableRow(rowID, t.cols, t.idGen, t.relManager)

        // Insert at index
        t.rows = append(t.rows[:index], append([]domain.TableRow{row}, t.rows[index:]...)...)

        return row, nil</span>
}

// DeleteRow deletes the row at the specified index.
func (t *table) DeleteRow(index int) error <span class="cov1" title="1">{
        if index &lt; 0 || index &gt;= len(t.rows) </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Table.DeleteRow", "index", index,
                        "row index out of bounds")
        }</span>

        <span class="cov1" title="1">t.rows = append(t.rows[:index], t.rows[index+1:]...)
        return nil</span>
}

// RowCount returns the number of rows in the table.
func (t *table) RowCount() int <span class="cov4" title="9">{
        return len(t.rows)
}</span>

// ColumnCount returns the number of columns in the table.
func (t *table) ColumnCount() int <span class="cov4" title="6">{
        return t.cols
}</span>

// Width returns the table width.
func (t *table) Width() domain.TableWidth <span class="cov1" title="1">{
        return t.width
}</span>

// SetWidth sets the table width.
func (t *table) SetWidth(width domain.TableWidth) error <span class="cov0" title="0">{
        if width.Type &lt; domain.WidthAuto || width.Type &gt; domain.WidthPct </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Table.SetWidth", "width.Type", width.Type,
                        "invalid width type")
        }</span>
        <span class="cov0" title="0">t.width = width
        return nil</span>
}

// Alignment returns the table alignment.
func (t *table) Alignment() domain.Alignment <span class="cov1" title="1">{
        return t.alignment
}</span>

// SetAlignment sets the table alignment.
func (t *table) SetAlignment(align domain.Alignment) error <span class="cov0" title="0">{
        if align &lt; domain.AlignmentLeft || align &gt; domain.AlignmentDistribute </span><span class="cov0" title="0">{
                return errors.InvalidArgument("Table.SetAlignment", "align", align,
                        "invalid alignment value")
        }</span>
        <span class="cov0" title="0">t.alignment = align
        return nil</span>
}

// Style returns the table style.
func (t *table) Style() domain.TableStyle <span class="cov3" title="4">{
        return t.style
}</span>

// SetStyle sets the table style.
func (t *table) SetStyle(style domain.TableStyle) error <span class="cov2" title="2">{
        t.style = style
        return nil
}</span>

// tableRow implements the domain.TableRow interface.
type tableRow struct {
        id         string
        cells      []domain.TableCell
        height     int
        idGen      *manager.IDGenerator
        relManager *manager.RelationshipManager
}

// NewTableRow creates a new TableRow.
func NewTableRow(id string, cols int, idGen *manager.IDGenerator, relManager *manager.RelationshipManager) domain.TableRow <span class="cov7" title="48">{
        row := &amp;tableRow{
                id:         id,
                cells:      make([]domain.TableCell, 0, cols),
                height:     0, // Auto height
                idGen:      idGen,
                relManager: relManager,
        }

        // Create cells
        for i := 0; i &lt; cols; i++ </span><span class="cov10" title="149">{
                cellID := idGen.NextCellID()
                cell := NewTableCell(cellID, idGen, relManager)
                row.cells = append(row.cells, cell)
        }</span>

        <span class="cov7" title="48">return row</span>
}

// Cell returns the cell at the specified column index.
func (r *tableRow) Cell(col int) (domain.TableCell, error) <span class="cov6" title="17">{
        if col &lt; 0 || col &gt;= len(r.cells) </span><span class="cov0" title="0">{
                return nil, errors.InvalidArgument("TableRow.Cell", "col", col,
                        "column index out of bounds")
        }</span>
        <span class="cov6" title="17">return r.cells[col], nil</span>
}

// Cells returns all cells in this row.
func (r *tableRow) Cells() []domain.TableCell <span class="cov3" title="5">{
        cells := make([]domain.TableCell, len(r.cells))
        copy(cells, r.cells)
        return cells
}</span>

// Height returns the row height.
func (r *tableRow) Height() int <span class="cov2" title="2">{
        return r.height
}</span>

// SetHeight sets the row height in twips.
func (r *tableRow) SetHeight(twips int) error <span class="cov0" title="0">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableRow.SetHeight", "twips", twips,
                        "height cannot be negative")
        }</span>
        <span class="cov0" title="0">r.height = twips
        return nil</span>
}

// tableCell implements the domain.TableCell interface.
type tableCell struct {
        id                string
        paragraphs        []domain.Paragraph
        tables            []domain.Table
        width             int
        verticalAlignment domain.VerticalAlignment
        borders           domain.TableBorders
        shading           domain.Color
        gridSpan          int
        vMerge            domain.VerticalMergeType
        idGen             *manager.IDGenerator
        relManager        *manager.RelationshipManager
}

// NewTableCell creates a new TableCell.
func NewTableCell(id string, idGen *manager.IDGenerator, relManager *manager.RelationshipManager) domain.TableCell <span class="cov10" title="149">{
        return &amp;tableCell{
                id:                id,
                paragraphs:        make([]domain.Paragraph, 0, constants.DefaultParagraphCapacity),
                tables:            make([]domain.Table, 0, 1),
                width:             0, // Auto width
                verticalAlignment: domain.VerticalAlignTop,
                borders:           domain.TableBorders{},
                shading:           domain.ColorWhite,
                gridSpan:          1, // Default: no horizontal merge
                vMerge:            domain.VMergeNone,
                idGen:             idGen,
                relManager:        relManager,
        }
}</span>

// AddParagraph adds a paragraph to this cell.
func (c *tableCell) AddParagraph() (domain.Paragraph, error) <span class="cov4" title="7">{
        id := c.idGen.NextParagraphID()
        para := NewParagraph(id, c.idGen, c.relManager)
        c.paragraphs = append(c.paragraphs, para)
        return para, nil
}</span>

// Paragraphs returns all paragraphs in this cell.
func (c *tableCell) Paragraphs() []domain.Paragraph <span class="cov5" title="13">{
        paras := make([]domain.Paragraph, len(c.paragraphs))
        copy(paras, c.paragraphs)
        return paras
}</span>

// Width returns the cell width.
func (c *tableCell) Width() int <span class="cov4" title="6">{
        return c.width
}</span>

// SetWidth sets the cell width in twips.
func (c *tableCell) SetWidth(twips int) error <span class="cov0" title="0">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableCell.SetWidth", "twips", twips,
                        "width cannot be negative")
        }</span>
        <span class="cov0" title="0">c.width = twips
        return nil</span>
}

// VerticalAlignment returns the vertical alignment of content.
func (c *tableCell) VerticalAlignment() domain.VerticalAlignment <span class="cov4" title="6">{
        return c.verticalAlignment
}</span>

// SetVerticalAlignment sets the vertical alignment.
func (c *tableCell) SetVerticalAlignment(align domain.VerticalAlignment) error <span class="cov0" title="0">{
        if align &lt; domain.VerticalAlignTop || align &gt; domain.VerticalAlignBottom </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableCell.SetVerticalAlignment", "align", align,
                        "invalid vertical alignment value")
        }</span>
        <span class="cov0" title="0">c.verticalAlignment = align
        return nil</span>
}

// Borders returns the cell borders.
func (c *tableCell) Borders() domain.TableBorders <span class="cov0" title="0">{
        return c.borders
}</span>

// SetBorders sets the cell borders.
func (c *tableCell) SetBorders(borders domain.TableBorders) error <span class="cov0" title="0">{
        c.borders = borders
        return nil
}</span>

// Shading returns the cell background color.
func (c *tableCell) Shading() domain.Color <span class="cov4" title="6">{
        return c.shading
}</span>

// SetShading sets the cell background color.
func (c *tableCell) SetShading(color domain.Color) error <span class="cov0" title="0">{
        c.shading = color
        return nil
}</span>

// Merge merges this cell with adjacent cells.
func (c *tableCell) Merge(cols, rows int) error <span class="cov4" title="9">{
        if cols &lt; 1 </span><span class="cov2" title="2">{
                return errors.InvalidArgument("TableCell.Merge", "cols", cols,
                        "cols must be at least 1")
        }</span>
        <span class="cov4" title="7">if rows &lt; 1 </span><span class="cov2" title="2">{
                return errors.InvalidArgument("TableCell.Merge", "rows", rows,
                        "rows must be at least 1")
        }</span>
        
        // Set horizontal merge (gridSpan)
        <span class="cov3" title="5">c.gridSpan = cols
        
        // Set vertical merge
        if rows &gt; 1 </span><span class="cov2" title="3">{
                c.vMerge = domain.VMergeRestart
        }</span>
        
        <span class="cov3" title="5">return nil</span>
}

// GridSpan returns the number of grid columns spanned by this cell.
func (c *tableCell) GridSpan() int <span class="cov5" title="10">{
        return c.gridSpan
}</span>

// SetGridSpan sets the horizontal merge span.
func (c *tableCell) SetGridSpan(span int) error <span class="cov2" title="2">{
        if span &lt; 1 </span><span class="cov1" title="1">{
                return errors.InvalidArgument("TableCell.SetGridSpan", "span", span,
                        "span must be at least 1")
        }</span>
        <span class="cov1" title="1">c.gridSpan = span
        return nil</span>
}

// VMerge returns the vertical merge type.
func (c *tableCell) VMerge() domain.VerticalMergeType <span class="cov5" title="11">{
        return c.vMerge
}</span>

// SetVMerge sets the vertical merge type.
func (c *tableCell) SetVMerge(mergeType domain.VerticalMergeType) error <span class="cov2" title="2">{
        if mergeType &lt; domain.VMergeNone || mergeType &gt; domain.VMergeContinue </span><span class="cov0" title="0">{
                return errors.InvalidArgument("TableCell.SetVMerge", "mergeType", mergeType,
                        "invalid vertical merge type")
        }</span>
        <span class="cov2" title="2">c.vMerge = mergeType
        return nil</span>
}

// AddTable adds a nested table to this cell.
func (c *tableCell) AddTable(rows, cols int) (domain.Table, error) <span class="cov4" title="9">{
        if rows &lt; 1 </span><span class="cov2" title="2">{
                return nil, errors.InvalidArgument("TableCell.AddTable", "rows", rows,
                        "rows must be at least 1")
        }</span>
        <span class="cov4" title="7">if cols &lt; 1 </span><span class="cov2" title="2">{
                return nil, errors.InvalidArgument("TableCell.AddTable", "cols", cols,
                        "cols must be at least 1")
        }</span>
        
        <span class="cov3" title="5">table := NewTable(c.idGen.GenerateID("table"), rows, cols, c.idGen, c.relManager)
        c.tables = append(c.tables, table)
        return table, nil</span>
}

// Tables returns all nested tables in this cell.
func (c *tableCell) Tables() []domain.Table <span class="cov5" title="14">{
        // Return a defensive copy
        result := make([]domain.Table, len(c.tables))
        copy(result, c.tables)
        return result
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// characterStyle implements domain.CharacterStyle.
type characterStyle struct {
        mu        sync.RWMutex
        id        string
        name      string
        basedOn   string
        font      domain.Font
        isDefault bool
        isBuiltIn bool
        bold      bool
        italic    bool
        underline domain.UnderlineStyle
        color     domain.Color
        size      int // in half-points
}

// newCharacterStyle creates a new character style.
// Note: builtIn parameter is used in tests to create custom styles.
//
//nolint:unparam // builtIn=true in production, false in tests
func newCharacterStyle(id, name string, builtIn bool) *characterStyle <span class="cov10" title="56">{
        return &amp;characterStyle{
                id:        id,
                name:      name,
                isBuiltIn: builtIn,
                font:      domain.Font{Name: constants.DefaultFontName},
                color:     domain.ColorBlack,
                size:      constants.DefaultFontSize,
                underline: domain.UnderlineNone,
        }
}</span>

// ID returns the unique style identifier.
func (cs *characterStyle) ID() string <span class="cov5" title="6">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.id
}</span>

// Name returns the style display name.
func (cs *characterStyle) Name() string <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.name
}</span>

// Type returns the style type.
func (cs *characterStyle) Type() domain.StyleType <span class="cov7" title="16">{
        return domain.StyleTypeCharacter
}</span>

// BasedOn returns the style ID this style is based on.
func (cs *characterStyle) BasedOn() string <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.basedOn
}</span>

// SetBasedOn sets the parent style.
func (cs *characterStyle) SetBasedOn(styleID string) error <span class="cov9" title="44">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.basedOn = styleID
        return nil
}</span>

// Next returns the style ID for next paragraph (not applicable for character styles).
func (cs *characterStyle) Next() string <span class="cov0" title="0">{
        return ""
}</span>

// SetNext sets next paragraph style (not applicable for character styles).
func (cs *characterStyle) SetNext(styleID string) error <span class="cov0" title="0">{
        return errors.NewValidationError(
                "CharacterStyle.SetNext",
                "styleID",
                styleID,
                "Next property not applicable for character styles",
        )
}</span>

// Font returns the font settings.
func (cs *characterStyle) Font() domain.Font <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.font
}</span>

// SetFont sets the font settings.
func (cs *characterStyle) SetFont(font domain.Font) error <span class="cov0" title="0">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "CharacterStyle.SetFont",
                        "font.Name",
                        "",
                        "font name cannot be empty",
                )
        }</span>

        <span class="cov0" title="0">cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.font = font
        return nil</span>
}

// IsDefault returns whether this is a default style.
func (cs *characterStyle) IsDefault() bool <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.isDefault
}</span>

// SetDefault marks this style as default.
func (cs *characterStyle) SetDefault(isDefault bool) error <span class="cov6" title="11">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.isDefault = isDefault
        return nil
}</span>

// IsCustom returns whether this is a custom style.
func (cs *characterStyle) IsCustom() bool <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return !cs.isBuiltIn
}</span>

// Bold returns whether the text is bold.
func (cs *characterStyle) Bold() bool <span class="cov1" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.bold
}</span>

// SetBold sets whether the text is bold.
func (cs *characterStyle) SetBold(bold bool) error <span class="cov6" title="12">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.bold = bold
        return nil
}</span>

// Italic returns whether the text is italic.
func (cs *characterStyle) Italic() bool <span class="cov1" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.italic
}</span>

// SetItalic sets whether the text is italic.
func (cs *characterStyle) SetItalic(italic bool) error <span class="cov6" title="12">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.italic = italic
        return nil
}</span>

// Underline returns the underline style.
func (cs *characterStyle) Underline() domain.UnderlineStyle <span class="cov0" title="0">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.underline
}</span>

// SetUnderline sets the underline style.
func (cs *characterStyle) SetUnderline(style domain.UnderlineStyle) error <span class="cov7" title="22">{
        if style &lt; domain.UnderlineNone || style &gt; domain.UnderlineWave </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "CharacterStyle.SetUnderline",
                        "style",
                        style,
                        "invalid underline style",
                )
        }</span>

        <span class="cov7" title="22">cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.underline = style
        return nil</span>
}

// Color returns the text color.
func (cs *characterStyle) Color() domain.Color <span class="cov1" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.color
}</span>

// SetColor sets the text color.
func (cs *characterStyle) SetColor(color domain.Color) error <span class="cov8" title="23">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.color = color
        return nil
}</span>

// Size returns the font size in half-points.
func (cs *characterStyle) Size() int <span class="cov1" title="1">{
        cs.mu.RLock()
        defer cs.mu.RUnlock()
        return cs.size
}</span>

// SetSize sets the font size in half-points.
func (cs *characterStyle) SetSize(halfPoints int) error <span class="cov1" title="1">{
        if halfPoints &lt; constants.MinFontSize || halfPoints &gt; constants.MaxFontSize </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "CharacterStyle.SetSize",
                        "halfPoints",
                        halfPoints,
                        "font size must be between 2 and 3276 half-points (1pt - 1638pt)",
                )
        }</span>

        <span class="cov1" title="1">cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.size = halfPoints
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



// Package manager provides internal management services for go-docx v2.
package manager

import (
        "fmt"
        "sync/atomic"

        "github.com/mmonterroca/docxgo/pkg/constants"
)

// IDGenerator generates unique IDs for document elements.
// It is thread-safe and can be used concurrently.
type IDGenerator struct {
        paragraphCounter atomic.Uint64
        runCounter       atomic.Uint64
        tableCounter     atomic.Uint64
        rowCounter       atomic.Uint64
        cellCounter      atomic.Uint64
        imageCounter     atomic.Uint64
        shapeCounter     atomic.Uint64
        relCounter       atomic.Uint64
        bookmarkCounter  atomic.Uint64
        commentCounter   atomic.Uint64
        footnoteCounter  atomic.Uint64
        endnoteCounter   atomic.Uint64
}

// NewIDGenerator creates a new ID generator.
func NewIDGenerator() *IDGenerator <span class="cov0" title="0">{
        return &amp;IDGenerator{}
}</span>

// NextParagraphID generates the next paragraph ID.
func (g *IDGenerator) NextParagraphID() string <span class="cov0" title="0">{
        id := g.paragraphCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixParagraph, id)
}</span>

// NextRunID generates the next run ID.
func (g *IDGenerator) NextRunID() string <span class="cov0" title="0">{
        id := g.runCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixRun, id)
}</span>

// NextTableID generates the next table ID.
func (g *IDGenerator) NextTableID() string <span class="cov0" title="0">{
        id := g.tableCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixTable, id)
}</span>

// NextRowID generates the next row ID.
func (g *IDGenerator) NextRowID() string <span class="cov0" title="0">{
        id := g.rowCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixRow, id)
}</span>

// NextCellID generates the next cell ID.
func (g *IDGenerator) NextCellID() string <span class="cov0" title="0">{
        id := g.cellCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixCell, id)
}</span>

// NextImageID generates the next image ID.
func (g *IDGenerator) NextImageID() string <span class="cov0" title="0">{
        id := g.imageCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixImage, id)
}</span>

// NextShapeID generates the next shape ID.
func (g *IDGenerator) NextShapeID() string <span class="cov0" title="0">{
        id := g.shapeCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixShape, id)
}</span>

// NextRelID generates the next relationship ID.
func (g *IDGenerator) NextRelID() string <span class="cov0" title="0">{
        id := g.relCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixRel, id)
}</span>

// NextBookmarkID generates the next bookmark ID.
func (g *IDGenerator) NextBookmarkID() string <span class="cov0" title="0">{
        id := g.bookmarkCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixBookmark, id)
}</span>

// NextCommentID generates the next comment ID.
func (g *IDGenerator) NextCommentID() string <span class="cov0" title="0">{
        id := g.commentCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixComment, id)
}</span>

// NextFootnoteID generates the next footnote ID.
func (g *IDGenerator) NextFootnoteID() string <span class="cov0" title="0">{
        id := g.footnoteCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixFootnote, id)
}</span>

// NextEndnoteID generates the next endnote ID.
func (g *IDGenerator) NextEndnoteID() string <span class="cov0" title="0">{
        id := g.endnoteCounter.Add(1)
        return fmt.Sprintf("%s%d", constants.IDPrefixEndnote, id)
}</span>

// GenerateID generates an ID with a custom prefix.
// This is a generic method for any element type.
func (g *IDGenerator) GenerateID(prefix string) string <span class="cov0" title="0">{
        // Use table counter for generic IDs
        id := g.tableCounter.Add(1)
        return fmt.Sprintf("%s%d", prefix, id)
}</span>

// Reset resets all counters to zero.
// This should only be used when starting a new document.
func (g *IDGenerator) Reset() <span class="cov0" title="0">{
        g.paragraphCounter.Store(0)
        g.runCounter.Store(0)
        g.tableCounter.Store(0)
        g.rowCounter.Store(0)
        g.cellCounter.Store(0)
        g.imageCounter.Store(0)
        g.shapeCounter.Store(0)
        g.relCounter.Store(0)
        g.bookmarkCounter.Store(0)
        g.commentCounter.Store(0)
        g.footnoteCounter.Store(0)
        g.endnoteCounter.Store(0)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package manager

import (
        "fmt"
        "path/filepath"
        "strings"
        "sync"

        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// MediaFile represents a media file in the document.
type MediaFile struct {
        ID          string // Unique ID
        Name        string // File name (e.g., "image1.png")
        Path        string // Path within .docx (e.g., "word/media/image1.png")
        ContentType string // MIME type
        Data        []byte // File data
}

// MediaManager manages media files (images, etc.) in a document.
// It is thread-safe.
type MediaManager struct {
        mu      sync.RWMutex
        files   map[string]*MediaFile // key is ID
        idGen   *IDGenerator
        counter int // Counter for generating unique file names
}

// NewMediaManager creates a new media manager.
func NewMediaManager(idGen *IDGenerator) *MediaManager <span class="cov0" title="0">{
        return &amp;MediaManager{
                files: make(map[string]*MediaFile, constants.DefaultMediaCapacity),
                idGen: idGen,
        }
}</span>

// Add adds a media file and returns its ID and path.
func (mm *MediaManager) Add(data []byte, filename string) (id, path string, err error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return "", "", errors.InvalidArgument("MediaManager.Add", "data", data, "media data cannot be empty")
        }</span>
        <span class="cov0" title="0">if filename == "" </span><span class="cov0" title="0">{
                return "", "", errors.InvalidArgument("MediaManager.Add", "filename", filename, "filename cannot be empty")
        }</span>

        <span class="cov0" title="0">mm.mu.Lock()
        defer mm.mu.Unlock()

        // Generate unique ID
        id = mm.idGen.NextImageID()

        // Detect content type from extension
        ext := strings.ToLower(filepath.Ext(filename))
        contentType := mm.detectContentType(ext)

        // Generate unique filename
        mm.counter++
        uniqueName := fmt.Sprintf("image%d%s", mm.counter, ext)
        path = constants.PathMediaPrefix + uniqueName

        file := &amp;MediaFile{
                ID:          id,
                Name:        uniqueName,
                Path:        path,
                ContentType: contentType,
                Data:        data,
        }

        mm.files[id] = file
        return id, path, nil</span>
}

// Get retrieves a media file by ID.
func (mm *MediaManager) Get(id string) (*MediaFile, error) <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        file, exists := mm.files[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NotFound("MediaManager.Get", "media file")
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// GetByPath retrieves a media file by path.
func (mm *MediaManager) GetByPath(path string) (*MediaFile, error) <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        for _, file := range mm.files </span><span class="cov0" title="0">{
                if file.Path == path </span><span class="cov0" title="0">{
                        return file, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.NotFound("MediaManager.GetByPath", "media file")</span>
}

// All returns all media files.
func (mm *MediaManager) All() []*MediaFile <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        files := make([]*MediaFile, 0, len(mm.files))
        for _, file := range mm.files </span><span class="cov0" title="0">{
                files = append(files, file)
        }</span>

        <span class="cov0" title="0">return files</span>
}

// Count returns the number of media files.
func (mm *MediaManager) Count() int <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        return len(mm.files)
}</span>

// Delete removes a media file by ID.
func (mm *MediaManager) Delete(id string) error <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()

        if _, exists := mm.files[id]; !exists </span><span class="cov0" title="0">{
                return errors.NotFound("MediaManager.Delete", "media file")
        }</span>

        <span class="cov0" title="0">delete(mm.files, id)
        return nil</span>
}

// detectContentType returns the MIME type for a file extension.
func (mm *MediaManager) detectContentType(ext string) string <span class="cov0" title="0">{
        switch ext </span>{
        case ".png":<span class="cov0" title="0">
                return constants.ContentTypePNG</span>
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                return constants.ContentTypeJPEG</span>
        case ".gif":<span class="cov0" title="0">
                return constants.ContentTypeGIF</span>
        case ".bmp":<span class="cov0" title="0">
                return constants.ContentTypeBMP</span>
        case ".tiff", ".tif":<span class="cov0" title="0">
                return constants.ContentTypeTIFF</span>
        case ".wmf":<span class="cov0" title="0">
                return constants.ContentTypeWMF</span>
        case ".emf":<span class="cov0" title="0">
                return constants.ContentTypeEMF</span>
        default:<span class="cov0" title="0">
                return "application/octet-stream"</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// paragraphStyle implements domain.ParagraphStyle.
type paragraphStyle struct {
        mu              sync.RWMutex
        id              string
        name            string
        basedOn         string
        next            string
        font            domain.Font
        isDefault       bool
        isBuiltIn       bool
        alignment       domain.Alignment
        spacingBefore   int
        spacingAfter    int
        lineSpacing     int
        indentation     domain.Indentation
        keepNext        bool
        keepLines       bool
        pageBreakBefore bool
        outlineLevel    int
}

// newParagraphStyle creates a new paragraph style.
// Note: builtIn parameter is used in tests to create custom styles.
//
//nolint:unparam // builtIn=true in production, false in tests
func newParagraphStyle(id, name string, builtIn bool) *paragraphStyle <span class="cov10" title="401">{
        return &amp;paragraphStyle{
                id:            id,
                name:          name,
                isBuiltIn:     builtIn,
                font:          domain.Font{Name: constants.DefaultFontName},
                alignment:     domain.AlignmentLeft,
                spacingBefore: 0,
                spacingAfter:  0,
                lineSpacing:   240, // Single spacing (240 = 1.0)
                outlineLevel:  0,   // Body text level
        }
}</span>

// ID returns the unique style identifier.
func (ps *paragraphStyle) ID() string <span class="cov8" title="135">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.id
}</span>

// Name returns the style display name.
func (ps *paragraphStyle) Name() string <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.name
}</span>

// Type returns the style type.
func (ps *paragraphStyle) Type() domain.StyleType <span class="cov7" title="82">{
        return domain.StyleTypeParagraph
}</span>

// BasedOn returns the style ID this style is based on.
func (ps *paragraphStyle) BasedOn() string <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.basedOn
}</span>

// SetBasedOn sets the parent style.
func (ps *paragraphStyle) SetBasedOn(styleID string) error <span class="cov9" title="286">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.basedOn = styleID
        return nil
}</span>

// Next returns the style ID to use for the next paragraph.
func (ps *paragraphStyle) Next() string <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.next
}</span>

// SetNext sets the next paragraph style.
func (ps *paragraphStyle) SetNext(styleID string) error <span class="cov0" title="0">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.next = styleID
        return nil
}</span>

// Font returns the font settings.
func (ps *paragraphStyle) Font() domain.Font <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.font
}</span>

// SetFont sets the font settings.
func (ps *paragraphStyle) SetFont(font domain.Font) error <span class="cov7" title="99">{
        if font.Name == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetFont",
                        "font.Name",
                        "",
                        "font name cannot be empty",
                )
        }</span>

        <span class="cov7" title="99">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.font = font
        return nil</span>
}

// IsDefault returns whether this is a default style.
func (ps *paragraphStyle) IsDefault() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.isDefault
}</span>

// SetDefault marks this style as default.
func (ps *paragraphStyle) SetDefault(isDefault bool) error <span class="cov4" title="11">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.isDefault = isDefault
        return nil
}</span>

// IsCustom returns whether this is a custom style.
func (ps *paragraphStyle) IsCustom() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return !ps.isBuiltIn
}</span>

// Alignment returns the paragraph alignment.
func (ps *paragraphStyle) Alignment() domain.Alignment <span class="cov1" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.alignment
}</span>

// SetAlignment sets the paragraph alignment.
func (ps *paragraphStyle) SetAlignment(align domain.Alignment) error <span class="cov4" title="12">{
        if align &lt; domain.AlignmentLeft || align &gt; domain.AlignmentDistribute </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetAlignment",
                        "alignment",
                        align,
                        "invalid alignment value",
                )
        }</span>

        <span class="cov4" title="12">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.alignment = align
        return nil</span>
}

// SpacingBefore returns spacing before paragraph in twips.
func (ps *paragraphStyle) SpacingBefore() int <span class="cov1" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.spacingBefore
}</span>

// SetSpacingBefore sets spacing before paragraph.
func (ps *paragraphStyle) SetSpacingBefore(twips int) error <span class="cov8" title="111">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetSpacingBefore",
                        "twips",
                        twips,
                        "spacing cannot be negative",
                )
        }</span>

        <span class="cov8" title="111">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.spacingBefore = twips
        return nil</span>
}

// SpacingAfter returns spacing after paragraph in twips.
func (ps *paragraphStyle) SpacingAfter() int <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.spacingAfter
}</span>

// SetSpacingAfter sets spacing after paragraph.
func (ps *paragraphStyle) SetSpacingAfter(twips int) error <span class="cov8" title="121">{
        if twips &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetSpacingAfter",
                        "twips",
                        twips,
                        "spacing cannot be negative",
                )
        }</span>

        <span class="cov8" title="121">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.spacingAfter = twips
        return nil</span>
}

// LineSpacing returns the line spacing value.
func (ps *paragraphStyle) LineSpacing() int <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.lineSpacing
}</span>

// SetLineSpacing sets the line spacing.
func (ps *paragraphStyle) SetLineSpacing(value int) error <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetLineSpacing",
                        "value",
                        value,
                        "line spacing cannot be negative",
                )
        }</span>

        <span class="cov0" title="0">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.lineSpacing = value
        return nil</span>
}

// Indentation returns the paragraph indentation.
func (ps *paragraphStyle) Indentation() domain.Indentation <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.indentation
}</span>

// SetIndentation sets the paragraph indentation.
func (ps *paragraphStyle) SetIndentation(indent domain.Indentation) error <span class="cov8" title="121">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.indentation = indent
        return nil
}</span>

// KeepNext returns whether to keep with next paragraph.
func (ps *paragraphStyle) KeepNext() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.keepNext
}</span>

// SetKeepNext sets keep with next paragraph.
func (ps *paragraphStyle) SetKeepNext(keep bool) error <span class="cov7" title="99">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.keepNext = keep
        return nil
}</span>

// KeepLines returns whether to keep lines together.
func (ps *paragraphStyle) KeepLines() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.keepLines
}</span>

// SetKeepLines sets keep lines together.
func (ps *paragraphStyle) SetKeepLines(keep bool) error <span class="cov7" title="99">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.keepLines = keep
        return nil
}</span>

// PageBreakBefore returns whether to insert page break before.
func (ps *paragraphStyle) PageBreakBefore() bool <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.pageBreakBefore
}</span>

// SetPageBreakBefore sets page break before.
func (ps *paragraphStyle) SetPageBreakBefore(breakBefore bool) error <span class="cov0" title="0">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.pageBreakBefore = breakBefore
        return nil
}</span>

// OutlineLevel returns the outline level.
func (ps *paragraphStyle) OutlineLevel() int <span class="cov1" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.outlineLevel
}</span>

// SetOutlineLevel sets the outline level.
func (ps *paragraphStyle) SetOutlineLevel(level int) error <span class="cov7" title="101">{
        if level &lt; 0 || level &gt; 9 </span><span class="cov1" title="1">{
                return errors.NewValidationError(
                        "ParagraphStyle.SetOutlineLevel",
                        "level",
                        level,
                        "outline level must be 0-9 (0=body text, 1-9=heading levels)",
                )
        }</span>

        <span class="cov7" title="100">ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.outlineLevel = level
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/internal/xml"
        "github.com/mmonterroca/docxgo/pkg/constants"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// Relationship represents an OOXML relationship.
type Relationship struct {
        ID         string // Relationship ID (e.g., "rId1")
        Type       string // Relationship type (e.g., "http://schemas.openxmlformats.org/.../image")
        Target     string // Target path (e.g., "media/image1.png")
        TargetMode string // "Internal" or "External"
}

// RelationshipManager manages relationships for a document part.
// It is thread-safe.
type RelationshipManager struct {
        mu            sync.RWMutex
        relationships map[string]*Relationship // key is ID
        idGen         *IDGenerator
}

// NewRelationshipManager creates a new relationship manager.
func NewRelationshipManager(idGen *IDGenerator) *RelationshipManager <span class="cov0" title="0">{
        return &amp;RelationshipManager{
                relationships: make(map[string]*Relationship, constants.DefaultRelCapacity),
                idGen:         idGen,
        }
}</span>

// Add adds a new relationship and returns its ID.
func (rm *RelationshipManager) Add(relType, target, targetMode string) (string, error) <span class="cov0" title="0">{
        if relType == "" </span><span class="cov0" title="0">{
                return "", errors.InvalidArgument("RelationshipManager.Add", "relType", relType, "relationship type cannot be empty")
        }</span>
        <span class="cov0" title="0">if target == "" </span><span class="cov0" title="0">{
                return "", errors.InvalidArgument("RelationshipManager.Add", "target", target, "target cannot be empty")
        }</span>

        <span class="cov0" title="0">rm.mu.Lock()
        defer rm.mu.Unlock()

        // Generate new ID
        id := rm.idGen.NextRelID()

        // Default to Internal if not specified
        if targetMode == "" </span><span class="cov0" title="0">{
                targetMode = "Internal"
        }</span>

        <span class="cov0" title="0">rel := &amp;Relationship{
                ID:         id,
                Type:       relType,
                Target:     target,
                TargetMode: targetMode,
        }

        rm.relationships[id] = rel
        return id, nil</span>
}

// Get retrieves a relationship by ID.
func (rm *RelationshipManager) Get(id string) (*Relationship, error) <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rel, exists := rm.relationships[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NotFound("RelationshipManager.Get", "relationship")
        }</span>

        <span class="cov0" title="0">return rel, nil</span>
}

// GetByTarget retrieves a relationship by target path.
// Returns the first relationship matching the target.
func (rm *RelationshipManager) GetByTarget(target string) (*Relationship, error) <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        for _, rel := range rm.relationships </span><span class="cov0" title="0">{
                if rel.Target == target </span><span class="cov0" title="0">{
                        return rel, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.NotFound("RelationshipManager.GetByTarget", "relationship")</span>
}

// All returns all relationships.
func (rm *RelationshipManager) All() []*Relationship <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rels := make([]*Relationship, 0, len(rm.relationships))
        for _, rel := range rm.relationships </span><span class="cov0" title="0">{
                rels = append(rels, rel)
        }</span>

        <span class="cov0" title="0">return rels</span>
}

// Count returns the number of relationships.
func (rm *RelationshipManager) Count() int <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        return len(rm.relationships)
}</span>

// Delete removes a relationship by ID.
func (rm *RelationshipManager) Delete(id string) error <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        if _, exists := rm.relationships[id]; !exists </span><span class="cov0" title="0">{
                return errors.NotFound("RelationshipManager.Delete", "relationship")
        }</span>

        <span class="cov0" title="0">delete(rm.relationships, id)
        return nil</span>
}

// AddImage adds an image relationship.
func (rm *RelationshipManager) AddImage(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeImage, target, "Internal")
}</span>

// AddHyperlink adds a hyperlink relationship.
func (rm *RelationshipManager) AddHyperlink(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeHyperlink, target, "External")
}</span>

// AddHeader adds a header relationship.
func (rm *RelationshipManager) AddHeader(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeHeader, target, "Internal")
}</span>

// AddFooter adds a footer relationship.
func (rm *RelationshipManager) AddFooter(target string) (string, error) <span class="cov0" title="0">{
        return rm.Add(constants.RelTypeFooter, target, "Internal")
}</span>

// ToXML converts relationships to XML structure.
func (rm *RelationshipManager) ToXML() *xml.Relationships <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        rels := &amp;xml.Relationships{
                Xmlns:         constants.NamespacePackageRels,
                Relationships: make([]*xml.Relationship, 0, len(rm.relationships)),
        }

        for _, rel := range rm.relationships </span><span class="cov0" title="0">{
                xmlRel := &amp;xml.Relationship{
                        ID:         rel.ID,
                        Type:       rel.Type,
                        Target:     rel.Target,
                        TargetMode: rel.TargetMode,
                }
                rels.Relationships = append(rels.Relationships, xmlRel)
        }</span>

        <span class="cov0" title="0">return rels</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package manager

import (
        "sync"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// styleManager implements domain.StyleManager.
type styleManager struct {
        mu              sync.RWMutex
        styles          map[string]domain.Style
        defaultStyles   map[domain.StyleType]string
        builtInStyleIDs map[string]bool
}

// NewStyleManager creates a new StyleManager with built-in styles.
func NewStyleManager() domain.StyleManager <span class="cov3" title="11">{
        sm := &amp;styleManager{
                styles:          make(map[string]domain.Style),
                defaultStyles:   make(map[domain.StyleType]string),
                builtInStyleIDs: make(map[string]bool),
        }

        // Initialize built-in styles
        sm.initializeBuiltInStyles()

        return sm
}</span>

// initializeBuiltInStyles creates all built-in OOXML styles.
func (sm *styleManager) initializeBuiltInStyles() <span class="cov3" title="11">{
        // Mark built-in paragraph style IDs
        builtInParagraphStyles := []string{
                domain.StyleIDNormal,
                domain.StyleIDHeading1, domain.StyleIDHeading2, domain.StyleIDHeading3,
                domain.StyleIDHeading4, domain.StyleIDHeading5, domain.StyleIDHeading6,
                domain.StyleIDHeading7, domain.StyleIDHeading8, domain.StyleIDHeading9,
                domain.StyleIDTitle, domain.StyleIDSubtitle,
                domain.StyleIDQuote, domain.StyleIDIntenseQuote,
                domain.StyleIDListParagraph, domain.StyleIDCaption,
                domain.StyleIDTOC1, domain.StyleIDTOC2, domain.StyleIDTOC3,
                domain.StyleIDTOC4, domain.StyleIDTOC5, domain.StyleIDTOC6,
                domain.StyleIDTOC7, domain.StyleIDTOC8, domain.StyleIDTOC9,
                domain.StyleIDHeader, domain.StyleIDFooter,
                domain.StyleIDFootnoteText, domain.StyleIDEndnoteText,
                domain.StyleIDBodyText, domain.StyleIDBodyTextIndent,
                domain.StyleIDNoSpacing,
        }

        for _, id := range builtInParagraphStyles </span><span class="cov7" title="352">{
                sm.builtInStyleIDs[id] = true
        }</span>

        // Mark built-in character style IDs
        <span class="cov3" title="11">builtInCharacterStyles := []string{
                domain.StyleIDDefaultParagraphFont,
                domain.StyleIDEmphasis, domain.StyleIDStrong, domain.StyleIDSubtle,
                domain.StyleIDIntenseEmphasis, domain.StyleIDIntenseReference,
                domain.StyleIDBookTitle,
                domain.StyleIDHyperlink, domain.StyleIDFollowedHyperlink,
        }

        for _, id := range builtInCharacterStyles </span><span class="cov6" title="99">{
                sm.builtInStyleIDs[id] = true
        }</span>

        // Create and add built-in styles
        <span class="cov3" title="11">sm.createBuiltInParagraphStyles()
        sm.createBuiltInCharacterStyles()

        // Set default styles
        sm.defaultStyles[domain.StyleTypeParagraph] = domain.StyleIDNormal
        sm.defaultStyles[domain.StyleTypeCharacter] = domain.StyleIDDefaultParagraphFont</span>
}

// createBuiltInParagraphStyles creates all built-in paragraph styles.
// Note: Error returns are intentionally ignored for built-in styles as they
// use only valid, hardcoded values that cannot fail under normal circumstances.
//
//nolint:errcheck // Built-in styles use hardcoded valid values
func (sm *styleManager) createBuiltInParagraphStyles() <span class="cov3" title="11">{
        // Normal style (base for all paragraphs)
        normal := newParagraphStyle(domain.StyleIDNormal, "Normal", true)
        normal.SetAlignment(domain.AlignmentLeft)
        normal.SetDefault(true)
        sm.styles[domain.StyleIDNormal] = normal

        // Heading styles
        headings := []struct {
                id           string
                name         string
                outlineLevel int
                size         int // in half-points
                bold         bool
        }{
                {domain.StyleIDHeading1, "Heading 1", 1, 32, true},  // 16pt
                {domain.StyleIDHeading2, "Heading 2", 2, 26, true},  // 13pt
                {domain.StyleIDHeading3, "Heading 3", 3, 24, true},  // 12pt
                {domain.StyleIDHeading4, "Heading 4", 4, 24, true},  // 12pt
                {domain.StyleIDHeading5, "Heading 5", 5, 22, true},  // 11pt
                {domain.StyleIDHeading6, "Heading 6", 6, 22, false}, // 11pt
                {domain.StyleIDHeading7, "Heading 7", 7, 22, false}, // 11pt
                {domain.StyleIDHeading8, "Heading 8", 8, 22, false}, // 11pt
                {domain.StyleIDHeading9, "Heading 9", 9, 22, false}, // 11pt
        }

        for _, h := range headings </span><span class="cov6" title="99">{
                style := newParagraphStyle(h.id, h.name, true)
                style.SetBasedOn(domain.StyleIDNormal)
                style.SetOutlineLevel(h.outlineLevel)
                style.SetSpacingBefore(240) // 240 twips = 12pt
                style.SetSpacingAfter(120)  // 120 twips = 6pt
                style.SetKeepNext(true)
                style.SetKeepLines(true)
                
                // Set font through the base Style interface
                font := domain.Font{Name: "Calibri Light"}
                style.SetFont(font)
                
                sm.styles[h.id] = style
        }</span>

        // Title and Subtitle
        <span class="cov3" title="11">title := newParagraphStyle(domain.StyleIDTitle, "Title", true)
        title.SetBasedOn(domain.StyleIDNormal)
        title.SetSpacingAfter(180)
        sm.styles[domain.StyleIDTitle] = title

        subtitle := newParagraphStyle(domain.StyleIDSubtitle, "Subtitle", true)
        subtitle.SetBasedOn(domain.StyleIDNormal)
        sm.styles[domain.StyleIDSubtitle] = subtitle

        // Quote styles
        quote := newParagraphStyle(domain.StyleIDQuote, "Quote", true)
        quote.SetBasedOn(domain.StyleIDNormal)
        quote.SetIndentation(domain.Indentation{Left: 720, Right: 720}) // 0.5 inch
        sm.styles[domain.StyleIDQuote] = quote

        // List Paragraph
        listPara := newParagraphStyle(domain.StyleIDListParagraph, "List Paragraph", true)
        listPara.SetBasedOn(domain.StyleIDNormal)
        listPara.SetIndentation(domain.Indentation{Left: 720})
        sm.styles[domain.StyleIDListParagraph] = listPara

        // TOC styles
        for i := 1; i &lt;= 9; i++ </span><span class="cov6" title="99">{
                id := ""
                name := ""
                switch i </span>{
                case 1:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC1, "TOC 1"</span>
                case 2:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC2, "TOC 2"</span>
                case 3:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC3, "TOC 3"</span>
                case 4:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC4, "TOC 4"</span>
                case 5:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC5, "TOC 5"</span>
                case 6:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC6, "TOC 6"</span>
                case 7:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC7, "TOC 7"</span>
                case 8:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC8, "TOC 8"</span>
                case 9:<span class="cov3" title="11">
                        id, name = domain.StyleIDTOC9, "TOC 9"</span>
                }
                <span class="cov6" title="99">tocStyle := newParagraphStyle(id, name, true)
                tocStyle.SetBasedOn(domain.StyleIDNormal)
                tocStyle.SetIndentation(domain.Indentation{Left: (i - 1) * 220})
                sm.styles[id] = tocStyle</span>
        }

        // Header and Footer
        <span class="cov3" title="11">header := newParagraphStyle(domain.StyleIDHeader, "Header", true)
        header.SetBasedOn(domain.StyleIDNormal)
        sm.styles[domain.StyleIDHeader] = header

        footer := newParagraphStyle(domain.StyleIDFooter, "Footer", true)
        footer.SetBasedOn(domain.StyleIDNormal)
        sm.styles[domain.StyleIDFooter] = footer

        // Body Text variants
        bodyText := newParagraphStyle(domain.StyleIDBodyText, "Body Text", true)
        bodyText.SetBasedOn(domain.StyleIDNormal)
        sm.styles[domain.StyleIDBodyText] = bodyText

        noSpacing := newParagraphStyle(domain.StyleIDNoSpacing, "No Spacing", true)
        noSpacing.SetBasedOn(domain.StyleIDNormal)
        noSpacing.SetSpacingBefore(0)
        noSpacing.SetSpacingAfter(0)
        sm.styles[domain.StyleIDNoSpacing] = noSpacing</span>
}

// createBuiltInCharacterStyles creates all built-in character styles.
// Note: Error returns are intentionally ignored for built-in styles as they
// use only valid, hardcoded values that cannot fail under normal circumstances.
//
//nolint:errcheck // Built-in styles use hardcoded valid values
func (sm *styleManager) createBuiltInCharacterStyles() <span class="cov3" title="11">{
        // Default Paragraph Font (base for all character styles)
        defaultFont := newCharacterStyle(domain.StyleIDDefaultParagraphFont, "Default Paragraph Font", true)
        defaultFont.SetDefault(true)
        sm.styles[domain.StyleIDDefaultParagraphFont] = defaultFont

        // Emphasis (italic)
        emphasis := newCharacterStyle(domain.StyleIDEmphasis, "Emphasis", true)
        emphasis.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        emphasis.SetItalic(true)
        sm.styles[domain.StyleIDEmphasis] = emphasis

        // Strong (bold)
        strong := newCharacterStyle(domain.StyleIDStrong, "Strong", true)
        strong.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        strong.SetBold(true)
        sm.styles[domain.StyleIDStrong] = strong

        // Hyperlink (blue, underlined)
        hyperlink := newCharacterStyle(domain.StyleIDHyperlink, "Hyperlink", true)
        hyperlink.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        hyperlink.SetColor(domain.Color{R: 0, G: 0, B: 255}) // Blue
        hyperlink.SetUnderline(domain.UnderlineSingle)
        sm.styles[domain.StyleIDHyperlink] = hyperlink

        // Followed Hyperlink (purple, underlined)
        followedHyperlink := newCharacterStyle(domain.StyleIDFollowedHyperlink, "Followed Hyperlink", true)
        followedHyperlink.SetBasedOn(domain.StyleIDDefaultParagraphFont)
        followedHyperlink.SetColor(domain.Color{R: 128, G: 0, B: 128}) // Purple
        followedHyperlink.SetUnderline(domain.UnderlineSingle)
        sm.styles[domain.StyleIDFollowedHyperlink] = followedHyperlink
}</span>

// GetStyle retrieves a style by ID.
func (sm *styleManager) GetStyle(styleID string) (domain.Style, error) <span class="cov6" title="103">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        style, exists := sm.styles[styleID]
        if !exists </span><span class="cov1" title="1">{
                return nil, errors.NewNotFoundError(
                        "StyleManager.GetStyle",
                        "style",
                        styleID,
                        "style not found",
                )
        }</span>

        <span class="cov6" title="102">return style, nil</span>
}

// AddStyle adds a new custom style.
func (sm *styleManager) AddStyle(style domain.Style) error <span class="cov6" title="104">{
        if style == nil </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "style",
                        nil,
                        "style cannot be nil",
                )
        }</span>

        <span class="cov6" title="104">styleID := style.ID()
        if styleID == "" </span><span class="cov0" title="0">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "style.ID",
                        "",
                        "style ID cannot be empty",
                )
        }</span>

        <span class="cov6" title="104">sm.mu.Lock()
        defer sm.mu.Unlock()

        // Check if it's a built-in style
        if sm.builtInStyleIDs[styleID] </span><span class="cov1" title="1">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "styleID",
                        styleID,
                        "cannot override built-in style",
                )
        }</span>

        // Check if already exists
        <span class="cov6" title="103">if _, exists := sm.styles[styleID]; exists </span><span class="cov1" title="1">{
                return errors.NewValidationError(
                        "StyleManager.AddStyle",
                        "styleID",
                        styleID,
                        "style already exists",
                )
        }</span>

        <span class="cov6" title="102">sm.styles[styleID] = style
        return nil</span>
}

// RemoveStyle removes a custom style.
func (sm *styleManager) RemoveStyle(styleID string) error <span class="cov2" title="3">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Cannot remove built-in styles
        if sm.builtInStyleIDs[styleID] </span><span class="cov1" title="1">{
                return errors.NewValidationError(
                        "StyleManager.RemoveStyle",
                        "styleID",
                        styleID,
                        "cannot remove built-in style",
                )
        }</span>

        <span class="cov1" title="2">if _, exists := sm.styles[styleID]; !exists </span><span class="cov1" title="1">{
                return errors.NewNotFoundError(
                        "StyleManager.RemoveStyle",
                        "style",
                        styleID,
                        "style not found",
                )
        }</span>

        <span class="cov1" title="1">delete(sm.styles, styleID)
        return nil</span>
}

// ListStyles returns all available styles.
func (sm *styleManager) ListStyles() []domain.Style <span class="cov6" title="101">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        styles := make([]domain.Style, 0, len(sm.styles))
        for _, style := range sm.styles </span><span class="cov10" title="3875">{
                styles = append(styles, style)
        }</span>

        <span class="cov6" title="101">return styles</span>
}

// ListStylesByType returns all styles of a specific type.
func (sm *styleManager) ListStylesByType(styleType domain.StyleType) []domain.Style <span class="cov1" title="2">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        styles := make([]domain.Style, 0)
        for _, style := range sm.styles </span><span class="cov5" title="64">{
                if style.Type() == styleType </span><span class="cov4" title="32">{
                        styles = append(styles, style)
                }</span>
        }

        <span class="cov1" title="2">return styles</span>
}

// DefaultStyle returns the default style for a type.
func (sm *styleManager) DefaultStyle(styleType domain.StyleType) (domain.Style, error) <span class="cov2" title="3">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        styleID, exists := sm.defaultStyles[styleType]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NewNotFoundError(
                        "StyleManager.DefaultStyle",
                        "default style",
                        styleType,
                        "no default style set for type",
                )
        }</span>

        <span class="cov2" title="3">return sm.styles[styleID], nil</span>
}

// SetDefaultStyle sets the default style for a type.
func (sm *styleManager) SetDefaultStyle(styleType domain.StyleType, styleID string) error <span class="cov2" title="3">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Verify style exists
        style, exists := sm.styles[styleID]
        if !exists </span><span class="cov1" title="1">{
                return errors.NewNotFoundError(
                        "StyleManager.SetDefaultStyle",
                        "style",
                        styleID,
                        "style not found",
                )
        }</span>

        // Verify style type matches
        <span class="cov1" title="2">if style.Type() != styleType </span><span class="cov1" title="1">{
                return errors.NewValidationError(
                        "StyleManager.SetDefaultStyle",
                        "styleType",
                        styleType,
                        "style type mismatch",
                )
        }</span>

        <span class="cov1" title="1">sm.defaultStyles[styleType] = styleID
        return nil</span>
}

// HasStyle checks if a style exists.
func (sm *styleManager) HasStyle(styleID string) bool <span class="cov6" title="130">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        _, exists := sm.styles[styleID]
        return exists
}</span>

// IsBuiltIn checks if a style is built-in (not custom).
func (sm *styleManager) IsBuiltIn(styleID string) bool <span class="cov2" title="3">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        return sm.builtInStyleIDs[styleID]
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package serializer converts domain objects into XML structures for OOXML serialization.
// It provides serializers for documents, paragraphs, runs, tables, and other document elements.
package serializer

/*
   Copyright (c) 2025 SlideLang

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as published
   by the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
*/

import (
        "fmt"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/internal/xml"
        "github.com/mmonterroca/docxgo/pkg/color"
        "github.com/mmonterroca/docxgo/pkg/constants"
)

// RunSerializer converts a domain.Run to xml.Run
type RunSerializer struct{}

// NewRunSerializer creates a new RunSerializer.
func NewRunSerializer() *RunSerializer <span class="cov9" title="9">{
        return &amp;RunSerializer{}
}</span>

// Serialize converts a domain.Run to xml.Run.
func (s *RunSerializer) Serialize(run domain.Run) *xml.Run <span class="cov8" title="7">{
        xmlRun := &amp;xml.Run{
                Properties: s.serializeProperties(run),
                Text:       s.serializeText(run),
        }
        return xmlRun
}</span>

func (s *RunSerializer) serializeProperties(run domain.Run) *xml.RunProperties <span class="cov8" title="7">{
        props := &amp;xml.RunProperties{}

        // Bold
        if run.Bold() </span><span class="cov6" title="4">{
                props.Bold = &amp;xml.BoolValue{Val: boolPtr(true)}
        }</span>

        // Italic
        <span class="cov8" title="7">if run.Italic() </span><span class="cov1" title="1">{
                props.Italic = &amp;xml.BoolValue{Val: boolPtr(true)}
        }</span>

        // Strike
        <span class="cov8" title="7">if run.Strike() </span><span class="cov0" title="0">{
                props.Strike = &amp;xml.BoolValue{Val: boolPtr(true)}
        }</span>

        // Underline
        <span class="cov8" title="7">if run.Underline() != domain.UnderlineNone </span><span class="cov0" title="0">{
                props.Underline = &amp;xml.Underline{
                        Val: s.underlineStyleToString(run.Underline()),
                }
        }</span>

        // Color
        <span class="cov8" title="7">if run.Color() != domain.ColorBlack </span><span class="cov1" title="1">{
                props.Color = &amp;xml.Color{
                        Val: color.ToHex(run.Color()),
                }
        }</span>

        // Font size
        <span class="cov8" title="7">if run.Size() != constants.DefaultFontSize </span><span class="cov1" title="1">{
                props.Size = &amp;xml.HalfPt{Val: run.Size()}
                props.SizeCS = &amp;xml.HalfPt{Val: run.Size()}
        }</span>

        // Font
        <span class="cov8" title="7">font := run.Font()
        if font.Name != "" &amp;&amp; font.Name != constants.DefaultFontName </span><span class="cov0" title="0">{
                props.Font = &amp;xml.Font{
                        ASCII:    font.Name,
                        EastAsia: font.EastAsia,
                        CS:       font.CS,
                }
        }</span>

        // Highlight
        <span class="cov8" title="7">if run.Highlight() != domain.HighlightNone </span><span class="cov0" title="0">{
                props.Highlight = &amp;xml.Highlight{
                        Val: s.highlightColorToString(run.Highlight()),
                }
        }</span>

        <span class="cov8" title="7">return props</span>
}

func (s *RunSerializer) serializeText(run domain.Run) *xml.Text <span class="cov8" title="7">{
        text := run.Text()
        if text == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="7">xmlText := &amp;xml.Text{
                Content: text,
        }

        // Preserve spaces if text starts/ends with space
        if len(text) &gt; 0 &amp;&amp; (text[0] == ' ' || text[len(text)-1] == ' ') </span><span class="cov1" title="1">{
                xmlText.Space = "preserve"
        }</span>

        <span class="cov8" title="7">return xmlText</span>
}

func (s *RunSerializer) underlineStyleToString(style domain.UnderlineStyle) string <span class="cov0" title="0">{
        switch style </span>{
        case domain.UnderlineNone:<span class="cov0" title="0">
                return constants.UnderlineValueNone</span>
        case domain.UnderlineSingle:<span class="cov0" title="0">
                return constants.UnderlineValueSingle</span>
        case domain.UnderlineDouble:<span class="cov0" title="0">
                return constants.UnderlineValueDouble</span>
        case domain.UnderlineThick:<span class="cov0" title="0">
                return constants.UnderlineValueThick</span>
        case domain.UnderlineDotted:<span class="cov0" title="0">
                return constants.UnderlineValueDotted</span>
        case domain.UnderlineDashed:<span class="cov0" title="0">
                return constants.UnderlineValueDashed</span>
        case domain.UnderlineWave:<span class="cov0" title="0">
                return constants.UnderlineValueWave</span>
        default:<span class="cov0" title="0">
                return constants.UnderlineValueSingle</span>
        }
}

func (s *RunSerializer) highlightColorToString(hlColor domain.HighlightColor) string <span class="cov0" title="0">{
        switch hlColor </span>{
        case domain.HighlightNone:<span class="cov0" title="0">
                return constants.HighlightValueNone</span>
        case domain.HighlightYellow:<span class="cov0" title="0">
                return constants.HighlightValueYellow</span>
        case domain.HighlightGreen:<span class="cov0" title="0">
                return constants.HighlightValueGreen</span>
        case domain.HighlightCyan:<span class="cov0" title="0">
                return constants.HighlightValueCyan</span>
        case domain.HighlightMagenta:<span class="cov0" title="0">
                return constants.HighlightValueMagenta</span>
        case domain.HighlightBlue:<span class="cov0" title="0">
                return constants.HighlightValueBlue</span>
        case domain.HighlightRed:<span class="cov0" title="0">
                return constants.HighlightValueRed</span>
        case domain.HighlightDarkBlue:<span class="cov0" title="0">
                return constants.HighlightValueDarkBlue</span>
        case domain.HighlightDarkCyan:<span class="cov0" title="0">
                return constants.HighlightValueDarkCyan</span>
        case domain.HighlightDarkGreen:<span class="cov0" title="0">
                return constants.HighlightValueDarkGreen</span>
        case domain.HighlightDarkMagenta:<span class="cov0" title="0">
                return constants.HighlightValueDarkMagenta</span>
        case domain.HighlightDarkRed:<span class="cov0" title="0">
                return constants.HighlightValueDarkRed</span>
        case domain.HighlightDarkYellow:<span class="cov0" title="0">
                return constants.HighlightValueDarkYellow</span>
        case domain.HighlightDarkGray:<span class="cov0" title="0">
                return constants.HighlightValueDarkGray</span>
        case domain.HighlightLightGray:<span class="cov0" title="0">
                return constants.HighlightValueLightGray</span>
        default:<span class="cov0" title="0">
                return constants.HighlightValueNone</span>
        }
}

// ParagraphSerializer converts a domain.Paragraph to xml.Paragraph
type ParagraphSerializer struct {
        runSerializer *RunSerializer
}

// NewParagraphSerializer creates a new ParagraphSerializer.
func NewParagraphSerializer() *ParagraphSerializer <span class="cov8" title="7">{
        return &amp;ParagraphSerializer{
                runSerializer: NewRunSerializer(),
        }
}</span>

// Serialize converts a domain.Paragraph to xml.Paragraph.
func (s *ParagraphSerializer) Serialize(para domain.Paragraph) *xml.Paragraph <span class="cov7" title="5">{
        xmlPara := &amp;xml.Paragraph{
                Properties: s.serializeProperties(para),
                Runs:       make([]*xml.Run, 0, len(para.Runs())),
        }

        // Serialize runs
        for _, run := range para.Runs() </span><span class="cov7" title="5">{
                xmlPara.Runs = append(xmlPara.Runs, s.runSerializer.Serialize(run))
        }</span>

        <span class="cov7" title="5">return xmlPara</span>
}

func (s *ParagraphSerializer) serializeProperties(para domain.Paragraph) *xml.ParagraphProperties <span class="cov7" title="5">{
        props := &amp;xml.ParagraphProperties{}

        // Alignment
        if para.Alignment() != domain.AlignmentLeft </span><span class="cov1" title="1">{
                props.Justification = &amp;xml.Justification{
                        Val: s.alignmentToString(para.Alignment()),
                }
        }</span>

        // Indentation
        <span class="cov7" title="5">indent := para.Indent()
        if indent.Left != 0 || indent.Right != 0 || indent.FirstLine != 0 || indent.Hanging != 0 </span><span class="cov1" title="1">{
                props.Indentation = &amp;xml.Indentation{
                        Left:      intPtrIfNotZero(indent.Left),
                        Right:     intPtrIfNotZero(indent.Right),
                        FirstLine: intPtrIfNotZero(indent.FirstLine),
                        Hanging:   intPtrIfNotZero(indent.Hanging),
                }
        }</span>

        // Spacing
        <span class="cov7" title="5">before := para.SpacingBefore()
        after := para.SpacingAfter()
        lineSpacing := para.LineSpacing()

        if before != 0 || after != 0 || lineSpacing.Value != constants.DefaultLineSpacing </span><span class="cov0" title="0">{
                props.Spacing = &amp;xml.Spacing{
                        Before:   intPtrIfNotZero(before),
                        After:    intPtrIfNotZero(after),
                        Line:     intPtrIfNotZero(lineSpacing.Value),
                        LineRule: s.lineSpacingRuleToString(lineSpacing.Rule),
                }
        }</span>

        <span class="cov7" title="5">return props</span>
}

func (s *ParagraphSerializer) alignmentToString(align domain.Alignment) string <span class="cov1" title="1">{
        switch align </span>{
        case domain.AlignmentLeft:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        case domain.AlignmentCenter:<span class="cov1" title="1">
                return constants.AlignmentValueCenter</span>
        case domain.AlignmentRight:<span class="cov0" title="0">
                return constants.AlignmentValueRight</span>
        case domain.AlignmentJustify:<span class="cov0" title="0">
                return constants.AlignmentValueJustify</span>
        case domain.AlignmentDistribute:<span class="cov0" title="0">
                return constants.AlignmentValueDistribute</span>
        default:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        }
}

func (s *ParagraphSerializer) lineSpacingRuleToString(rule domain.LineSpacingRule) *string <span class="cov0" title="0">{
        var val string
        switch rule </span>{
        case domain.LineSpacingAuto:<span class="cov0" title="0">
                val = constants.LineSpacingRuleAuto</span>
        case domain.LineSpacingExact:<span class="cov0" title="0">
                val = constants.LineSpacingRuleExact</span>
        case domain.LineSpacingAtLeast:<span class="cov0" title="0">
                val = constants.LineSpacingRuleAtLeast</span>
        default:<span class="cov0" title="0">
                val = constants.LineSpacingRuleAuto</span>
        }
        <span class="cov0" title="0">return &amp;val</span>
}

// TableSerializer converts domain tables to XML
type TableSerializer struct {
        paraSerializer *ParagraphSerializer
}

// NewTableSerializer creates a new TableSerializer.
func NewTableSerializer() *TableSerializer <span class="cov5" title="3">{
        return &amp;TableSerializer{
                paraSerializer: NewParagraphSerializer(),
        }
}</span>

// Serialize converts a domain.Table to xml.Table.
func (s *TableSerializer) Serialize(table domain.Table) *xml.Table <span class="cov3" title="2">{
        xmlTable := &amp;xml.Table{
                Properties: s.serializeTableProperties(table),
                Grid:       s.serializeGrid(table),
                Rows:       make([]*xml.TableRow, 0, table.RowCount()),
        }

        // Serialize rows
        for i := 0; i &lt; table.RowCount(); i++ </span><span class="cov6" title="4">{
                row, _ := table.Row(i)
                xmlTable.Rows = append(xmlTable.Rows, s.serializeRow(row))
        }</span>

        <span class="cov3" title="2">return xmlTable</span>
}

func (s *TableSerializer) serializeTableProperties(table domain.Table) *xml.TableProperties <span class="cov3" title="2">{
        props := &amp;xml.TableProperties{}

        // Width
        width := table.Width()
        props.Width = &amp;xml.TableWidth{
                Type: s.widthTypeToString(width.Type),
                W:    width.Value,
        }

        // Alignment
        if table.Alignment() != domain.AlignmentLeft </span><span class="cov0" title="0">{
                props.Jc = &amp;xml.Justification{
                        Val: s.alignmentToString(table.Alignment()),
                }
        }</span>

        // Style
        <span class="cov3" title="2">if style := table.Style(); style.Name != "" </span><span class="cov0" title="0">{
                props.Style = &amp;xml.TableStyle{
                        Val: style.Name,
                }
        }</span>

        <span class="cov3" title="2">return props</span>
}

func (s *TableSerializer) serializeGrid(table domain.Table) *xml.TableGrid <span class="cov3" title="2">{
        grid := &amp;xml.TableGrid{
                Cols: make([]*xml.GridCol, table.ColumnCount()),
        }

        for i := 0; i &lt; table.ColumnCount(); i++ </span><span class="cov7" title="5">{
                grid.Cols[i] = &amp;xml.GridCol{}
        }</span>

        <span class="cov3" title="2">return grid</span>
}

func (s *TableSerializer) serializeRow(row domain.TableRow) *xml.TableRow <span class="cov6" title="4">{
        xmlRow := &amp;xml.TableRow{
                Cells: make([]*xml.TableCell, 0, len(row.Cells())),
        }

        // Height
        if row.Height() &gt; 0 </span><span class="cov0" title="0">{
                xmlRow.Properties = &amp;xml.TableRowProperties{
                        Height: &amp;xml.TableRowHeight{
                                Val:  row.Height(),
                                Rule: "atLeast",
                        },
                }
        }</span>

        // Serialize cells
        <span class="cov6" title="4">for _, cell := range row.Cells() </span><span class="cov10" title="10">{
                xmlRow.Cells = append(xmlRow.Cells, s.serializeCell(cell))
        }</span>

        <span class="cov6" title="4">return xmlRow</span>
}

func (s *TableSerializer) serializeCell(cell domain.TableCell) *xml.TableCell <span class="cov10" title="10">{
        xmlCell := &amp;xml.TableCell{
                Properties: s.serializeCellProperties(cell),
                Paragraphs: make([]*xml.Paragraph, 0, len(cell.Paragraphs())),
                Tables:     make([]*xml.Table, 0, len(cell.Tables())),
        }

        // Serialize paragraphs
        for _, para := range cell.Paragraphs() </span><span class="cov1" title="1">{
                xmlCell.Paragraphs = append(xmlCell.Paragraphs, s.paraSerializer.Serialize(para))
        }</span>

        // Serialize nested tables
        <span class="cov10" title="10">for _, table := range cell.Tables() </span><span class="cov0" title="0">{
                xmlCell.Tables = append(xmlCell.Tables, s.Serialize(table))
        }</span>

        // Add empty paragraph if cell has no content
        <span class="cov10" title="10">if len(xmlCell.Paragraphs) == 0 &amp;&amp; len(xmlCell.Tables) == 0 </span><span class="cov9" title="9">{
                xmlCell.Paragraphs = append(xmlCell.Paragraphs, &amp;xml.Paragraph{})
        }</span>

        <span class="cov10" title="10">return xmlCell</span>
}

func (s *TableSerializer) serializeCellProperties(cell domain.TableCell) *xml.TableCellProperties <span class="cov10" title="10">{
        props := &amp;xml.TableCellProperties{}

        // Width
        if cell.Width() &gt; 0 </span><span class="cov0" title="0">{
                props.Width = &amp;xml.TableWidth{
                        Type: constants.WidthTypeDXA,
                        W:    cell.Width(),
                }
        }</span>

        // GridSpan (horizontal merge)
        <span class="cov10" title="10">if cell.GridSpan() &gt; 1 </span><span class="cov0" title="0">{
                props.GridSpan = &amp;xml.GridSpan{
                        Val: cell.GridSpan(),
                }
        }</span>

        // VMerge (vertical merge)
        <span class="cov10" title="10">if cell.VMerge() != domain.VMergeNone </span><span class="cov0" title="0">{
                vMerge := &amp;xml.VMerge{}
                if cell.VMerge() == domain.VMergeRestart </span><span class="cov0" title="0">{
                        vMerge.Val = "restart"
                }</span>
                // VMergeContinue uses empty Val (omitted)
                <span class="cov0" title="0">props.VMerge = vMerge</span>
        }

        // Vertical alignment
        <span class="cov10" title="10">if cell.VerticalAlignment() != domain.VerticalAlignTop </span><span class="cov0" title="0">{
                props.VAlign = &amp;xml.VerticalAlign{
                        Val: s.verticalAlignToString(cell.VerticalAlignment()),
                }
        }</span>

        // Shading
        <span class="cov10" title="10">if cell.Shading() != domain.ColorWhite </span><span class="cov0" title="0">{
                props.Shading = &amp;xml.Shading{
                        Val:  "clear",
                        Fill: color.ToHex(cell.Shading()),
                }
        }</span>

        <span class="cov10" title="10">return props</span>
}

func (s *TableSerializer) widthTypeToString(wType domain.WidthType) string <span class="cov3" title="2">{
        switch wType </span>{
        case domain.WidthAuto:<span class="cov3" title="2">
                return constants.WidthTypeAuto</span>
        case domain.WidthDXA:<span class="cov0" title="0">
                return constants.WidthTypeDXA</span>
        case domain.WidthPct:<span class="cov0" title="0">
                return constants.WidthTypePct</span>
        default:<span class="cov0" title="0">
                return constants.WidthTypeAuto</span>
        }
}

func (s *TableSerializer) alignmentToString(align domain.Alignment) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.AlignmentLeft:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        case domain.AlignmentCenter:<span class="cov0" title="0">
                return constants.AlignmentValueCenter</span>
        case domain.AlignmentRight:<span class="cov0" title="0">
                return constants.AlignmentValueRight</span>
        case domain.AlignmentJustify:<span class="cov0" title="0">
                return constants.AlignmentValueJustify</span>
        case domain.AlignmentDistribute:<span class="cov0" title="0">
                return constants.AlignmentValueDistribute</span>
        default:<span class="cov0" title="0">
                return constants.AlignmentValueLeft</span>
        }
}

func (s *TableSerializer) verticalAlignToString(align domain.VerticalAlignment) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.VerticalAlignTop:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueTop</span>
        case domain.VerticalAlignCenter:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueCenter</span>
        case domain.VerticalAlignBottom:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueBottom</span>
        default:<span class="cov0" title="0">
                return constants.VerticalAlignmentValueTop</span>
        }
}

// Helper functions

func boolPtr(b bool) *bool <span class="cov7" title="5">{
        return &amp;b
}</span>

func intPtrIfNotZero(i int) *int <span class="cov6" title="4">{
        if i == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="3">return &amp;i</span>
}

// DocumentSerializer converts a domain.Document to XML structures
type DocumentSerializer struct {
        paraSerializer  *ParagraphSerializer
        tableSerializer *TableSerializer
}

// NewDocumentSerializer creates a new DocumentSerializer.
func NewDocumentSerializer() *DocumentSerializer <span class="cov3" title="2">{
        return &amp;DocumentSerializer{
                paraSerializer:  NewParagraphSerializer(),
                tableSerializer: NewTableSerializer(),
        }
}</span>

// SerializeBody converts document content to xml.Body.
func (s *DocumentSerializer) SerializeBody(doc domain.Document) *xml.Body <span class="cov3" title="2">{
        body := &amp;xml.Body{
                Paragraphs: make([]*xml.Paragraph, 0, len(doc.Paragraphs())),
                Tables:     make([]*xml.Table, 0, len(doc.Tables())),
        }

        // For now, serialize all paragraphs then all tables
        // TODO: Maintain insertion order
        for _, para := range doc.Paragraphs() </span><span class="cov3" title="2">{
                body.Paragraphs = append(body.Paragraphs, s.paraSerializer.Serialize(para))
        }</span>

        <span class="cov3" title="2">for _, table := range doc.Tables() </span><span class="cov1" title="1">{
                body.Tables = append(body.Tables, s.tableSerializer.Serialize(table))
        }</span>

        <span class="cov3" title="2">return body</span>
}

// SerializeDocument creates the complete document XML structure.
func (s *DocumentSerializer) SerializeDocument(doc domain.Document) *xml.Document <span class="cov3" title="2">{
        return &amp;xml.Document{
                XMLnsW: constants.NamespaceMain,
                XMLnsR: constants.NamespaceRelationships,
                Body:   s.SerializeBody(doc),
        }
}</span>

// SerializeCoreProperties converts metadata to core properties.
func (s *DocumentSerializer) SerializeCoreProperties(meta *domain.Metadata) *xml.CoreProperties <span class="cov1" title="1">{
        props := &amp;xml.CoreProperties{
                XMLnsCP:      constants.NamespaceCoreProperties,
                XMLnsDC:      constants.NamespaceDC,
                XMLnsDCTerms: constants.NamespaceDCTerms,
                XMLnsXSI:     "http://www.w3.org/2001/XMLSchema-instance",
                Title:        meta.Title,
                Subject:      meta.Subject,
                Creator:      meta.Creator,
                Description:  meta.Description,
        }

        // Keywords
        if len(meta.Keywords) &gt; 0 </span><span class="cov0" title="0">{
                keywords := ""
                for i, kw := range meta.Keywords </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                keywords += ", "
                        }</span>
                        <span class="cov0" title="0">keywords += kw</span>
                }
                <span class="cov0" title="0">props.Keywords = keywords</span>
        }

        // Dates
        <span class="cov1" title="1">if meta.Created != "" </span><span class="cov0" title="0">{
                props.Created = &amp;xml.DCDate{
                        Type:  "dcterms:W3CDTF",
                        Value: meta.Created,
                }
        }</span>
        <span class="cov1" title="1">if meta.Modified != "" </span><span class="cov0" title="0">{
                props.Modified = &amp;xml.DCDate{
                        Type:  "dcterms:W3CDTF",
                        Value: meta.Modified,
                }
        }</span>

        <span class="cov1" title="1">return props</span>
}

// SerializeAppProperties creates app.xml properties.
func (s *DocumentSerializer) SerializeAppProperties(doc domain.Document) *xml.AppProperties <span class="cov0" title="0">{
        return &amp;xml.AppProperties{
                Xmlns:       constants.NamespaceExtendedProperties,
                Application: "go-docx/v2",
                DocSecurity: 0,
                Lines:       0,
                Paragraphs:  len(doc.Paragraphs()),
                Company:     "SlideLang",
        }
}</span>

// DebugPrint outputs document statistics for testing and debugging purposes.
func (s *DocumentSerializer) DebugPrint(doc domain.Document) <span class="cov0" title="0">{
        fmt.Printf("Document has %d paragraphs and %d tables\n",
                len(doc.Paragraphs()), len(doc.Tables()))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package writer handles writing DOCX files as ZIP archives containing XML documents.
// It provides the ZipWriter for creating properly structured Office Open XML packages.
package writer

/*
   Copyright (c) 2025 SlideLang

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

import (
        "archive/zip"
        "encoding/xml"
        "fmt"
        "io"
        "time"

        "github.com/mmonterroca/docxgo/internal/serializer"
        xmlstructs "github.com/mmonterroca/docxgo/internal/xml"
        "github.com/mmonterroca/docxgo/pkg/constants"
)

// ZipWriter writes a .docx file to an io.Writer.
type ZipWriter struct {
        zipWriter  *zip.Writer
        serializer *serializer.DocumentSerializer
}

// NewZipWriter creates a new ZipWriter.
func NewZipWriter(w io.Writer) *ZipWriter <span class="cov4" title="3">{
        return &amp;ZipWriter{
                zipWriter:  zip.NewWriter(w),
                serializer: serializer.NewDocumentSerializer(),
        }
}</span>

// WriteDocument writes a complete .docx document structure.
func (zw *ZipWriter) WriteDocument(doc *xmlstructs.Document, rels *xmlstructs.Relationships, coreProps *xmlstructs.CoreProperties, appProps *xmlstructs.AppProperties) error <span class="cov4" title="3">{
        // Write [Content_Types].xml
        if err := zw.writeContentTypes(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write content types: %w", err)
        }</span>

        // Write _rels/.rels
        <span class="cov4" title="3">if err := zw.writeRootRels(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write root rels: %w", err)
        }</span>

        // Write word/document.xml
        <span class="cov4" title="3">if err := zw.writeMainDocument(doc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write main document: %w", err)
        }</span>

        // Write word/_rels/document.xml.rels
        <span class="cov4" title="3">if err := zw.writeDocumentRels(rels); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write document rels: %w", err)
        }</span>

        // Write docProps/core.xml
        <span class="cov4" title="3">if err := zw.writeCoreProperties(coreProps); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write core properties: %w", err)
        }</span>

        // Write docProps/app.xml
        <span class="cov4" title="3">if err := zw.writeAppProperties(appProps); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write app properties: %w", err)
        }</span>

        // Write word/styles.xml (minimal default)
        <span class="cov4" title="3">if err := zw.writeDefaultStyles(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write styles: %w", err)
        }</span>

        // Write word/fontTable.xml (minimal default)
        <span class="cov4" title="3">if err := zw.writeDefaultFontTable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write font table: %w", err)
        }</span>

        // Write word/theme/theme1.xml (minimal default)
        <span class="cov4" title="3">if err := zw.writeDefaultTheme(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write theme: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// Close closes the ZIP writer.
func (zw *ZipWriter) Close() error <span class="cov4" title="3">{
        return zw.zipWriter.Close()
}</span>

// writeContentTypes writes [Content_Types].xml
func (zw *ZipWriter) writeContentTypes() error <span class="cov4" title="3">{
        ct := &amp;xmlstructs.ContentTypes{
                Xmlns: constants.NamespaceContentTypes,
                Defaults: []*xmlstructs.Default{
                        {Extension: "rels", ContentType: constants.ContentTypeRelationships},
                        {Extension: "xml", ContentType: "application/xml"},
                },
                Overrides: []*xmlstructs.Override{
                        {PartName: "/word/document.xml", ContentType: constants.ContentTypeDocument},
                        {PartName: "/word/styles.xml", ContentType: constants.ContentTypeStyles},
                        {PartName: "/word/fontTable.xml", ContentType: constants.ContentTypeFontTable},
                        {PartName: "/word/theme/theme1.xml", ContentType: constants.ContentTypeTheme},
                        {PartName: "/docProps/core.xml", ContentType: constants.ContentTypeCoreProperties},
                        {PartName: "/docProps/app.xml", ContentType: constants.ContentTypeExtendedProperties},
                },
        }

        return zw.writeXML("[Content_Types].xml", ct)
}</span>

// writeRootRels writes _rels/.rels
func (zw *ZipWriter) writeRootRels() error <span class="cov4" title="3">{
        rels := &amp;xmlstructs.Relationships{
                Xmlns: constants.NamespacePackageRels,
                Relationships: []*xmlstructs.Relationship{
                        {
                                ID:     "rId1",
                                Type:   constants.RelTypeDocument,
                                Target: "word/document.xml",
                        },
                        {
                                ID:     "rId2",
                                Type:   "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
                                Target: "docProps/core.xml",
                        },
                        {
                                ID:     "rId3",
                                Type:   "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
                                Target: "docProps/app.xml",
                        },
                },
        }

        return zw.writeXML("_rels/.rels", rels)
}</span>

// writeMainDocument writes word/document.xml
func (zw *ZipWriter) writeMainDocument(doc *xmlstructs.Document) error <span class="cov4" title="3">{
        return zw.writeXML("word/document.xml", doc)
}</span>

// writeDocumentRels writes word/_rels/document.xml.rels
func (zw *ZipWriter) writeDocumentRels(rels *xmlstructs.Relationships) error <span class="cov4" title="3">{
        if rels == nil </span><span class="cov0" title="0">{
                rels = &amp;xmlstructs.Relationships{
                        Xmlns:         constants.NamespacePackageRels,
                        Relationships: []*xmlstructs.Relationship{},
                }
        }</span>
        <span class="cov4" title="3">return zw.writeXML("word/_rels/document.xml.rels", rels)</span>
}

// writeCoreProperties writes docProps/core.xml
func (zw *ZipWriter) writeCoreProperties(props *xmlstructs.CoreProperties) error <span class="cov4" title="3">{
        if props == nil </span><span class="cov4" title="3">{
                now := time.Now()
                props = &amp;xmlstructs.CoreProperties{
                        XMLnsCP:      constants.NamespaceCoreProperties,
                        XMLnsDC:      constants.NamespaceDC,
                        XMLnsDCTerms: constants.NamespaceDCTerms,
                        XMLnsXSI:     "http://www.w3.org/2001/XMLSchema-instance",
                        Creator:      "go-docx v2",
                        Created: &amp;xmlstructs.DCDate{
                                Type:  "dcterms:W3CDTF",
                                Value: now.Format(time.RFC3339),
                        },
                        Modified: &amp;xmlstructs.DCDate{
                                Type:  "dcterms:W3CDTF",
                                Value: now.Format(time.RFC3339),
                        },
                }
        }</span>
        <span class="cov4" title="3">return zw.writeXML("docProps/core.xml", props)</span>
}

// writeAppProperties writes docProps/app.xml
func (zw *ZipWriter) writeAppProperties(props *xmlstructs.AppProperties) error <span class="cov4" title="3">{
        if props == nil </span><span class="cov4" title="3">{
                props = &amp;xmlstructs.AppProperties{
                        Xmlns:       constants.NamespaceExtendedProperties,
                        Application: "go-docx v2.0.0",
                        DocSecurity: 0,
                }
        }</span>
        <span class="cov4" title="3">return zw.writeXML("docProps/app.xml", props)</span>
}

// writeDefaultStyles writes minimal word/styles.xml
func (zw *ZipWriter) writeDefaultStyles() error <span class="cov4" title="3">{
        styles := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
  &lt;w:docDefaults&gt;
    &lt;w:rPrDefault&gt;
      &lt;w:rPr&gt;
        &lt;w:rFonts w:ascii="Calibri" w:hAnsi="Calibri"/&gt;
        &lt;w:sz w:val="22"/&gt;
      &lt;/w:rPr&gt;
    &lt;/w:rPrDefault&gt;
    &lt;w:pPrDefault/&gt;
  &lt;/w:docDefaults&gt;
&lt;/w:styles&gt;`
        return zw.writeRaw("word/styles.xml", []byte(styles))
}</span>

// writeDefaultFontTable writes minimal word/fontTable.xml
func (zw *ZipWriter) writeDefaultFontTable() error <span class="cov4" title="3">{
        fontTable := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;w:fonts xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
  &lt;w:font w:name="Calibri"&gt;
    &lt;w:panose1 w:val="020F0502020204030204"/&gt;
    &lt;w:charset w:val="00"/&gt;
    &lt;w:family w:val="swiss"/&gt;
    &lt;w:pitch w:val="variable"/&gt;
  &lt;/w:font&gt;
&lt;/w:fonts&gt;`
        return zw.writeRaw("word/fontTable.xml", []byte(fontTable))
}</span>

// writeDefaultTheme writes minimal word/theme/theme1.xml
func (zw *ZipWriter) writeDefaultTheme() error <span class="cov4" title="3">{
        theme := `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"&gt;
  &lt;a:themeElements&gt;
    &lt;a:clrScheme name="Office"&gt;
      &lt;a:dk1&gt;&lt;a:sysClr val="windowText"/&gt;&lt;/a:dk1&gt;
      &lt;a:lt1&gt;&lt;a:sysClr val="window"/&gt;&lt;/a:lt1&gt;
      &lt;a:dk2&gt;&lt;a:srgbClr val="44546A"/&gt;&lt;/a:dk2&gt;
      &lt;a:lt2&gt;&lt;a:srgbClr val="E7E6E6"/&gt;&lt;/a:lt2&gt;
      &lt;a:accent1&gt;&lt;a:srgbClr val="4472C4"/&gt;&lt;/a:accent1&gt;
      &lt;a:accent2&gt;&lt;a:srgbClr val="ED7D31"/&gt;&lt;/a:accent2&gt;
      &lt;a:accent3&gt;&lt;a:srgbClr val="A5A5A5"/&gt;&lt;/a:accent3&gt;
      &lt;a:accent4&gt;&lt;a:srgbClr val="FFC000"/&gt;&lt;/a:accent4&gt;
      &lt;a:accent5&gt;&lt;a:srgbClr val="5B9BD5"/&gt;&lt;/a:accent5&gt;
      &lt;a:accent6&gt;&lt;a:srgbClr val="70AD47"/&gt;&lt;/a:accent6&gt;
      &lt;a:hlink&gt;&lt;a:srgbClr val="0563C1"/&gt;&lt;/a:hlink&gt;
      &lt;a:folHlink&gt;&lt;a:srgbClr val="954F72"/&gt;&lt;/a:folHlink&gt;
    &lt;/a:clrScheme&gt;
    &lt;a:fontScheme name="Office"&gt;&lt;a:majorFont/&gt;&lt;a:minorFont/&gt;&lt;/a:fontScheme&gt;
    &lt;a:fmtScheme name="Office"&gt;&lt;a:fillStyleLst/&gt;&lt;a:lnStyleLst/&gt;&lt;a:effectStyleLst/&gt;&lt;a:bgFillStyleLst/&gt;&lt;/a:fmtScheme&gt;
  &lt;/a:themeElements&gt;
&lt;/a:theme&gt;`
        return zw.writeRaw("word/theme/theme1.xml", []byte(theme))
}</span>

// writeXML marshals and writes an XML structure to the ZIP.
func (zw *ZipWriter) writeXML(path string, v interface{}) error <span class="cov10" title="18">{
        w, err := zw.zipWriter.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write XML header
        <span class="cov10" title="18">if _, err := w.Write([]byte(xml.Header)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Marshal and write XML
        <span class="cov10" title="18">encoder := xml.NewEncoder(w)
        encoder.Indent("", "  ")
        if err := encoder.Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="18">return nil</span>
}

// writeRaw writes raw bytes to the ZIP.
func (zw *ZipWriter) writeRaw(path string, data []byte) error <span class="cov7" title="9">{
        w, err := zw.zipWriter.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="9">_, err = w.Write(data)
        return err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package xml

import "github.com/mmonterroca/docxgo/domain"

// NewInlineDrawing creates an inline drawing (flows with text).
func NewInlineDrawing(img domain.Image, drawingID int) *Drawing <span class="cov0" title="0">{
        size := img.Size()
        
        return &amp;Drawing{
                Inline: &amp;Inline{
                        DistT:  0,
                        DistB:  0,
                        DistL:  0,
                        DistR:  0,
                        Extent: &amp;Extent{
                                Cx: size.WidthEMU,
                                Cy: size.HeightEMU,
                        },
                        EffectExtent: &amp;EffectExtent{
                                L: 0,
                                T: 0,
                                R: 0,
                                B: 0,
                        },
                        DocPr: &amp;DocPr{
                                ID:    drawingID,
                                Name:  "Picture " + img.ID(),
                                Descr: img.Description(),
                        },
                        Graphic: newGraphic(img, size),
                },
        }
}</span>

// NewFloatingDrawing creates a floating drawing (absolute positioning).
func NewFloatingDrawing(img domain.Image, drawingID int) *Drawing <span class="cov0" title="0">{
        size := img.Size()
        pos := img.Position()
        
        // Convert position to anchor
        anchor := &amp;Anchor{
                DistT:          114300, // Default distances (0.125 inch)
                DistB:          114300,
                DistL:          114300,
                DistR:          114300,
                RelativeHeight: pos.ZOrder,
                BehindDoc:      pos.BehindText,
                Locked:         false,
                LayoutInCell:   true,
                AllowOverlap:   true,
                SimplePos: &amp;SimplePos{
                        X: 0,
                        Y: 0,
                },
                Extent: &amp;Extent{
                        Cx: size.WidthEMU,
                        Cy: size.HeightEMU,
                },
                EffectExtent: &amp;EffectExtent{
                        L: 0,
                        T: 0,
                        R: 0,
                        B: 0,
                },
                DocPr: &amp;DocPr{
                        ID:    drawingID,
                        Name:  "Picture " + img.ID(),
                        Descr: img.Description(),
                },
                Graphic: newGraphic(img, size),
        }

        // Set horizontal position
        anchor.PositionH = &amp;PositionH{
                RelativeFrom: convertHAlign(pos.HAlign),
        }
        if pos.OffsetX != 0 </span><span class="cov0" title="0">{
                offset := pos.OffsetX
                anchor.PositionH.PosOffset = &amp;offset
        }</span> else<span class="cov0" title="0"> {
                align := string(pos.HAlign)
                anchor.PositionH.Align = &amp;align
        }</span>

        // Set vertical position
        <span class="cov0" title="0">anchor.PositionV = &amp;PositionV{
                RelativeFrom: convertVAlign(pos.VAlign),
        }
        if pos.OffsetY != 0 </span><span class="cov0" title="0">{
                offset := pos.OffsetY
                anchor.PositionV.PosOffset = &amp;offset
        }</span> else<span class="cov0" title="0"> {
                align := string(pos.VAlign)
                anchor.PositionV.Align = &amp;align
        }</span>

        // Set wrap type
        <span class="cov0" title="0">if pos.WrapText != domain.WrapNone </span><span class="cov0" title="0">{
                anchor.WrapType = &amp;WrapType{
                        WrapText: "bothSides",
                }
        }</span>

        <span class="cov0" title="0">return &amp;Drawing{
                Anchor: anchor,
        }</span>
}

// newGraphic creates the graphic content for an image.
func newGraphic(img domain.Image, size domain.ImageSize) *Graphic <span class="cov0" title="0">{
        return &amp;Graphic{
                Xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
                GraphicData: &amp;GraphicData{
                        URI: "http://schemas.openxmlformats.org/drawingml/2006/picture",
                        Pic: &amp;Pic{
                                Xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture",
                                NvPicPr: &amp;NvPicPr{
                                        CNvPr: &amp;CNvPr{
                                                ID:    0,
                                                Name:  "Picture " + img.ID(),
                                                Descr: img.Description(),
                                        },
                                        CNvPicPr: &amp;CNvPicPr{
                                                PicLocks: &amp;PicLocks{
                                                        NoChangeAspect: true,
                                                },
                                        },
                                },
                                BlipFill: &amp;BlipFill{
                                        Blip: &amp;Blip{
                                                Xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
                                                Embed: img.RelationshipID(),
                                        },
                                        Stretch: &amp;Stretch{
                                                FillRect: &amp;FillRect{},
                                        },
                                },
                                SpPr: &amp;SpPr{
                                        Xfrm: &amp;Xfrm{
                                                Off: &amp;Off{X: 0, Y: 0},
                                                Ext: &amp;Ext{
                                                        Cx: size.WidthEMU,
                                                        Cy: size.HeightEMU,
                                                },
                                        },
                                        PrstGeom: &amp;PrstGeom{
                                                Prst:  "rect",
                                                AvLst: &amp;AvLst{},
                                        },
                                },
                        },
                },
        }
}</span>

// convertHAlign converts domain horizontal alignment to XML relative from.
func convertHAlign(align domain.HorizontalAlign) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.HAlignLeft:<span class="cov0" title="0">
                return "column"</span>
        case domain.HAlignCenter:<span class="cov0" title="0">
                return "column"</span>
        case domain.HAlignRight:<span class="cov0" title="0">
                return "column"</span>
        case domain.HAlignInside:<span class="cov0" title="0">
                return "margin"</span>
        case domain.HAlignOutside:<span class="cov0" title="0">
                return "margin"</span>
        default:<span class="cov0" title="0">
                return "column"</span>
        }
}

// convertVAlign converts domain vertical alignment to XML relative from.
func convertVAlign(align domain.VerticalAlign) string <span class="cov0" title="0">{
        switch align </span>{
        case domain.VAlignTop:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.VAlignCenter:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.VAlignBottom:<span class="cov0" title="0">
                return "paragraph"</span>
        case domain.VAlignInside:<span class="cov0" title="0">
                return "margin"</span>
        case domain.VAlignOutside:<span class="cov0" title="0">
                return "margin"</span>
        default:<span class="cov0" title="0">
                return "paragraph"</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package xml

import "encoding/xml"

// FieldSimple represents a w:fldSimple element for simple fields.
// Complex fields use: w:fldChar (begin) -&gt; w:instrText -&gt; w:fldChar (separate) -&gt; result -&gt; w:fldChar (end)
type FieldSimple struct {
        XMLName xml.Name `xml:"w:fldSimple"`
        Instr   string   `xml:"w:instr,attr"`
        Text    *Text    `xml:"w:t,omitempty"`
}

// FieldChar represents w:fldChar element (field character).
type FieldChar struct {
        XMLName  xml.Name `xml:"w:fldChar"`
        FldType  string   `xml:"w:fldCharType,attr"` // begin, separate, end
        Dirty    *bool    `xml:"w:dirty,attr,omitempty"`
        FldLock  *bool    `xml:"w:fldLock,attr,omitempty"`
}

// InstrText represents w:instrText element (field instruction text).
type InstrText struct {
        XMLName xml.Name `xml:"w:instrText"`
        Space   string   `xml:"xml:space,attr,omitempty"`
        Content string   `xml:",chardata"`
}

// NewFieldBegin creates a field begin character.
func NewFieldBegin() *FieldChar <span class="cov10" title="3">{
        return &amp;FieldChar{
                FldType: "begin",
        }
}</span>

// NewFieldSeparate creates a field separate character.
func NewFieldSeparate() *FieldChar <span class="cov6" title="2">{
        return &amp;FieldChar{
                FldType: "separate",
        }
}</span>

// NewFieldEnd creates a field end character.
func NewFieldEnd() *FieldChar <span class="cov6" title="2">{
        return &amp;FieldChar{
                FldType: "end",
        }
}</span>

// NewInstrText creates a field instruction text element.
func NewInstrText(instruction string) *InstrText <span class="cov10" title="3">{
        return &amp;InstrText{
                Space:   "preserve",
                Content: instruction,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package xml

import "encoding/xml"

// Header represents a Word header document (header1.xml, header2.xml, etc.)
type Header struct {
        XMLName    xml.Name     `xml:"w:hdr"`
        Xmlns      string       `xml:"xmlns:w,attr"`
        XmlnsR     string       `xml:"xmlns:r,attr"`
        Paragraphs []*Paragraph `xml:"w:p"`
}

// Footer represents a Word footer document (footer1.xml, footer2.xml, etc.)
type Footer struct {
        XMLName    xml.Name     `xml:"w:ftr"`
        Xmlns      string       `xml:"xmlns:w,attr"`
        XmlnsR     string       `xml:"xmlns:r,attr"`
        Paragraphs []*Paragraph `xml:"w:p"`
}

// NewHeader creates a new header document.
func NewHeader() *Header <span class="cov8" title="1">{
        return &amp;Header{
                Xmlns:      "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
                XmlnsR:     "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
                Paragraphs: make([]*Paragraph, 0),
        }
}</span>

// NewFooter creates a new footer document.
func NewFooter() *Footer <span class="cov8" title="1">{
        return &amp;Footer{
                Xmlns:      "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
                XmlnsR:     "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
                Paragraphs: make([]*Paragraph, 0),
        }
}</span>

// AddParagraph adds a paragraph to the header.
func (h *Header) AddParagraph(p *Paragraph) <span class="cov8" title="1">{
        h.Paragraphs = append(h.Paragraphs, p)
}</span>

// AddParagraph adds a paragraph to the footer.
func (f *Footer) AddParagraph(p *Paragraph) <span class="cov8" title="1">{
        f.Paragraphs = append(f.Paragraphs, p)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package xml

import "encoding/xml"

// SectionProperties represents w:sectPr element (section properties).
type SectionProperties struct {
        XMLName     xml.Name     `xml:"w:sectPr"`
        PageSize    *PageSize    `xml:"w:pgSz,omitempty"`
        PageMargins *PageMargins `xml:"w:pgMar,omitempty"`
        Columns     *Columns     `xml:"w:cols,omitempty"`
        HeaderRef   []HeaderRef  `xml:"w:headerReference,omitempty"`
        FooterRef   []FooterRef  `xml:"w:footerReference,omitempty"`
        Type        *SectionType `xml:"w:type,omitempty"`
}

// PageSize represents w:pgSz element (page size).
type PageSize struct {
        XMLName xml.Name `xml:"w:pgSz"`
        Width   int      `xml:"w:w,attr"`              // Width in twips
        Height  int      `xml:"w:h,attr"`              // Height in twips
        Orient  string   `xml:"w:orient,attr,omitempty"` // portrait or landscape
}

// PageMargins represents w:pgMar element (page margins).
type PageMargins struct {
        XMLName xml.Name `xml:"w:pgMar"`
        Top     int      `xml:"w:top,attr"`
        Right   int      `xml:"w:right,attr"`
        Bottom  int      `xml:"w:bottom,attr"`
        Left    int      `xml:"w:left,attr"`
        Header  int      `xml:"w:header,attr"`
        Footer  int      `xml:"w:footer,attr"`
        Gutter  int      `xml:"w:gutter,attr,omitempty"`
}

// Columns represents w:cols element (column definition).
type Columns struct {
        XMLName xml.Name `xml:"w:cols"`
        Num     int      `xml:"w:num,attr,omitempty"`     // Number of columns
        Space   int      `xml:"w:space,attr,omitempty"`   // Space between columns
        Sep     *bool    `xml:"w:sep,attr,omitempty"`     // Draw separator line
}

// HeaderRef represents w:headerReference element.
type HeaderRef struct {
        XMLName xml.Name `xml:"w:headerReference"`
        Type    string   `xml:"w:type,attr"` // default, first, even
        ID      string   `xml:"r:id,attr"`   // Relationship ID
}

// FooterRef represents w:footerReference element.
type FooterRef struct {
        XMLName xml.Name `xml:"w:footerReference"`
        Type    string   `xml:"w:type,attr"` // default, first, even
        ID      string   `xml:"r:id,attr"`   // Relationship ID
}

// SectionType represents w:type element (section type).
type SectionType struct {
        XMLName xml.Name `xml:"w:type"`
        Val     string   `xml:"w:val,attr"` // nextPage, continuous, evenPage, oddPage
}

// NewSectionProperties creates a new section properties element.
func NewSectionProperties() *SectionProperties <span class="cov10" title="2">{
        return &amp;SectionProperties{
                HeaderRef: make([]HeaderRef, 0),
                FooterRef: make([]FooterRef, 0),
        }
}</span>

// SetPageSize sets the page size for the section.
func (sp *SectionProperties) SetPageSize(width, height int, landscape bool) <span class="cov1" title="1">{
        orient := "portrait"
        if landscape </span><span class="cov0" title="0">{
                orient = "landscape"
        }</span>
        <span class="cov1" title="1">sp.PageSize = &amp;PageSize{
                Width:  width,
                Height: height,
                Orient: orient,
        }</span>
}

// SetPageMargins sets the page margins for the section.
func (sp *SectionProperties) SetPageMargins(top, right, bottom, left, header, footer int) <span class="cov1" title="1">{
        sp.PageMargins = &amp;PageMargins{
                Top:    top,
                Right:  right,
                Bottom: bottom,
                Left:   left,
                Header: header,
                Footer: footer,
        }
}</span>

// SetColumns sets the number of columns for the section.
func (sp *SectionProperties) SetColumns(num int) <span class="cov1" title="1">{
        sp.Columns = &amp;Columns{
                Num: num,
        }
}</span>

// AddHeaderRef adds a header reference.
func (sp *SectionProperties) AddHeaderRef(headerType, rID string) <span class="cov1" title="1">{
        sp.HeaderRef = append(sp.HeaderRef, HeaderRef{
                Type: headerType,
                ID:   rID,
        })
}</span>

// AddFooterRef adds a footer reference.
func (sp *SectionProperties) AddFooterRef(footerType, rID string) <span class="cov1" title="1">{
        sp.FooterRef = append(sp.FooterRef, FooterRef{
                Type: footerType,
                ID:   rID,
        })
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



package xml

import "encoding/xml"

// Styles represents the styles.xml document.
type Styles struct {
        XMLName  xml.Name `xml:"w:styles"`
        Xmlns    string   `xml:"xmlns:w,attr"`
        DocDefaults *DocDefaults `xml:"w:docDefaults,omitempty"`
        Styles   []*Style `xml:"w:style"`
}

// DocDefaults represents w:docDefaults element.
type DocDefaults struct {
        XMLName         xml.Name               `xml:"w:docDefaults"`
        RunDefaults     *RunDefaults           `xml:"w:rPrDefault,omitempty"`
        ParaDefaults    *ParagraphDefaults     `xml:"w:pPrDefault,omitempty"`
}

// RunDefaults represents default run properties.
type RunDefaults struct {
        XMLName    xml.Name       `xml:"w:rPrDefault"`
        Properties *RunProperties `xml:"w:rPr,omitempty"`
}

// ParagraphDefaults represents default paragraph properties.
type ParagraphDefaults struct {
        XMLName    xml.Name                  `xml:"w:pPrDefault"`
        Properties *StyleParagraphProperties `xml:"w:pPr,omitempty"`
}

// Style represents w:style element.
type Style struct {
        XMLName       xml.Name                  `xml:"w:style"`
        Type          string                    `xml:"w:type,attr"`           // paragraph, character, table, numbering
        StyleID       string                    `xml:"w:styleId,attr"`
        Default       *bool                     `xml:"w:default,attr,omitempty"`
        CustomStyle   *bool                     `xml:"w:customStyle,attr,omitempty"`
        Name          *StyleName                `xml:"w:name,omitempty"`
        BasedOn       *BasedOn                  `xml:"w:basedOn,omitempty"`
        Next          *Next                     `xml:"w:next,omitempty"`
        UIPriority    *UIPriority               `xml:"w:uiPriority,omitempty"`
        QFormat       *struct{}                 `xml:"w:qFormat,omitempty"`
        RunProps      *RunProperties            `xml:"w:rPr,omitempty"`
        ParaProps     *StyleParagraphProperties `xml:"w:pPr,omitempty"`
}

// StyleName represents w:name element.
type StyleName struct {
        XMLName xml.Name `xml:"w:name"`
        Val     string   `xml:"w:val,attr"`
}

// BasedOn represents w:basedOn element.
type BasedOn struct {
        XMLName xml.Name `xml:"w:basedOn"`
        Val     string   `xml:"w:val,attr"`
}

// Next represents w:next element (next paragraph style).
type Next struct {
        XMLName xml.Name `xml:"w:next"`
        Val     string   `xml:"w:val,attr"`
}

// UIPriority represents w:uiPriority element.
type UIPriority struct {
        XMLName xml.Name `xml:"w:uiPriority"`
        Val     int      `xml:"w:val,attr"`
}

// StyleParagraphProperties represents w:pPr element (paragraph properties in styles).
type StyleParagraphProperties struct {
        XMLName         xml.Name          `xml:"w:pPr"`
        Alignment       *Alignment        `xml:"w:jc,omitempty"`
        SpacingBefore   *StyleSpacing     `xml:"w:spacing,omitempty"`
        Indentation     *StyleIndentation `xml:"w:ind,omitempty"`
        KeepNext        *struct{}         `xml:"w:keepNext,omitempty"`
        KeepLines       *struct{}         `xml:"w:keepLines,omitempty"`
        PageBreakBefore *struct{}         `xml:"w:pageBreakBefore,omitempty"`
        OutlineLevel    *OutlineLevel     `xml:"w:outlineLvl,omitempty"`
}

// Alignment represents w:jc element (justification/alignment).
type Alignment struct {
        XMLName xml.Name `xml:"w:jc"`
        Val     string   `xml:"w:val,attr"` // left, center, right, both (justified), distribute
}

// StyleSpacing represents w:spacing element (paragraph spacing in styles).
type StyleSpacing struct {
        XMLName     xml.Name `xml:"w:spacing"`
        Before      *int     `xml:"w:before,attr,omitempty"`      // Space before in twips
        After       *int     `xml:"w:after,attr,omitempty"`       // Space after in twips
        Line        *int     `xml:"w:line,attr,omitempty"`        // Line spacing
        LineRule    string   `xml:"w:lineRule,attr,omitempty"`    // auto, exact, atLeast
}

// StyleIndentation represents w:ind element (paragraph indentation in styles).
type StyleIndentation struct {
        XMLName   xml.Name `xml:"w:ind"`
        Left      *int     `xml:"w:left,attr,omitempty"`      // Left indent in twips
        Right     *int     `xml:"w:right,attr,omitempty"`     // Right indent in twips
        FirstLine *int     `xml:"w:firstLine,attr,omitempty"` // First line indent
        Hanging   *int     `xml:"w:hanging,attr,omitempty"`   // Hanging indent
}

// OutlineLevel represents w:outlineLvl element (outline level 0-9).
type OutlineLevel struct {
        XMLName xml.Name `xml:"w:outlineLvl"`
        Val     int      `xml:"w:val,attr"`
}

// NewStyles creates a new styles document.
func NewStyles() *Styles <span class="cov6" title="2">{
        return &amp;Styles{
                Xmlns:  "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
                Styles: make([]*Style, 0),
        }
}</span>

// AddStyle adds a style to the styles collection.
func (s *Styles) AddStyle(style *Style) <span class="cov10" title="3">{
        s.Styles = append(s.Styles, style)
}</span>

// NewParagraphStyle creates a new paragraph style.
func NewParagraphStyle(styleID, name string, isDefault bool) *Style <span class="cov6" title="2">{
        style := &amp;Style{
                Type:    "paragraph",
                StyleID: styleID,
                Name:    &amp;StyleName{Val: name},
        }
        if isDefault </span><span class="cov1" title="1">{
                defaultVal := true
                style.Default = &amp;defaultVal
        }</span>
        <span class="cov6" title="2">return style</span>
}

// NewCharacterStyle creates a new character style.
func NewCharacterStyle(styleID, name string, isDefault bool) *Style <span class="cov1" title="1">{
        style := &amp;Style{
                Type:    "character",
                StyleID: styleID,
                Name:    &amp;StyleName{Val: name},
        }
        if isDefault </span><span class="cov0" title="0">{
                defaultVal := true
                style.Default = &amp;defaultVal
        }</span>
        <span class="cov1" title="1">return style</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



// Package color provides color utilities for go-docx v2.
package color

import (
        "fmt"
        "strconv"

        "github.com/mmonterroca/docxgo/domain"
        "github.com/mmonterroca/docxgo/pkg/errors"
)

// Common color constants for convenience.
var (
        Black   = domain.Color{R: 0, G: 0, B: 0}
        White   = domain.Color{R: 255, G: 255, B: 255}
        Red     = domain.Color{R: 255, G: 0, B: 0}
        Green   = domain.Color{R: 0, G: 128, B: 0}
        Blue    = domain.Color{R: 0, G: 0, B: 255}
        Yellow  = domain.Color{R: 255, G: 255, B: 0}
        Cyan    = domain.Color{R: 0, G: 255, B: 255}
        Magenta = domain.Color{R: 255, G: 0, B: 255}
        Orange  = domain.Color{R: 255, G: 165, B: 0}
        Purple  = domain.Color{R: 128, G: 0, B: 128}
        Gray    = domain.Color{R: 128, G: 128, B: 128}
        Silver  = domain.Color{R: 192, G: 192, B: 192}
)

// ToHex converts a Color to a hex string (e.g., "FF0000" for red).
func ToHex(c domain.Color) string <span class="cov0" title="0">{
        return fmt.Sprintf("%02X%02X%02X", c.R, c.G, c.B)
}</span>

// FromHex creates a Color from a hex string.
// Accepts formats: "RGB", "RRGGBB", "#RGB", "#RRGGBB"
func FromHex(hex string) (domain.Color, error) <span class="cov0" title="0">{
        // Remove # if present
        if len(hex) &gt; 0 &amp;&amp; hex[0] == '#' </span><span class="cov0" title="0">{
                hex = hex[1:]
        }</span>

        <span class="cov0" title="0">var r, g, b uint8

        switch len(hex) </span>{
        case 3:<span class="cov0" title="0">
                // Short form: RGB -&gt; RRGGBB
                rv, err := strconv.ParseUint(string(hex[0]), 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid red component")
                }</span>
                <span class="cov0" title="0">gv, err := strconv.ParseUint(string(hex[1]), 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid green component")
                }</span>
                <span class="cov0" title="0">bv, err := strconv.ParseUint(string(hex[2]), 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid blue component")
                }</span>
                <span class="cov0" title="0">r = uint8(rv*16 + rv)
                g = uint8(gv*16 + gv)
                b = uint8(bv*16 + bv)</span>

        case 6:<span class="cov0" title="0">
                // Full form: RRGGBB
                rv, err := strconv.ParseUint(hex[0:2], 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid red component")
                }</span>
                <span class="cov0" title="0">gv, err := strconv.ParseUint(hex[2:4], 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid green component")
                }</span>
                <span class="cov0" title="0">bv, err := strconv.ParseUint(hex[4:6], 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex, "invalid blue component")
                }</span>
                <span class="cov0" title="0">r = uint8(rv)
                g = uint8(gv)
                b = uint8(bv)</span>

        default:<span class="cov0" title="0">
                return domain.Color{}, errors.InvalidArgument("FromHex", "hex", hex,
                        "hex color must be 3 or 6 characters (optionally prefixed with #)")</span>
        }

        <span class="cov0" title="0">return domain.Color{R: r, G: g, B: b}, nil</span>
}

// Validate checks if a color is valid (all components in range 0-255).
func Validate(_ domain.Color) error <span class="cov0" title="0">{
        // uint8 automatically ensures 0-255 range, so this is always valid
        return nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
MIT License

Copyright (c) 2025 Misael Montero
Copyright (c) 2020-2023 fumiama (original go-docx)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



// Package errors provides structured error types for go-docx v2.
package errors

import (
        "fmt"
        "strings"
)

// Error codes for categorizing errors
const (
        ErrCodeValidation   = "VALIDATION_ERROR"
        ErrCodeNotFound     = "NOT_FOUND"
        ErrCodeInvalidState = "INVALID_STATE"
        ErrCodeIO           = "IO_ERROR"
        ErrCodeXML          = "XML_ERROR"
        ErrCodeInternal     = "INTERNAL_ERROR"
        ErrCodeUnsupported  = "UNSUPPORTED"
)

// DocxError represents a structured error in go-docx v2.
type DocxError struct {
        Code    string                 // Error code (e.g., "VALIDATION_ERROR")
        Op      string                 // Operation that failed (e.g., "Document.AddParagraph")
        Err     error                  // Underlying error
        Message string                 // Human-readable message
        Context map[string]interface{} // Additional context
}

// Error implements the error interface.
func (e *DocxError) Error() string <span class="cov0" title="0">{
        var parts []string

        if e.Op != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("operation=%s", e.Op))
        }</span>

        <span class="cov0" title="0">if e.Code != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("code=%s", e.Code))
        }</span>

        <span class="cov0" title="0">if e.Message != "" </span><span class="cov0" title="0">{
                parts = append(parts, e.Message)
        }</span>

        <span class="cov0" title="0">if e.Err != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("cause=%v", e.Err))
        }</span>

        <span class="cov0" title="0">if len(e.Context) &gt; 0 </span><span class="cov0" title="0">{
                var ctx []string
                for k, v := range e.Context </span><span class="cov0" title="0">{
                        ctx = append(ctx, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov0" title="0">parts = append(parts, fmt.Sprintf("context={%s}", strings.Join(ctx, ", ")))</span>
        }

        <span class="cov0" title="0">return strings.Join(parts, " | ")</span>
}

// Unwrap returns the underlying error.
func (e *DocxError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// Is checks if the error matches the target error.
func (e *DocxError) Is(target error) bool <span class="cov0" title="0">{
        t, ok := target.(*DocxError)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return e.Code == t.Code</span>
}

// ValidationError represents a validation error.
type ValidationError struct {
        Field      string      // Field name that failed validation
        Value      interface{} // Invalid value
        Constraint string      // Constraint that was violated
        Message    string      // Human-readable message
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov0" title="0">{
        if e.Message != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("validation error: field=%s, value=%v, constraint=%s, message=%s",
                        e.Field, e.Value, e.Constraint, e.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("validation error: field=%s, value=%v, constraint=%s",
                e.Field, e.Value, e.Constraint)</span>
}

// BuilderError wraps an error and allows method chaining to continue
// while capturing the first error that occurred.
type BuilderError struct {
        err error
}

// Error implements the error interface.
func (b *BuilderError) Error() string <span class="cov0" title="0">{
        if b.err == nil </span><span class="cov0" title="0">{
                return "no error"
        }</span>
        <span class="cov0" title="0">return b.err.Error()</span>
}

// Unwrap returns the underlying error.
func (b *BuilderError) Unwrap() error <span class="cov0" title="0">{
        return b.err
}</span>

// HasError returns true if an error has been captured.
func (b *BuilderError) HasError() bool <span class="cov0" title="0">{
        return b.err != nil
}</span>

// Get returns the captured error (may be nil).
func (b *BuilderError) Get() error <span class="cov0" title="0">{
        return b.err
}</span>

// Set sets the error if one hasn't been set already.
func (b *BuilderError) Set(err error) <span class="cov0" title="0">{
        if b.err == nil &amp;&amp; err != nil </span><span class="cov0" title="0">{
                b.err = err
        }</span>
}

// Helper functions for creating common errors

// Errorf creates a new DocxError with formatted message.
func Errorf(code, op, format string, args ...interface{}) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code:    code,
                Op:      op,
                Message: fmt.Sprintf(format, args...),
        }
}</span>

// Wrap wraps an error with operation context.
func Wrap(err error, op string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DocxError{
                Code: ErrCodeInternal,
                Op:   op,
                Err:  err,
        }</span>
}

// WrapWithCode wraps an error with operation and error code.
func WrapWithCode(err error, code, op string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DocxError{
                Code: code,
                Op:   op,
                Err:  err,
        }</span>
}

// WrapWithContext wraps an error with operation and additional context.
func WrapWithContext(err error, op string, context map[string]interface{}) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DocxError{
                Code:    ErrCodeInternal,
                Op:      op,
                Err:     err,
                Context: context,
        }</span>
}

// NotFound creates a "not found" error.
func NotFound(op, item string) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code:    ErrCodeNotFound,
                Op:      op,
                Message: fmt.Sprintf("%s not found", item),
        }
}</span>

// InvalidState creates an "invalid state" error.
func InvalidState(op, message string) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code:    ErrCodeInvalidState,
                Op:      op,
                Message: message,
        }
}</span>

// Validation creates a validation error.
func Validation(field string, value interface{}, constraint, message string) error <span class="cov0" title="0">{
        return &amp;ValidationError{
                Field:      field,
                Value:      value,
                Constraint: constraint,
                Message:    message,
        }
}</span>

// NewValidationError creates a validation error with operation context.
// This is a convenience function for backward compatibility.
func NewValidationError(op, field string, value interface{}, message string) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code: ErrCodeValidation,
                Op:   op,
                Err: &amp;ValidationError{
                        Field:   field,
                        Value:   value,
                        Message: message,
                },
        }
}</span>

// NewNotFoundError creates a "not found" error.
// This is a convenience function for backward compatibility.
func NewNotFoundError(op, field string, value interface{}, message string) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code:    ErrCodeNotFound,
                Op:      op,
                Message: fmt.Sprintf("%s: %v - %s", field, value, message),
        }
}</span>

// InvalidArgument creates a validation error for invalid arguments.
func InvalidArgument(op, field string, value interface{}, message string) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code: ErrCodeValidation,
                Op:   op,
                Err: &amp;ValidationError{
                        Field:   field,
                        Value:   value,
                        Message: message,
                },
        }
}</span>

// Unsupported creates an "unsupported" error.
func Unsupported(op, feature string) error <span class="cov0" title="0">{
        return &amp;DocxError{
                Code:    ErrCodeUnsupported,
                Op:      op,
                Message: fmt.Sprintf("%s is not supported", feature),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
